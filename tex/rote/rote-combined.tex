\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{Hausarbeit: Rote-Learning anhand einer kÃ¼nstlichen Intelligenz fÃ¼r das Brettspiel MÃ¼hle}
    \author{Robert Franzke (7222940) und Joost Ole Seddig (8713483)}
    \date{}
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    
    \hypertarget{rote-learning}{%
\section{Einleitung}\label{rote-learning}}


    Der $\alpha$-$\beta$-Pruning Algorithmus versucht durch die Auswertung der zukÃ¼nftig
mÃ¶glichen ZÃ¼ge den Besten auszuwÃ¤hlen. Da der Suchraum jedoch zu groÃ
ist um jedes mÃ¶gliche Spiel zu betrachten, muss an einem bestimmten
Punkt das Vorausschauen beendet werden und eine SchÃ¤tzung statt dem
tatsÃ¤chlichen Wert verwendet werden. Diese Aufgabe Ã¼bernimmt die in dem
Notebook \texttt{nmm-heuristic} implementierte Heuristik. Dies bedeutet
dass eine kÃ¼nstliche Intelligenz, die den $\alpha$-$\beta$-Pruning Algorithmus
implementiert, je besser ist, desto mehr Schritte in die die Zukunft
geschaut werden kann. Die Laufzeit $\alpha$-$\beta$-Pruning Algorithmus nimmt jedoch
mit zunehmender Tiefe, aufgrund der sehr schnell ansteigenden Anzahl der
ZustÃ¤nde, deutlich zu. Somit ist eine Neuberechnung der SchÃ¤zung bei
jedem Zug nicht praktikabel.

An diesem Punkt setzt das Rote-Learning an: Indem der $\alpha$-$\beta$-Pruning
Algorithmus um eine elementare Form des Lernens erweitert wird, wird
dessen EffektivitÃ¤t stark gesteigert. Grundlegend werden bei der
Verwendung von Rote-Learning alle ZustÃ¤nde, die jemals besucht wurden,
zusammen mit den dazugehÃ¶rigen errechneten SchÃ¤tzungen abgespeichert.
Anstatt die WertschÃ¤tzung dieser ZustÃ¤nde bei jedem Zug neu zu
berechnen, kÃ¶nnen diese nun aus dem Speicher abgerufen werden. Dies
spart vor allem bei einer hohen Suchtiefe viel Rechenzeit ein. Diese
Einsparung der Rechenzeit kann darauf verwendet werden, weitere ZustÃ¤nde
zu berechnen und somit die QualitÃ¤t der SchÃ¤tzungen zu erhÃ¶hen. Da mit
jedem Spiel mehr ZustÃ¤nde und deren SchÃ¤tzungen gespeichert werden,
verbessert sich das Ergebnis des Algorithmus Ã¼ber Zeit. Es tritt also
ein Lerneffekt ein.

    \hypertarget{implementierung}{%
\subsection{Implementierung}\label{implementierung}}

Um das oben genannte Prinzip von Rote-Learning in Python zu
implementieren, wurde auf eine bereits fertige Implementierung des
$\alpha$-$\beta$-Pruning Algorithmus fÃ¼r das Spiel MÃ¼hle zurÃ¼ck gegriffen.
Dieser wurde im Rahmen der Studienarbeit entwickelt und musste fÃ¼r die
Verwendung von Rote-Learning nur noch geringfÃ¼gig angepasst werden. Um
zu evaluieren ob Rote-Learning einen Vorteil gegenÃ¼ber einem nicht
trainierten Algorithmus herbeifÃ¼hrt, werden folgende Notebooks benÃ¶tigt:

\begin{itemize}
\tightlist
\item
  \texttt{nmm-cache} implementiert eine schnelle, persistierbare
  Transpositionstabelle (auch Cache genannt);
\item
  \texttt{nmm-rote-training} implementierung ein Klasse fÃ¼r den
  Trainingsteil des Rote-Learnings;
\item
  \texttt{nmm-alpha-beta-pruning} ist eine bereits vorhandene
  Implementierung des $\alpha$-$\beta$-Pruning Algorithmus;
\item
  \texttt{nmm-tournament} ist eine ebenfalls bereits vorhandene
  Implementierung zur Evaluation, ob ein per Rote-Learning trainierter
  Algorithmus besser abschneidet als ein nicht trainierter Algorithmus.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}cache.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}rote\PYZhy{}training.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}alpha\PYZhy{}beta\PYZhy{}pruning.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}tournament.ipynb
\end{Verbatim}
\end{tcolorbox}

    Desweitern wird das Paket \texttt{memory\_profiler} eingebunden, welches
die Ãberwachung der Auslastung des Arbeitsspeichers ermÃ¶glicht.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{memory\PYZus{}profiler} \PY{k+kn}{import} \PY{n}{memory\PYZus{}usage}
\end{Verbatim}
\end{tcolorbox}


    


    
\hypertarget{persistente-transpositionstabelle}{%
\section{nmm-cache: Persistente
Transpositionstabelle}\label{persistente-transpositionstabelle}}

    Der Training Prozess des Rote-Learnings ist sehr zeitaufwendig, da viele
Spiele gespielt werden mÃ¼ssen. Damit dieser Prozess nicht vor jedem
Spiel ausgefÃ¼hrt werden muss, ist es sinnvoll die trainierte
Transpositionstabelle persistent auf der Festplatte abspeichern zu
kÃ¶nnen. Es gibt mehrere MÃ¶glichkeiten diese Transpositionstabelle zu
implementieren, jedoch ist die Geschwindigkeit hier einer des
ausschlaggebendsten Faktoren. Um zu ermitteln wie die Tabelle
implementiert werden soll, wurde also ein Geschwindigkeitsvergleich
erstellt. Dieser ist im Notebook \texttt{nmm-rote-performance-testing}
zu finden. Das Ergebnis dieses Vergleiches hat ergeben, dass sich ein
Python-Dictionary im Arbeitsspeicher gut eignet. Dieses kann ebenfalls
in einer binÃ¤ren Datei auf einem DatentrÃ¤ger persistiert werden.

    \hypertarget{cache}{%
\subsection{Cache}\label{cache}}

Die Klasse \texttt{Cache} implementiert eine Transpositionstabelle die
persistiert werden kann. Der Konstruktor erhÃ¤lt folgenden Parameter:

\begin{itemize}
    \tightlist
    \item \texttt{max\_size} gibt an, wie viele EintrÃ¤ge sich maximal im Cache
    befinden dÃ¼rfen, bevor EintrÃ¤ge mit dem geringsten Rekursionslimit
    entfernt werden.
    \item \texttt{path} gibt an, aus welcher Datei der Cache
    geladen werden soll. Ist dieser nicht gesetzt wird ein neuer leerer
    Cache initiiert.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Cache}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{1\PYZus{}000\PYZus{}000}\PY{p}{,} \PY{n}{path}\PY{p}{:} \PY{n+nb}{str} \PY{o}{=} \PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{n}{max\PYZus{}size}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
        \PY{k}{if} \PY{n}{path}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{load}\PY{p}{(}\PY{n}{path}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r Entwicklungszwecke wird eine Stringdarstellung fÃ¼r die Klasse
\texttt{Cache} implementiert. Hierzu wird durch die Funktion
\texttt{\_\_repr\_\_} ein String zurÃ¼ckgegeben, der alle Parameter der
Klasse beinhaltet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n+nb}{str}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Cache(size=}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, max\PYZus{}size=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}size}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{Cache}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    Damit die ZustÃ¤nde und die Werte direkt als Bytes gespeichert und wieder
ausgelesen werden kÃ¶nnen, ist das Paket \texttt{struct} nÃ¶tig. Dieses
ermÃ¶glicht \texttt{float} Werte zu \texttt{bytes} zu konvertieren. Das
Paket \texttt{tqdm} ermÃ¶glicht eine simple Fortschrittsanzeige.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{struct}
\PY{k+kn}{from} \PY{n+nn}{tqdm}\PY{n+nn}{.}\PY{n+nn}{notebook} \PY{k+kn}{import} \PY{n}{tqdm}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{convert\_state\_to\_bytes} konvertiert einen Zustand
in ein Byte-Array der LÃ¤nge 7. Der Zustand wird dabei immer auf den
weiÃen Spieler normiert. Durch die Normierung mÃ¼ssen die ZustÃ¤nde nur
noch fÃ¼r einen Spieler gespeichert werden, worduch fÃ¼r die gleiche Menge
an effektiv verwendbaren ZustÃ¤nden nur noch die HÃ¤lfte des Speichers
benÃ¶tigt wird. Diese Optimierung ist jedoch nur effektiv, wenn beide
Spieler die gleiche Anzahl an Steinen haben. In der ersten Phase liegt
bei dem weiÃen Spieler (meist) ein Stein mehr auf dem Spielbrett als bei
dem schwarzen Spieler. Deshalb bringt die Normierung zu Beginn in den
meisten FÃ¤llen nichts, im spÃ¤teren Verlauf ist sie jedoch sinnvoll.

Dabei werden folgende Argumente erwartet:

\begin{itemize}
    \tightlist
    \item \texttt{state} \(\in States\);
    \item \texttt{player} \(\in Player\).
\end{itemize}

Das resultierende Byte-Array besteht aus:

\begin{itemize}
    \tightlist
    \item \texttt{bytes{[}0{]}}
    beinhaltet den Stapel, wobei die ersten 4 Bits vom weiÃen und die
    letzten 4 Bits vom schwarzen Spieler belegt sind;
    \item \texttt{bytes{[}1:3{]}} beinhaltet die Steine des weiÃen Spielers auf
    dem Spielbrett, beginnend mit dem inneren Ring und dem letzten Stein des
    Ringes;
    \item \texttt{bytes{[}4:7{]}} beinhaltet die Steine des schwarzen
    Spielers auf dem Spielbrett im gleichen Format.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{convert\PYZus{}state\PYZus{}to\PYZus{}bytes}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{:}
    \PY{n}{players} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
    \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
        \PY{n}{players} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
        \PY{n}{state} \PY{o}{=} \PY{p}{(}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
    \PY{n}{byte\PYZus{}data} \PY{o}{=} \PY{p}{(}\PY{p}{(}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{\PYZlt{}\PYZlt{}} \PY{l+m+mi}{4}\PY{p}{)} \PY{o}{|} \PY{n}{state}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{for} \PY{n}{player} \PY{o+ow}{in} \PY{n}{players}\PY{p}{:}
        \PY{k}{for} \PY{n}{ring} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
            \PY{n}{ring\PYZus{}byte} \PY{o}{=} \PY{l+m+mi}{0}
            \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
                \PY{n}{ring\PYZus{}byte} \PY{o}{\PYZlt{}\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{1}
                \PY{k}{if} \PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{n}{ring}\PY{p}{]}\PY{p}{[}\PY{n}{cell}\PY{p}{]} \PY{o+ow}{is} \PY{n}{player}\PY{p}{:}
                    \PY{n}{ring\PYZus{}byte} \PY{o}{|}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{n}{byte\PYZus{}data} \PY{o}{+}\PY{o}{=} \PY{n}{ring\PYZus{}byte}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{return} \PY{n}{byte\PYZus{}data}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{write} schreibt einen Zustand in die
Transpositionstabelle. Dabei wird der Zustand auf den weiÃen Spieler
normiert. Es werden folgende Argumente erwartet:

\begin{itemize}
    \tightlist
    \item \texttt{state} \(\in States\);
    \item \texttt{player} \(\in Player\);
    \item \texttt{limit} \(\in \mathbb{N}_0\);
    \item \texttt{value} \(\in \mathopen[-1.0,1.0\mathclose]\);
    \item \texttt{alpha} \(\in \mathopen[-1.0,1.0\mathclose]\);
    \item \texttt{beta} \(\in \mathopen[-1.0,1.0\mathclose]\).
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{write}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{str}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{value}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{alpha}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{beta}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{k+kc}{None}\PY{p}{:}
    \PY{n}{state} \PY{o}{=} \PY{n}{convert\PYZus{}state\PYZus{}to\PYZus{}bytes}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}
    \PY{n}{key} \PY{o}{=} \PY{n}{state} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
        \PY{n}{value}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{n}{value}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{beta}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{alpha}
    \PY{n}{value} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{alpha}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{beta}\PY{p}{)}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}

\PY{n}{Cache}\PY{o}{.}\PY{n}{write} \PY{o}{=} \PY{n}{write}
\PY{k}{del} \PY{n}{write}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{read} liest einen vorher gespeicherten Zustand aus
der Transpositionstabelle aus. Falls der Zustand nicht vorhanden ist
wird \texttt{None} zurÃ¼ckgegeben. Dabei wird die Normierung auf den
weiÃen Spieler rÃ¼ckgÃ¤ngig gemacht. Folgende Argumente werden erwartet:

\begin{itemize}
    \tightlist
    \item \texttt{state} \(\in States\);
    \item \texttt{player} \(\in Player\);
    \item \texttt{limit} \(\in \mathbb{N}_0\).
\end{itemize}

ZurÃ¼ckgegeben wird ein Tripel bestehend aus:

\begin{enumerate}
    \tightlist
    \item \texttt{value} \(\in \mathopen[-1.0,1.0\mathclose]\);
    \item \texttt{alpha} \(\in \mathopen[-1.0,1.0\mathclose]\);
    \item \texttt{beta} \(\in \mathopen[-1.0,1.0\mathclose]\).
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{read}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{str}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{p}{(}\PY{n+nb}{float}\PY{p}{,}\PY{n+nb}{float}\PY{p}{,}\PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
    \PY{n}{state} \PY{o}{=} \PY{n}{convert\PYZus{}state\PYZus{}to\PYZus{}bytes}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}
    \PY{n}{key} \PY{o}{=} \PY{n}{state} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{n}{result} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{result}\PY{p}{:}
        \PY{k}{return} \PY{k+kc}{None}
    \PY{n}{value} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{8}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{n}{alpha} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{[}\PY{l+m+mi}{8}\PY{p}{:}\PY{l+m+mi}{16}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{n}{beta} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{[}\PY{l+m+mi}{16}\PY{p}{:}\PY{l+m+mi}{24}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
        \PY{n}{value}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{n}{value}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{beta}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{alpha}
    \PY{k}{return} \PY{p}{(}\PY{n}{value}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{)}

\PY{n}{Cache}\PY{o}{.}\PY{n}{read} \PY{o}{=} \PY{n}{read}
\PY{k}{del} \PY{n}{read}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{clean} prÃ¼ft ob der Cache seine maximale GrÃ¶Ãe
Ã¼berschritten hat. Ist dies der Fall werden EintrÃ¤ge beginnend mit dem
Rekursionslimit \(limit = 0\) aus dem Cache entfernt. Solange die
Transpositionstabelle weiterhin ihre maximale GrÃ¶Ãe Ã¼berschreitet, wird
das minimale Rekursionslimit erhÃ¶ht und die unterschreitenden EintrÃ¤ge
gelÃ¶scht.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{clean}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{)}\PY{p}{:}
    \PY{n}{min\PYZus{}limit} \PY{o}{=} \PY{l+m+mi}{0}
    
    \PY{k}{while} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}size}\PY{p}{:}
        \PY{n}{min\PYZus{}limit} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        
        \PY{n}{pre\PYZus{}len} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{p}{\PYZob{}}
            \PY{n}{key}\PY{p}{:} \PY{n}{value}
            \PY{k}{for} \PY{n}{key}\PY{p}{,} \PY{n}{value} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}
            \PY{k}{if} \PY{n}{key}\PY{p}{[}\PY{l+m+mi}{7}\PY{p}{]} \PY{o}{\PYZgt{}} \PY{n}{min\PYZus{}limit}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Increased min\PYZus{}limit to }\PY{l+s+si}{\PYZob{}}\PY{n}{min\PYZus{}limit}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ and deleted }\PY{l+s+si}{\PYZob{}}\PY{n}{pre\PYZus{}len} \PY{o}{\PYZhy{}} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ entries. }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
              \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Cache is now }\PY{l+s+si}{\PYZob{}}\PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ entries big.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    
    \PY{k}{return} \PY{n}{min\PYZus{}limit} \PY{o}{!=} \PY{l+m+mi}{0}

\PY{n}{Cache}\PY{o}{.}\PY{n}{clean} \PY{o}{=} \PY{n}{clean}
\PY{k}{del} \PY{n}{clean}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{save} persistiert den Cache auf dem Dateisystem.
DafÃ¼r wird folgendes Argument erwartet:
\begin{itemize}
    \tightlist
    \item \texttt{path} beschreibt den Pfad zur zu schreibenden Datei im Dateisystem.    
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{save}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{,} \PY{n}{path}\PY{p}{:} \PY{n+nb}{str}\PY{p}{)}\PY{p}{:}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{n}{path}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{wb}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{k}{for} \PY{n}{key}\PY{p}{,}\PY{n}{value} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{:}
            \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{key}\PY{p}{)}
            \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{value}\PY{p}{)}

\PY{n}{Cache}\PY{o}{.}\PY{n}{save} \PY{o}{=} \PY{n}{save}
\PY{k}{del} \PY{n}{save}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{load} lÃ¤dt einen zuvor persistierten Cache aus einer
Datei, die sich auf dem Dateisystem des Computers befindet. DafÃ¼r wird
folgendes Argument erwartet: 

\begin{itemize}
    \tightlist
    \item \texttt{path} beschreibt den Pfad zur zu lesenden Datei im Dateisystem.    
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{load}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{,} \PY{n}{path}\PY{p}{:} \PY{n+nb}{str}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{n}{path}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Failed to load cache from file }\PY{l+s+si}{\PYZob{}}\PY{n}{path}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{return}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{n}{path}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rb}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{k}{while} \PY{k+kc}{True}\PY{p}{:}
            \PY{n}{key} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{)}
            \PY{n}{value} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{l+m+mi}{24}\PY{p}{)}
            \PY{k}{if} \PY{o+ow}{not} \PY{n}{key} \PY{o+ow}{or} \PY{o+ow}{not} \PY{n}{value}\PY{p}{:}
                \PY{k}{break}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Successfully loaded cache from file }\PY{l+s+si}{\PYZob{}}\PY{n}{path}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Cache}\PY{o}{.}\PY{n}{load} \PY{o}{=} \PY{n}{load}
\PY{k}{del} \PY{n}{load}
\end{Verbatim}
\end{tcolorbox}









    
\hypertarget{geschwindigkeit-tests-der-transpositionstabelle}{%
\section{nmm-rote-performance-testing: Geschwindigkeit Test der
Transpositionstabelle}\label{geschwindigkeit-tests-der-transpositionstabelle}}

    Die Klasse \texttt{Cache} aus dem Notebook \texttt{nmm-cache}
implementiert eine Transpositionstabelle die persistiert werden kann. Um
zu ermitteln wie diese implementiert werden soll, wurde zwischen zwei
MÃ¶glichkeiten abgewogen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Zum einen steht die Verwendung einer externen Key-Value-Datenbank zur
  Auswahl. Diese wird in einem weiteren Container auf dem selben
  Computer ausgefÃ¼hrt, dadurch werden die Netzwerklatenzen minimiert.
\item
  Die zweite MÃ¶glichkeit ist das Speichern im Arbeitsspeicher in einem
  Python-Dictionary. Dieses kann anschlieÃend exportiert und auf einen
  persistenten DatentrÃ¤ger geschrieben werden.
\end{enumerate}

Um zu ermitteln welche Methode verwendet werden sollte, wird im
Nachfolgenden die Geschwindigkeit der jeweiligen Methode getestet und
bewertet.

    \hypertarget{vorbereitungen}{%
\subsection{Vorbereitungen}\label{vorbereitungen}}

Bevor die MÃ¶glichkeiten getestet werden kÃ¶nnen, mÃ¼ssen folgende Pakete
geladen werden:

\begin{itemize}
    \tightlist
    \item \texttt{redis} implementiert die Kommunikation mit der Redis-Datenbank;
    \item \texttt{struct} Ã¼bersetzt \texttt{float} Werte in \texttt{bytes};
    \item \texttt{random} ermittelt Zufallswerte zum testen;
    \item \texttt{tqdm} zeigt den Fortschritt an.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{redis}
\PY{k+kn}{import} \PY{n+nn}{struct}
\PY{k+kn}{import} \PY{n+nn}{random}
\PY{k+kn}{from} \PY{n+nn}{tqdm}\PY{n+nn}{.}\PY{n+nn}{notebook} \PY{k+kn}{import} \PY{n}{tqdm}
\end{Verbatim}
\end{tcolorbox}

    Des Weiteren wird die Klasse \texttt{CacheTest} angelegt, welche als
Interface fÃ¼r die jeweilige Implementierung dient. Zwei Funktionen
werden vorgegeben:

\begin{itemize}
\tightlist
\item
  \texttt{write} schreibt die Werte \texttt{value}, \texttt{alpha} und
  \texttt{beta} an dem SchlÃ¼ssel \texttt{state} und \texttt{player} in
  den Cache;
\item
  \texttt{read} lieÃt die mit \texttt{write} gespeicherten Werte aus
  oder gibt \texttt{None} zurÃ¼ck, falls der Cache diese nicht
  beinhaltet.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{CacheTest}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{write}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{value}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{alpha}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{beta}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{k+kc}{None}\PY{p}{:}
        \PY{k}{pass}
    
    \PY{k}{def} \PY{n+nf}{read}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{p}{(}\PY{n+nb}{float}\PY{p}{,} \PY{n+nb}{float}\PY{p}{,} \PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
        \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}Value, Alpha, Beta\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{k}{pass}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{python-dictionary}{%
\subsection{Python-Dictionary}\label{python-dictionary}}

Der native Python Cache besteht aus einem einfachen Python-Dictionary in
welches die Key-Value-Paare gespeichert werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{PythonCache}\PY{p}{(}\PY{n}{CacheTest}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
        \PY{k}{pass}
    
    \PY{k}{def} \PY{n+nf}{write}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{value}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{alpha}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{beta}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{key} \PY{o}{=} \PY{n}{state}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{player}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{value} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{alpha}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{beta}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}
    
    \PY{k}{def} \PY{n+nf}{read}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{p}{(}\PY{n+nb}{float}\PY{p}{,}\PY{n+nb}{float}\PY{p}{,}\PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
        \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}Value, Alpha, Beta\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{n}{key} \PY{o}{=} \PY{n}{state}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{player}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{value} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{p}{(}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{8}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{l+m+mi}{8}\PY{p}{:}\PY{l+m+mi}{16}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{l+m+mi}{16}\PY{p}{:}\PY{l+m+mi}{24}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
        \PY{p}{)} \PY{k}{if} \PY{n}{value} \PY{k}{else} \PY{k+kc}{None}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{redis}{%
\subsection{Redis}\label{redis}}

Der Redis-Cache implementiert eine Transpositionstabelle auf basierend
auf der Key-Value-Datenbank \emph{Redis}. Die Ãbersetzung der Werte zu
Byte-Arrays erfolgt Ã¤quivalent zu dem Python-Cache. Die Werte werden
danach mit Hilfe des \texttt{redis} Pakets in der lokalen
Redis-Datenbank gespeichert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{RedisCache}\PY{p}{(}\PY{n}{CacheTest}\PY{p}{)}\PY{p}{:}
    \PY{n}{r} \PY{o}{=} \PY{n}{redis}\PY{o}{.}\PY{n}{Redis}\PY{p}{(}\PY{n}{host}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{redis}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{def} \PY{n+nf}{write}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{value}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{alpha}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{beta}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{key} \PY{o}{=} \PY{n}{state}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{player}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{value} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{value}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{alpha}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{beta}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{r}\PY{o}{.}\PY{n}{set}\PY{p}{(}\PY{n}{key}\PY{p}{,}\PY{n}{value}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{read}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{)}\PY{p}{:}
        \PY{n}{key} \PY{o}{=} \PY{n}{state}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{player}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{value} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{r}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{p}{(}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{8}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{l+m+mi}{8}\PY{p}{:}\PY{l+m+mi}{16}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{l+m+mi}{16}\PY{p}{:}\PY{l+m+mi}{24}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
        \PY{p}{)} \PY{k}{if} \PY{n}{value} \PY{k}{else} \PY{k+kc}{None}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{test}{%
\subsection{Test}\label{test}}

Als Vorbereitung des Tests werden zunÃ¤chst Instanzen der einzelnen
\texttt{CacheTest} Implementierungen erstellt. AuÃerdem werden
Einstellungen fÃ¼r die Tests vorgenommen:

\begin{itemize}
\tightlist
\item
  \texttt{count} ist die Anzahl der Elemente, die in die Caches
  geschrieben werden sollen;
\item
  \texttt{start} bis \texttt{end} ist das Intervall in dem ZustÃ¤nde
  generiert werden. Ein Zustand ist in diesem Test jedeglich eine Zahl.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{pc} \PY{o}{=} \PY{n}{PythonCache}\PY{p}{(}\PY{p}{)}
\PY{n}{rc} \PY{o}{=} \PY{n}{RedisCache}\PY{p}{(}\PY{p}{)}

\PY{n}{count} \PY{o}{=}     \PY{l+m+mi}{1\PYZus{}000\PYZus{}000}
\PY{n}{start} \PY{o}{=} \PY{l+m+mi}{1\PYZus{}000\PYZus{}000\PYZus{}000}
\PY{n}{end}   \PY{o}{=} \PY{n}{start}\PY{o}{+}\PY{n}{count}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{test-der-schreibgeschwindigkeit}{%
\subsubsection{Test der
Schreibgeschwindigkeit}\label{test-der-schreibgeschwindigkeit}}

Durch die Einstellung \texttt{count} gesteuert werden zufÃ¤llige Werte in
den Caches gespeichert. In diesem Fall sind es eine Millionen EintrÃ¤ge.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}\PYZpc{}time}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Python Cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{for} \PY{n}{state} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{player} \PY{o+ow}{in} \PY{p}{[}\PY{k+kc}{True}\PY{p}{,} \PY{k+kc}{False}\PY{p}{]}\PY{p}{:}
        \PY{k}{for} \PY{n}{limit} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{:}
            \PY{n}{pc}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{,} \PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}\PYZpc{}time}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Redis Cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{for} \PY{n}{state} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{player} \PY{o+ow}{in} \PY{p}{[}\PY{k+kc}{True}\PY{p}{,} \PY{k+kc}{False}\PY{p}{]}\PY{p}{:}
        \PY{k}{for} \PY{n}{limit} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{:}
            \PY{n}{rc}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{,} \PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Im Vergleich zu dem \texttt{PythonCache} ist der \texttt{RedisCache} bei
dem Schreibvorgang der EintrÃ¤ge etwa um den Faktor \(90\) langsamer.

    \hypertarget{testen-der-lesegeschwindigkeit}{%
\subsubsection{Testen der
Lesegeschwindigkeit}\label{testen-der-lesegeschwindigkeit}}

Bei dem Test der Lesegeschwindigkeit wird gemessen, wie schnell die
Werte fÃ¼r zufÃ¤llig ermittelte ZustÃ¤nde zurÃ¼ck gegeben werden kÃ¶nnen.
Dabei wird auf die oben generierten EintrÃ¤ge zurÃ¼ck gegriffen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}\PYZpc{}time}
\PY{n}{valid} \PY{o}{=} \PY{l+m+mi}{0}
\PY{k}{for} \PY{n}{count} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n}{count}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{n}{state} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{limit} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
    \PY{n}{player} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{choice}\PY{p}{(}\PY{p}{[}\PY{k+kc}{True}\PY{p}{,} \PY{k+kc}{False}\PY{p}{]}\PY{p}{)}
    \PY{n}{result} \PY{o}{=} \PY{n}{pc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
    \PY{k}{if} \PY{n}{result} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{valid} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{valid}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}\PYZpc{}time}
\PY{n}{valid} \PY{o}{=} \PY{l+m+mi}{0}
\PY{k}{for} \PY{n}{count} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n}{count}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{n}{state} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{limit} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
    \PY{n}{player} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{choice}\PY{p}{(}\PY{p}{[}\PY{k+kc}{True}\PY{p}{,} \PY{k+kc}{False}\PY{p}{]}\PY{p}{)}
    \PY{n}{result} \PY{o}{=} \PY{n}{rc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
    \PY{k}{if} \PY{n}{result} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{valid} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{valid}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    WÃ¤hrend die Lesegeschwindigkeit beim \texttt{RedisCache} deutlich hÃ¶her
als die Schreibgeschwindigkeit ist, ist diese dennoch um etwa den Faktor
\(4\) langsamer als die des \texttt{PythonCache}s.

    \hypertarget{resumee}{%
\subsection{Resumee der Cache Implementierungen}\label{resumee}}

Sowohl die Lese- als auch die Schreibgeschwindigkeit ist beim
\texttt{PythonCache} deutlich hÃ¶her als beim \texttt{RedisCache}. Wobei
die Geschwindigkeitsdifferenz beim Schreiben stÃ¤rker ausfÃ¤llt als beim
Lesen. Dies ist hÃ¶chst wahrscheinlich auf den Overhead der Verbindung
zwischen Datenbank und dem Python-Programm zurÃ¼ckzufÃ¼hren.

Aus diesem Grund wurde sich dafÃ¼r entschieden, den Cache als
Python-Dictionary zu implementieren und anschlieÃend als Datei auf dem
DatentrÃ¤ger zu persistieren. Hierbei wird in Kauf genommen, dass die
wachsende GrÃ¶Ãe des Caches zu einer starken Auslastung des
Arbeitsspeicher fÃ¼hren kann.









\hypertarget{rote-learning-training}{%
\section{nmm-rote-training: Rote-Learning Training}\label{rote-learning-training}}


    Der Rote-Learning Algorithmus muss im wahrsten Sinne des Wortes
auswendig lernen und das Spiel trainieren. Dazu werden mÃ¶glichst viele
Spiele hintereinander gespielt und die Transpositionstabelle mit immer
mehr und genaueren Daten gefÃ¼llt.

ZunÃ¤chst werden beide implementierte Algorithmen geladen:
\texttt{AlphaBetaPruning} und \texttt{Minimax}. Die \texttt{Match}
Implementierung aus dem \texttt{Tournament} Notebook kann ebenfalls
wieder verwendet werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}alpha\PYZhy{}beta\PYZhy{}pruning.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}minimax.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}tournament.ipynb
\end{Verbatim}
\end{tcolorbox}

    Um eine Ã¼bersichtlichere Entwicklung zu ermÃ¶glichen, werden
Typdefinitionen geladen, welche spÃ¤ter im Code verwendet werden. Das
Paket \texttt{tqdm} ermÃ¶glicht eine einfache Fortschrittsanzeige.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{typing} \PY{k+kn}{import} \PY{n}{Optional}\PY{p}{,} \PY{n}{Union}\PY{p}{,} \PY{n}{List}\PY{p}{,} \PY{n}{Callable}
\PY{k+kn}{from} \PY{n+nn}{tqdm}\PY{n+nn}{.}\PY{n+nn}{notebook} \PY{k+kn}{import} \PY{n}{tqdm}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{training}{%
\subsection{Training}\label{training}}

Innerhalb eines Trainings spielt eine kÃ¼nstliche Intelligenz viele Male
gegen sich selbst und erweitert so ihre Transpositionstabelle. Bei jedem
Spiel gegen sich selbst ist eine hÃ¶here Rekursionstiefe erreichbar, da
der Cache bereits Werte von vorherigen Runden beinhaltet. Da die
Implementierung der Transpositionstablle die gespeicherten Werte auf den
weiÃen Spieler normiert, ist es sogar effizient mÃ¶glich, dass sich beide
kÃ¼nstliche Intelligenzen (weiÃ und schwarz) einen Cache teilen.

Innerhalb eines Trainings werden nur die ersten 18 Runden eines jeden
Spieles gespielt, da alle diese Runden gezwungenermaÃen in der ersten
Spielphase \texttt{Placing} sind. Jeder Spieler muss alle seine 9 Steine
zu Beginn der Runde setzen. Dadurch werden innerhalb der 18 Runden alle
Steine von beiden Spielern gesetzt. Es wird nur die Spielphase
\texttt{Placing} trainiert, da diese Phase im Vergleich zur zweiten
Phase \texttt{Moving} um einiges komplexer ist. Bei jedem Zug kann jeder
neue Stein eines Spielers auf jedes freie Feld bewegt werden, in der
\texttt{Moving} Phase sind hingengen nur benachbarte leere Felder
mÃ¶glich. Dadurch ist der Suchraum fÃ¼r die Algorithmen zu Beginn des
Spieles besonders groÃ und die kÃ¼nstliche Intelligenz kann
dementsprechend weniger ZÃ¼ge in die Zukunft schauen. Durch das
Auswendiglernen dieser Phase gewinnen die Algorithmen einen grÃ¶Ãeren
Vorteil.

Auch die letzte Phase \texttt{Flying} ist sehr komplex und wÃ¼rde vom
Auswendiglernen profitieren, allerdings wird hierzu eine
Endspieldatenbank implementiert. Diese Datenbank deckt die letzte Phase
besser ab als das Auswendiglernen.

    Die Klasse \texttt{Training} implementiert solch ein Training und
benÃ¶tigt mehrere Parameter:

Verpflichtend: 
\begin{itemize}
    \tightlist
    \item \texttt{cache} ist die Instanz der
    Transpositionstabelle, die innerhalb des Trainings verwendet und damit
    trainiert werden soll;
    \item \texttt{artificial\_intelligence} ist eine
    Funktion die eine \texttt{ArtificialIntelligence} Instanz produziert,
    die jeweils fÃ¼r den weiÃen und den schwarzen Spieler aufgerufen wird;
\end{itemize}

Optional:
\begin{itemize}
    \tightlist
    \item \texttt{trainings} ist die Anzahl der Runden in denen
    trainiert werden sollen;
    \item \texttt{seed\_offset} ist die Zahl, die auf
    den Seed addiert werden soll um verschiedene TrainingslÃ¤ufe erstellen zu
    kÃ¶nnen;
    \item \texttt{path\_prefix} ist der Prefix der vor den Dateinamen
    geschrieben wird, um den Cache Zwischenstand zu speichern;
    \item \texttt{save\_interval} ist das Intervall in dem der Cache auf der
    Festplatte zwischen gespeichert werden soll.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Training}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}
        \PY{n+nb+bp}{self}\PY{p}{,}
        \PY{n}{cache}\PY{p}{:} \PY{n}{Cache}\PY{p}{,}
        \PY{n}{artificial\PYZus{}intelligence}\PY{p}{:} \PY{n}{Callable}\PY{p}{[}\PY{p}{[}\PY{n}{Cache}\PY{p}{]}\PY{p}{,} \PY{n}{ArtificialIntelligence}\PY{p}{]}\PY{p}{,}
        \PY{n}{trainings}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{100}\PY{p}{,}
        \PY{n}{seed\PYZus{}offset}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{0}\PY{p}{,}
        \PY{n}{path\PYZus{}prefix}\PY{p}{:} \PY{n+nb}{str} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{training\PYZhy{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
        \PY{n}{save\PYZus{}interval}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{10}
    \PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{n}{cache}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{artificial\PYZus{}intelligence} \PY{o}{=} \PY{n}{artificial\PYZus{}intelligence}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{trainings} \PY{o}{=} \PY{n}{trainings}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset} \PY{o}{=} \PY{n}{seed\PYZus{}offset}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{path\PYZus{}prefix} \PY{o}{=} \PY{n}{path\PYZus{}prefix}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{save\PYZus{}interval} \PY{o}{=} \PY{n}{save\PYZus{}interval}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r Entwicklungszwecke wird eine Stringdarstellung fÃ¼r die Klasse
\texttt{Training} implementiert. Hierzu wird durch die Funktion
\texttt{\_\_repr\_\_} ein String zurÃ¼ckgegeben, der alle Parameter der
Klasse beinhaltet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Training}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Training(cache=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
           \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{artificial\PYZus{}intelligence=}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{type}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{artificial\PYZus{}intelligence}\PY{p}{)}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
           \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{trainings=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{trainings}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, seed\PYZus{}offset=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
           \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{path\PYZus{}prefix=}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{path\PYZus{}prefix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{, save\PYZus{}interval=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{save\PYZus{}interval}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{Training}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{train} trainiert die gespeicherte
Transpositionstabelle indem fÃ¼r die Anzahl der zu spielenden Runden
(\texttt{trainings}) ein Spiel (\texttt{Match}) erstellt wird. Dieses
Spiel wird von zwei \texttt{ArtificialIntelligence} Instanzen gespielt,
welche durch die gespeicherte Funktion \texttt{artificial\_intelligence}
erstellt werden. Pro Spiel werden maximal 18 Runden, also nur die
\texttt{Placing} Phase gespielt. Nach \texttt{save\_interval} Spielen
sowie am Ende wird die Transpositionstabelle mit der Rundennummer auf
der Festplatte zwischengespeichert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{train}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Training}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{trainings}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n}{name} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{path\PYZus{}prefix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+si}{\PYZob{}}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{l+s+si}{:}\PY{l+s+s2}{0\PYZgt{}3}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}
        \PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset} \PY{o}{+} \PY{n}{i}\PY{p}{)}
        \PY{n}{match} \PY{o}{=} \PY{n}{Match}\PY{p}{(}
            \PY{n}{white}     \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{artificial\PYZus{}intelligence}\PY{p}{(}\PY{n}{cache} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{p}{,}
            \PY{n}{black}     \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{artificial\PYZus{}intelligence}\PY{p}{(}\PY{n}{cache} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{p}{,}
            \PY{n}{max\PYZus{}turns} \PY{o}{=} \PY{l+m+mi}{18}\PY{p}{,}
            \PY{n}{name}      \PY{o}{=} \PY{n}{name}
        \PY{p}{)}
        
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Training \PYZsh{}}\PY{l+s+si}{\PYZob{}}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{match}\PY{o}{.}\PY{n}{play}\PY{p}{(}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ \PYZgt{} }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        
        \PY{k}{if} \PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{save\PYZus{}interval} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZgt{} Saving to }\PY{l+s+s2}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{.cache}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{...}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{save}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{.cache}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{p}{)}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{save}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{path\PYZus{}prefix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{final.cache}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n}{Training}\PY{o}{.}\PY{n}{train} \PY{o}{=} \PY{n}{train}
\PY{k}{del} \PY{n}{train}
\end{Verbatim}
\end{tcolorbox}











    \hypertarget{anwendung}{%
\section{Anwendung}\label{anwendung}}

Um den bei Rote-Learning beschriebenen Lerneffekt zu erzielen und die
ZustÃ¤nde zu Speichern, wurde eine Transpositionstabelle als Klasse
\texttt{Cache} in dem Notebook \texttt{nmm-cache} implementiert. Diese
Klasse verfÃ¼gt Ã¼ber fÃ¼nf Methoden zur Verwaltung des Caches:

\begin{itemize}
\tightlist
\item
  \texttt{write} speichert einen neuen Zustand und die errechneten Werte
  ab;
\item
  \texttt{read} liest die gespeicherten Werte eines Zustandes aus dem
  Cache aus;
\item
  \texttt{save} legt den Inhalt des Caches in einer Datei auf einem
  DatentrÃ¤ger ab;
\item
  \texttt{load} lÃ¤dt die Daten des Caches aus einer Datei auf dem
  DatentrÃ¤ger;
\item
  \texttt{clean} lÃ¶scht EintrÃ¤ge aus dem Cache, falls die Anzahl der
  EintrÃ¤ge \texttt{max\_size} Ã¼berschritten wurde.
\end{itemize}

Um die einzelnen Werte fÃ¼r die ZustÃ¤nde im Cache abzulegen, werden
sowohl die ZustÃ¤nde als auch die Werte in ein Byte-Array konvertiert.
Insgesamt ist ein Eintrag des Caches somit 32 Bytes groÃ. Um zu
verhindern, dass der Cache zu groÃ wird um ihn im Arbeitsspeicher oder
auf dem DatentrÃ¤ger speichern zu kÃ¶nnen, wurde der Parameter
\texttt{max\_size} eingefÃ¼hrt. Dieser begrenzt den Cache auf eine
maximale Anzahl an EintrÃ¤gen. Um die Performance zu steigern, wird dies
jedoch nicht beim jedem Aufruf der \texttt{write} Methode geprÃ¼ft
sondern nur beim Aufruf der Methode \texttt{clean}. Dies kann dazu
fÃ¼hren, dass zwischen den Aufrufen der \texttt{clean} Methode mehr
EintrÃ¤ge im Cache vorhanden sind, als durch \texttt{max\_size} erlaubt.
Wird der Cache auf dem DatentrÃ¤ger abgelegt, entspricht die DateigrÃ¶Ãe
genau der Anzahl an Elementen multipliziert mit 32 Bytes. Die GrÃ¶Ãe das
Caches im Arbeitsspeicher ist jedoch um einen Faktoren von ca. \(6\)
grÃ¶Ãer, da Python weiteren Arbeitsspeicher, beispielsweise fÃ¼r den
Datentyp, reserviert.

Der folgende Befehl erstellt einen Cache mit einer GrÃ¶Ãe von 50
Millionen ZustÃ¤nden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{cache} \PY{o}{=} \PY{n}{Cache}\PY{p}{(}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{50\PYZus{}000\PYZus{}000}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{anbindung-an-ux3b1-ux3b2-pruning}{%
\subsection{Anbindung an
$\alpha$-$\beta$-Pruning}\label{anbindung-an-ux3b1-ux3b2-pruning}}

Da im $\alpha$-$\beta$-Pruning Algorithmus bereits die Verwendung eines
In-Memory-Caches vorgesehen ist, mussten nur kleine Anpassungen
vorgenommen werden. Es musste sichergestellt werden, dass sowohl zum
Schreiben als auch zum Lesen der Werte aus dem Cache die richtigen
Methoden aufgerufen werden, sowie dass ein Cache entweder als Parameter
Ã¼bergeben werden kann oder ein neuer instanziiert wird. Nach jeder
Berechnung der nÃ¤chsten besten ZÃ¼ge mit Hilfe der \texttt{bestMoves}
Methode, wurde der Aufruf der \texttt{clean} Methode hinterlegt, um die
GrÃ¶Ãe des Caches anzupassen.

    \hypertarget{traingingsprozess}{%
\subsection{Traingingsprozess}\label{traingingsprozess}}

Um die Transpositionstabelle zu trainieren und somit das Rote-Learning
umzusetzen, wird die Klasse \texttt{Training} aus dem Notebook
\texttt{nmm-rote-training} verwendet. Dazu muss zuerst eine Methode
erstellt werden, welche den Algorithmus fÃ¼r die kÃ¼nstliche Intelligenz
konfiguriert und generiert. Diese Methode wird
\texttt{artificial\_intelligence\_generator} genannt und generiert eine
AlphaBetaPruning Instanz, welche den Ã¼bergebenen Cache und eine
benutzerdefinierte Heuristiken verwendet. Die verwendeten Heuristiken
wurden bereits im Rahmen der Studienarbeit ermittelt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{artificial\PYZus{}intelligence\PYZus{}generator}\PY{p}{(}\PY{n}{cache}\PY{p}{:} \PY{n}{Cache}\PY{p}{)}\PY{p}{:}
    \PY{n}{customWeights} \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{stash} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{mills} \PY{o}{=} \PY{l+m+mi}{2}\PY{p}{,} \PY{n}{possible\PYZus{}mills} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{)}
    \PY{k}{return} \PY{n}{AlphaBetaPruning}\PY{p}{(}\PY{n}{cache} \PY{o}{=} \PY{n}{cache}\PY{p}{,} \PY{n}{weights} \PY{o}{=} \PY{n}{customWeights}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r den Cache wurde sich fÃ¼r eine maximale GrÃ¶Ãe von 50.000.000
EintrÃ¤gen entschieden. Dies resultiert in eine maximal GrÃ¶Ãe des Caches
von ca. 1,6Gb auf dem DatentrÃ¤ger. Des Weiteren werden die Standardwerte
der Training-Klasse verwendet. Das heiÃt, dass ingesamt 100 Spiele
gespielt werden und der Seed fÃ¼r den Zufallsgenerator nicht angepasst
wird. Alle 10 Spiele wird der Cache auf dem DatentrÃ¤ger gespeichert und
wird der Prefix \texttt{training-} fÃ¼r den Dateinamen verwendet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{training} \PY{o}{=} \PY{n}{Training}\PY{p}{(}
    \PY{n}{cache} \PY{o}{=} \PY{n}{cache}\PY{p}{,} 
    \PY{n}{artificial\PYZus{}intelligence} \PY{o}{=} \PY{n}{artificial\PYZus{}intelligence\PYZus{}generator}\PY{p}{,}
    \PY{n}{path\PYZus{}prefix} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{training\PYZhy{}small\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Der Trainingsprozess wird durch den Aufruf der Funktion \texttt{train}
gestartet und dauert mit der oben genannten Konfiguration in etwa 4,5
Stunden. Dabei werden bis zu 10 Gb Arbeitsspeicher benÃ¶tigt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{mem\PYZus{}usage} \PY{o}{=} \PY{n}{memory\PYZus{}usage}\PY{p}{(}\PY{n}{training}\PY{o}{.}\PY{n}{train}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Maximum memory usage: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s1}{ MB.}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}} \PY{n+nb}{max}\PY{p}{(}\PY{n}{mem\PYZus{}usage}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{trainings-limitierungen}{%
\subsubsection{Trainings Limitierungen}\label{trainings-limitierungen}}

Auf den ersten Blick scheint es so, dass man den Cache unendlich weiter
trainieren kann. Dies jedoch mit der aktuellen Implementierung nicht
zielfÃ¼hrend. Ab einem gewissen Trainingszeitpunkt ist das
Rekursionslimit der EintrÃ¤ge im Cache so hoch, dass dieses durch
weiteres Training nicht erneut erreicht werden kÃ¶nnen. Dies ist lÃ¤sst
sich gut an nachfolgendem Beispiel erkennen:

Durch die geringe GrÃ¶Ãe des Caches sowie dem kleinen Wert fÃ¼r
\texttt{max\_states} kommt man sehr schnell an den Punkt, an dem das
Cache-Limit auf 3 erhÃ¶ht wird. Dadurch werden fast alle EintrÃ¤ge aus dem
Cache gelÃ¶scht und es verbleiben nur noch \texttt{48} im Cache. Dies
passiert mehrere Male und ist ein Zeichen dafÃ¼r, dass der Cache nicht
mehr weiter trainiert werden kann, da dieser zu klein ist um genÃ¼gend
EintrÃ¤ge zu halten, damit mehr EintrÃ¤ge mit \texttt{limit\ =\ 3}
berechnet werden kÃ¶nnen bevor der \texttt{max\_states} Wert
Ã¼berschritten wird.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{t} \PY{o}{=} \PY{n}{Training}\PY{p}{(}
    \PY{n}{cache}                   \PY{o}{=} \PY{n}{Cache}\PY{p}{(}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{1\PYZus{}000}\PY{p}{)}\PY{p}{,}
    \PY{n}{artificial\PYZus{}intelligence} \PY{o}{=} \PY{k}{lambda} \PY{n}{cache}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}
        \PY{n}{cache}      \PY{o}{=} \PY{n}{cache}\PY{p}{,}
        \PY{n}{max\PYZus{}states} \PY{o}{=} \PY{l+m+mi}{1\PYZus{}000}
    \PY{p}{)}\PY{p}{,}
    \PY{n}{path\PYZus{}prefix}             \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{max\PYZhy{}learning\PYZhy{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
    \PY{n}{save\PYZus{}interval}           \PY{o}{=} \PY{l+m+mi}{1}
\PY{p}{)}
\PY{n}{t}\PY{o}{.}\PY{n}{train}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{auswertung}{%
\subsection{Auswertung}\label{auswertung}}

Bei der Auswertung wird auf die Klasse \texttt{Tournament} aus dem
Notebook \texttt{nmm-tournament} zurÃ¼ck gegriffen. Diese Klasse besitzt
die Methode \texttt{play}, welche es ermÃ¶glicht verschiedene Algorithmen
gegeneinander Antreten zu lassen und die Ergebnisse zu speichern.

Um zu ermitteln ob die Rote-Learning-Methode einen Vorteil gegenÃ¼ber
einem normalen Cache bietet, tritt eine Ã¼ber 100 Spiele trainierte
Trainspositionstabelle gegen eine untrainierte Transpositionstabelle an.
Dies wird zehn mal mit verschiedenen Seeds wiederholt. Das verÃ¤ndern der
Seeds sorgt dabei fÃ¼r einen verÃ¤nderten Spielverlauf. Somit sollte
ermittelt werden kÃ¶nnen, ob durch das Training eine Verbesserung der
kÃ¼nstlichen Intelligenz eintritt und wenn ja, wie deutlich diese
Verbesserung ausfÃ¤llt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{:}
    \PY{n}{Tournament}\PY{p}{(}
        \PY{p}{[}
            \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}
                \PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{New Cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
                \PY{n}{weights} \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{stash} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{mills} \PY{o}{=} \PY{l+m+mi}{2}\PY{p}{,} \PY{n}{possible\PYZus{}mills} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}
                \PY{n}{cache} \PY{o}{=} \PY{n}{Cache}\PY{p}{(}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{50\PYZus{}000\PYZus{}000}\PY{p}{)}
            \PY{p}{)}\PY{p}{,}
            \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}
                \PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Trained Cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
                \PY{n}{weights} \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{stash} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{mills} \PY{o}{=} \PY{l+m+mi}{2}\PY{p}{,} \PY{n}{possible\PYZus{}mills} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}
                \PY{n}{cache} \PY{o}{=} \PY{n}{Cache}\PY{p}{(}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{50\PYZus{}000\PYZus{}000}\PY{p}{,} \PY{n}{path} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{training\PYZhy{}small\PYZhy{}final.cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
            \PY{p}{)}
        \PY{p}{]}\PY{p}{,}
        \PY{n}{instances\PYZus{}per\PYZus{}round} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{,}
        \PY{n}{seed\PYZus{}offset}         \PY{o}{=} \PY{n}{i}\PY{p}{,}
        \PY{n}{name}                \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{small\PYZhy{}full\PYZhy{}}\PY{l+s+si}{\PYZob{}}\PY{n}{i}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZhy{}seed}\PY{l+s+s2}{\PYZdq{}}
    \PY{p}{)}\PY{o}{.}\PY{n}{play}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Auswertung hat ergeben, dass von insgesamt von 20 gespielten Spielen
10 gewonnen wurden. Bei 5 lief es auf ein Unentschieden herraus und 5
wurden verloren. Damit lÃ¤sst sich mit ziemlicher Sicherheit sagen, dass
das Training der ersten Spielphase durch Rote-Learning einen Vorteil im
gesamten Spielverlauf bietet.

    \hypertarget{fazit}{%
\section{Fazit}\label{fazit}}

Das Ziel dieser Arbeit war die Implementierung des in dem Paper
\texttt{Some\ Studies\ in\ Machine\ Learning\ Using\ the\ Game\ of\ Checkers}
von \texttt{A.L.Samuel} beschriebene Prinzip von Rote-Learning zu
erarbeiten. Das Ziel wurde erfolgreich durch eine Python-Implementierung
erreicht und durch eine Verbesserung der Leistung einer kÃ¼nstlichen
Intelligenz bestÃ¤tigt. Im Laufe der Arbeit wurde sich neben der
Implementierung in Python auch mit den dem $\alpha$-$\beta$-Pruning Algorithmus sowie
verschiedenen Methoden zur Persistierung eines Caches beschÃ¤ftigt.

WÃ¤hrend in dem Paper jedoch zwei Methoden beschrieben werden, um
EintrÃ¤ge aus einem zu groÃen Cache zu lÃ¶schen, wird sich in dieser
Arbeit nur auf eine Methode konzentriert. Im Paper wird zum einen die
Aufruf-Frequenz oder zum anderen das Rekursionslimit des Eintrags. Diese
Arbeit behandelt nur das LÃ¶schen von EintrÃ¤gen basierend auf dem
Rekursionslimit.

Dennoch lÃ¤sst sich sagen, dass diese Arbeit ein Erfolg war, da eine
deutliche Verbesserung des $\alpha$-$\beta$-Pruning mit einem trainierten Cache
erreicht werden konnte, sodass nach 100 Trainingsrunden nur noch 25\%
der Spiele gegen eine nicht trainierte kÃ¼nstliche Intelligenz verloren
wurden.


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
