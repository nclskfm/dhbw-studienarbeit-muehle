\documentclass[11pt]{article}

    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{Hausarbeit: Rote-Learning anhand einer künstlichen Intelligenz für das Brettspiel Mühle}
    \author{Robert Franzke (7222940) und Joost Ole Seddig (8713483)}
    \date{}
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    
    \hypertarget{rote-learning}{%
\section{Einleitung}\label{rote-learning}}


    Der $\alpha$-$\beta$-Pruning Algorithmus versucht durch die Auswertung der zukünftig
möglichen Züge den Besten auszuwählen. Da der Suchraum jedoch zu groß
ist um jedes mögliche Spiel zu betrachten, muss an einem bestimmten
Punkt das Vorausschauen beendet werden und eine Schätzung statt dem
tatsächlichen Wert verwendet werden. Diese Aufgabe übernimmt die in dem
Notebook \texttt{nmm-heuristic} implementierte Heuristik. Dies bedeutet
dass eine künstliche Intelligenz, die den $\alpha$-$\beta$-Pruning Algorithmus
implementiert, je besser ist, desto mehr Schritte in die die Zukunft
geschaut werden kann. Die Laufzeit $\alpha$-$\beta$-Pruning Algorithmus nimmt jedoch
mit zunehmender Tiefe, aufgrund der sehr schnell ansteigenden Anzahl der
Zustände, deutlich zu. Somit ist eine Neuberechnung der Schäzung bei
jedem Zug nicht praktikabel.

An diesem Punkt setzt das Rote-Learning an: Indem der $\alpha$-$\beta$-Pruning
Algorithmus um eine elementare Form des Lernens erweitert wird, wird
dessen Effektivität stark gesteigert. Grundlegend werden bei der
Verwendung von Rote-Learning alle Zustände, die jemals besucht wurden,
zusammen mit den dazugehörigen errechneten Schätzungen abgespeichert.
Anstatt die Wertschätzung dieser Zustände bei jedem Zug neu zu
berechnen, können diese nun aus dem Speicher abgerufen werden. Dies
spart vor allem bei einer hohen Suchtiefe viel Rechenzeit ein. Diese
Einsparung der Rechenzeit kann darauf verwendet werden, weitere Zustände
zu berechnen und somit die Qualität der Schätzungen zu erhöhen. Da mit
jedem Spiel mehr Zustände und deren Schätzungen gespeichert werden,
verbessert sich das Ergebnis des Algorithmus über Zeit. Es tritt also
ein Lerneffekt ein.

    \hypertarget{implementierung}{%
\subsection{Implementierung}\label{implementierung}}

Um das oben genannte Prinzip von Rote-Learning in Python zu
implementieren, wurde auf eine bereits fertige Implementierung des
$\alpha$-$\beta$-Pruning Algorithmus für das Spiel Mühle zurück gegriffen.
Dieser wurde im Rahmen der Studienarbeit entwickelt und musste für die
Verwendung von Rote-Learning nur noch geringfügig angepasst werden. Um
zu evaluieren ob Rote-Learning einen Vorteil gegenüber einem nicht
trainierten Algorithmus herbeiführt, werden folgende Notebooks benötigt:

\begin{itemize}
\tightlist
\item
  \texttt{nmm-cache} implementiert eine schnelle, persistierbare
  Transpositionstabelle (auch Cache genannt);
\item
  \texttt{nmm-rote-training} implementierung ein Klasse für den
  Trainingsteil des Rote-Learnings;
\item
  \texttt{nmm-alpha-beta-pruning} ist eine bereits vorhandene
  Implementierung des $\alpha$-$\beta$-Pruning Algorithmus;
\item
  \texttt{nmm-tournament} ist eine ebenfalls bereits vorhandene
  Implementierung zur Evaluation, ob ein per Rote-Learning trainierter
  Algorithmus besser abschneidet als ein nicht trainierter Algorithmus.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}cache.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}rote\PYZhy{}training.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}alpha\PYZhy{}beta\PYZhy{}pruning.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}tournament.ipynb
\end{Verbatim}
\end{tcolorbox}

    Desweitern wird das Paket \texttt{memory\_profiler} eingebunden, welches
die Überwachung der Auslastung des Arbeitsspeichers ermöglicht.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{memory\PYZus{}profiler} \PY{k+kn}{import} \PY{n}{memory\PYZus{}usage}
\end{Verbatim}
\end{tcolorbox}


    


    
\hypertarget{persistente-transpositionstabelle}{%
\section{nmm-cache: Persistente
Transpositionstabelle}\label{persistente-transpositionstabelle}}

    Der Training Prozess des Rote-Learnings ist sehr zeitaufwendig, da viele
Spiele gespielt werden müssen. Damit dieser Prozess nicht vor jedem
Spiel ausgeführt werden muss, ist es sinnvoll die trainierte
Transpositionstabelle persistent auf der Festplatte abspeichern zu
können. Es gibt mehrere Möglichkeiten diese Transpositionstabelle zu
implementieren, jedoch ist die Geschwindigkeit hier einer des
ausschlaggebendsten Faktoren. Um zu ermitteln wie die Tabelle
implementiert werden soll, wurde also ein Geschwindigkeitsvergleich
erstellt. Dieser ist im Notebook \texttt{nmm-rote-performance-testing}
zu finden. Das Ergebnis dieses Vergleiches hat ergeben, dass sich ein
Python-Dictionary im Arbeitsspeicher gut eignet. Dieses kann ebenfalls
in einer binären Datei auf einem Datenträger persistiert werden.

    \hypertarget{cache}{%
\subsection{Cache}\label{cache}}

Die Klasse \texttt{Cache} implementiert eine Transpositionstabelle die
persistiert werden kann. Der Konstruktor erhält folgenden Parameter:

\begin{itemize}
    \tightlist
    \item \texttt{max\_size} gibt an, wie viele Einträge sich maximal im Cache
    befinden dürfen, bevor Einträge mit dem geringsten Rekursionslimit
    entfernt werden.
    \item \texttt{path} gibt an, aus welcher Datei der Cache
    geladen werden soll. Ist dieser nicht gesetzt wird ein neuer leerer
    Cache initiiert.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Cache}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{1\PYZus{}000\PYZus{}000}\PY{p}{,} \PY{n}{path}\PY{p}{:} \PY{n+nb}{str} \PY{o}{=} \PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{n}{max\PYZus{}size}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
        \PY{k}{if} \PY{n}{path}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{load}\PY{p}{(}\PY{n}{path}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Für Entwicklungszwecke wird eine Stringdarstellung für die Klasse
\texttt{Cache} implementiert. Hierzu wird durch die Funktion
\texttt{\_\_repr\_\_} ein String zurückgegeben, der alle Parameter der
Klasse beinhaltet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n+nb}{str}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Cache(size=}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, max\PYZus{}size=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}size}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{Cache}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    Damit die Zustände und die Werte direkt als Bytes gespeichert und wieder
ausgelesen werden können, ist das Paket \texttt{struct} nötig. Dieses
ermöglicht \texttt{float} Werte zu \texttt{bytes} zu konvertieren. Das
Paket \texttt{tqdm} ermöglicht eine simple Fortschrittsanzeige.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{struct}
\PY{k+kn}{from} \PY{n+nn}{tqdm}\PY{n+nn}{.}\PY{n+nn}{notebook} \PY{k+kn}{import} \PY{n}{tqdm}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{convert\_state\_to\_bytes} konvertiert einen Zustand
in ein Byte-Array der Länge 7. Der Zustand wird dabei immer auf den
weißen Spieler normiert. Durch die Normierung müssen die Zustände nur
noch für einen Spieler gespeichert werden, worduch für die gleiche Menge
an effektiv verwendbaren Zuständen nur noch die Hälfte des Speichers
benötigt wird. Diese Optimierung ist jedoch nur effektiv, wenn beide
Spieler die gleiche Anzahl an Steinen haben. In der ersten Phase liegt
bei dem weißen Spieler (meist) ein Stein mehr auf dem Spielbrett als bei
dem schwarzen Spieler. Deshalb bringt die Normierung zu Beginn in den
meisten Fällen nichts, im späteren Verlauf ist sie jedoch sinnvoll.

Dabei werden folgende Argumente erwartet:

\begin{itemize}
    \tightlist
    \item \texttt{state} \(\in States\);
    \item \texttt{player} \(\in Player\).
\end{itemize}

Das resultierende Byte-Array besteht aus:

\begin{itemize}
    \tightlist
    \item \texttt{bytes{[}0{]}}
    beinhaltet den Stapel, wobei die ersten 4 Bits vom weißen und die
    letzten 4 Bits vom schwarzen Spieler belegt sind;
    \item \texttt{bytes{[}1:3{]}} beinhaltet die Steine des weißen Spielers auf
    dem Spielbrett, beginnend mit dem inneren Ring und dem letzten Stein des
    Ringes;
    \item \texttt{bytes{[}4:7{]}} beinhaltet die Steine des schwarzen
    Spielers auf dem Spielbrett im gleichen Format.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{convert\PYZus{}state\PYZus{}to\PYZus{}bytes}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{:}
    \PY{n}{players} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
    \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
        \PY{n}{players} \PY{o}{=} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}
        \PY{n}{state} \PY{o}{=} \PY{p}{(}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
    \PY{n}{byte\PYZus{}data} \PY{o}{=} \PY{p}{(}\PY{p}{(}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{\PYZlt{}\PYZlt{}} \PY{l+m+mi}{4}\PY{p}{)} \PY{o}{|} \PY{n}{state}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{for} \PY{n}{player} \PY{o+ow}{in} \PY{n}{players}\PY{p}{:}
        \PY{k}{for} \PY{n}{ring} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
            \PY{n}{ring\PYZus{}byte} \PY{o}{=} \PY{l+m+mi}{0}
            \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{7}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
                \PY{n}{ring\PYZus{}byte} \PY{o}{\PYZlt{}\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{1}
                \PY{k}{if} \PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{n}{ring}\PY{p}{]}\PY{p}{[}\PY{n}{cell}\PY{p}{]} \PY{o+ow}{is} \PY{n}{player}\PY{p}{:}
                    \PY{n}{ring\PYZus{}byte} \PY{o}{|}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{n}{byte\PYZus{}data} \PY{o}{+}\PY{o}{=} \PY{n}{ring\PYZus{}byte}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{return} \PY{n}{byte\PYZus{}data}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{write} schreibt einen Zustand in die
Transpositionstabelle. Dabei wird der Zustand auf den weißen Spieler
normiert. Es werden folgende Argumente erwartet:

\begin{itemize}
    \tightlist
    \item \texttt{state} \(\in States\);
    \item \texttt{player} \(\in Player\);
    \item \texttt{limit} \(\in \mathbb{N}_0\);
    \item \texttt{value} \(\in \mathopen[-1.0,1.0\mathclose]\);
    \item \texttt{alpha} \(\in \mathopen[-1.0,1.0\mathclose]\);
    \item \texttt{beta} \(\in \mathopen[-1.0,1.0\mathclose]\).
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{write}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{str}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{value}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{alpha}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{beta}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{k+kc}{None}\PY{p}{:}
    \PY{n}{state} \PY{o}{=} \PY{n}{convert\PYZus{}state\PYZus{}to\PYZus{}bytes}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}
    \PY{n}{key} \PY{o}{=} \PY{n}{state} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
        \PY{n}{value}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{n}{value}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{beta}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{alpha}
    \PY{n}{value} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{alpha}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{beta}\PY{p}{)}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}

\PY{n}{Cache}\PY{o}{.}\PY{n}{write} \PY{o}{=} \PY{n}{write}
\PY{k}{del} \PY{n}{write}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{read} liest einen vorher gespeicherten Zustand aus
der Transpositionstabelle aus. Falls der Zustand nicht vorhanden ist
wird \texttt{None} zurückgegeben. Dabei wird die Normierung auf den
weißen Spieler rückgängig gemacht. Folgende Argumente werden erwartet:

\begin{itemize}
    \tightlist
    \item \texttt{state} \(\in States\);
    \item \texttt{player} \(\in Player\);
    \item \texttt{limit} \(\in \mathbb{N}_0\).
\end{itemize}

Zurückgegeben wird ein Tripel bestehend aus:

\begin{enumerate}
    \tightlist
    \item \texttt{value} \(\in \mathopen[-1.0,1.0\mathclose]\);
    \item \texttt{alpha} \(\in \mathopen[-1.0,1.0\mathclose]\);
    \item \texttt{beta} \(\in \mathopen[-1.0,1.0\mathclose]\).
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{read}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{str}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{p}{(}\PY{n+nb}{float}\PY{p}{,}\PY{n+nb}{float}\PY{p}{,}\PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
    \PY{n}{state} \PY{o}{=} \PY{n}{convert\PYZus{}state\PYZus{}to\PYZus{}bytes}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}
    \PY{n}{key} \PY{o}{=} \PY{n}{state} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{n}{result} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{result}\PY{p}{:}
        \PY{k}{return} \PY{k+kc}{None}
    \PY{n}{value} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{8}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{n}{alpha} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{[}\PY{l+m+mi}{8}\PY{p}{:}\PY{l+m+mi}{16}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{n}{beta} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{result}\PY{p}{[}\PY{l+m+mi}{16}\PY{p}{:}\PY{l+m+mi}{24}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
    \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
        \PY{n}{value}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta} \PY{o}{=} \PY{o}{\PYZhy{}}\PY{n}{value}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{beta}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{alpha}
    \PY{k}{return} \PY{p}{(}\PY{n}{value}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{)}

\PY{n}{Cache}\PY{o}{.}\PY{n}{read} \PY{o}{=} \PY{n}{read}
\PY{k}{del} \PY{n}{read}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{clean} prüft ob der Cache seine maximale Größe
überschritten hat. Ist dies der Fall werden Einträge beginnend mit dem
Rekursionslimit \(limit = 0\) aus dem Cache entfernt. Solange die
Transpositionstabelle weiterhin ihre maximale Größe überschreitet, wird
das minimale Rekursionslimit erhöht und die unterschreitenden Einträge
gelöscht.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{clean}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{)}\PY{p}{:}
    \PY{n}{min\PYZus{}limit} \PY{o}{=} \PY{l+m+mi}{0}
    
    \PY{k}{while} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}size}\PY{p}{:}
        \PY{n}{min\PYZus{}limit} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        
        \PY{n}{pre\PYZus{}len} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{p}{\PYZob{}}
            \PY{n}{key}\PY{p}{:} \PY{n}{value}
            \PY{k}{for} \PY{n}{key}\PY{p}{,} \PY{n}{value} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}
            \PY{k}{if} \PY{n}{key}\PY{p}{[}\PY{l+m+mi}{7}\PY{p}{]} \PY{o}{\PYZgt{}} \PY{n}{min\PYZus{}limit}
        \PY{p}{\PYZcb{}}
        
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Increased min\PYZus{}limit to }\PY{l+s+si}{\PYZob{}}\PY{n}{min\PYZus{}limit}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ and deleted }\PY{l+s+si}{\PYZob{}}\PY{n}{pre\PYZus{}len} \PY{o}{\PYZhy{}} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ entries. }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
              \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Cache is now }\PY{l+s+si}{\PYZob{}}\PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ entries big.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    
    \PY{k}{return} \PY{n}{min\PYZus{}limit} \PY{o}{!=} \PY{l+m+mi}{0}

\PY{n}{Cache}\PY{o}{.}\PY{n}{clean} \PY{o}{=} \PY{n}{clean}
\PY{k}{del} \PY{n}{clean}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{save} persistiert den Cache auf dem Dateisystem.
Dafür wird folgendes Argument erwartet:
\begin{itemize}
    \tightlist
    \item \texttt{path} beschreibt den Pfad zur zu schreibenden Datei im Dateisystem.    
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{save}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{,} \PY{n}{path}\PY{p}{:} \PY{n+nb}{str}\PY{p}{)}\PY{p}{:}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{n}{path}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{wb}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{k}{for} \PY{n}{key}\PY{p}{,}\PY{n}{value} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{:}
            \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{key}\PY{p}{)}
            \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{value}\PY{p}{)}

\PY{n}{Cache}\PY{o}{.}\PY{n}{save} \PY{o}{=} \PY{n}{save}
\PY{k}{del} \PY{n}{save}
\end{Verbatim}
\end{tcolorbox}

    Die Methode \texttt{load} lädt einen zuvor persistierten Cache aus einer
Datei, die sich auf dem Dateisystem des Computers befindet. Dafür wird
folgendes Argument erwartet: 

\begin{itemize}
    \tightlist
    \item \texttt{path} beschreibt den Pfad zur zu lesenden Datei im Dateisystem.    
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{load}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Cache}\PY{p}{,} \PY{n}{path}\PY{p}{:} \PY{n+nb}{str}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{n}{path}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Failed to load cache from file }\PY{l+s+si}{\PYZob{}}\PY{n}{path}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{return}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{n}{path}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{rb}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{k}{while} \PY{k+kc}{True}\PY{p}{:}
            \PY{n}{key} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{)}
            \PY{n}{value} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{l+m+mi}{24}\PY{p}{)}
            \PY{k}{if} \PY{o+ow}{not} \PY{n}{key} \PY{o+ow}{or} \PY{o+ow}{not} \PY{n}{value}\PY{p}{:}
                \PY{k}{break}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Successfully loaded cache from file }\PY{l+s+si}{\PYZob{}}\PY{n}{path}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{Cache}\PY{o}{.}\PY{n}{load} \PY{o}{=} \PY{n}{load}
\PY{k}{del} \PY{n}{load}
\end{Verbatim}
\end{tcolorbox}









    
\hypertarget{geschwindigkeit-tests-der-transpositionstabelle}{%
\section{nmm-rote-performance-testing: Geschwindigkeit Test der
Transpositionstabelle}\label{geschwindigkeit-tests-der-transpositionstabelle}}

    Die Klasse \texttt{Cache} aus dem Notebook \texttt{nmm-cache}
implementiert eine Transpositionstabelle die persistiert werden kann. Um
zu ermitteln wie diese implementiert werden soll, wurde zwischen zwei
Möglichkeiten abgewogen.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Zum einen steht die Verwendung einer externen Key-Value-Datenbank zur
  Auswahl. Diese wird in einem weiteren Container auf dem selben
  Computer ausgeführt, dadurch werden die Netzwerklatenzen minimiert.
\item
  Die zweite Möglichkeit ist das Speichern im Arbeitsspeicher in einem
  Python-Dictionary. Dieses kann anschließend exportiert und auf einen
  persistenten Datenträger geschrieben werden.
\end{enumerate}

Um zu ermitteln welche Methode verwendet werden sollte, wird im
Nachfolgenden die Geschwindigkeit der jeweiligen Methode getestet und
bewertet.

    \hypertarget{vorbereitungen}{%
\subsection{Vorbereitungen}\label{vorbereitungen}}

Bevor die Möglichkeiten getestet werden können, müssen folgende Pakete
geladen werden:

\begin{itemize}
    \tightlist
    \item \texttt{redis} implementiert die Kommunikation mit der Redis-Datenbank;
    \item \texttt{struct} übersetzt \texttt{float} Werte in \texttt{bytes};
    \item \texttt{random} ermittelt Zufallswerte zum testen;
    \item \texttt{tqdm} zeigt den Fortschritt an.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{redis}
\PY{k+kn}{import} \PY{n+nn}{struct}
\PY{k+kn}{import} \PY{n+nn}{random}
\PY{k+kn}{from} \PY{n+nn}{tqdm}\PY{n+nn}{.}\PY{n+nn}{notebook} \PY{k+kn}{import} \PY{n}{tqdm}
\end{Verbatim}
\end{tcolorbox}

    Des Weiteren wird die Klasse \texttt{CacheTest} angelegt, welche als
Interface für die jeweilige Implementierung dient. Zwei Funktionen
werden vorgegeben:

\begin{itemize}
\tightlist
\item
  \texttt{write} schreibt die Werte \texttt{value}, \texttt{alpha} und
  \texttt{beta} an dem Schlüssel \texttt{state} und \texttt{player} in
  den Cache;
\item
  \texttt{read} ließt die mit \texttt{write} gespeicherten Werte aus
  oder gibt \texttt{None} zurück, falls der Cache diese nicht
  beinhaltet.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{CacheTest}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{write}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{value}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{alpha}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{beta}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{k+kc}{None}\PY{p}{:}
        \PY{k}{pass}
    
    \PY{k}{def} \PY{n+nf}{read}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{p}{(}\PY{n+nb}{float}\PY{p}{,} \PY{n+nb}{float}\PY{p}{,} \PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
        \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}Value, Alpha, Beta\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{k}{pass}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{python-dictionary}{%
\subsection{Python-Dictionary}\label{python-dictionary}}

Der native Python Cache besteht aus einem einfachen Python-Dictionary in
welches die Key-Value-Paare gespeichert werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{PythonCache}\PY{p}{(}\PY{n}{CacheTest}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
        \PY{k}{pass}
    
    \PY{k}{def} \PY{n+nf}{write}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{value}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{alpha}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{beta}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{key} \PY{o}{=} \PY{n}{state}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{player}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{value} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{alpha}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{beta}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{value}
    
    \PY{k}{def} \PY{n+nf}{read}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{p}{(}\PY{n+nb}{float}\PY{p}{,}\PY{n+nb}{float}\PY{p}{,}\PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
        \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}Value, Alpha, Beta\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{n}{key} \PY{o}{=} \PY{n}{state}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{player}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{value} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{p}{(}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{8}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{l+m+mi}{8}\PY{p}{:}\PY{l+m+mi}{16}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{l+m+mi}{16}\PY{p}{:}\PY{l+m+mi}{24}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
        \PY{p}{)} \PY{k}{if} \PY{n}{value} \PY{k}{else} \PY{k+kc}{None}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{redis}{%
\subsection{Redis}\label{redis}}

Der Redis-Cache implementiert eine Transpositionstabelle auf basierend
auf der Key-Value-Datenbank \emph{Redis}. Die Übersetzung der Werte zu
Byte-Arrays erfolgt äquivalent zu dem Python-Cache. Die Werte werden
danach mit Hilfe des \texttt{redis} Pakets in der lokalen
Redis-Datenbank gespeichert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{RedisCache}\PY{p}{(}\PY{n}{CacheTest}\PY{p}{)}\PY{p}{:}
    \PY{n}{r} \PY{o}{=} \PY{n}{redis}\PY{o}{.}\PY{n}{Redis}\PY{p}{(}\PY{n}{host}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{redis}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{def} \PY{n+nf}{write}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{value}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{alpha}\PY{p}{:} \PY{n+nb}{float}\PY{p}{,} \PY{n}{beta}\PY{p}{:} \PY{n+nb}{float}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{key} \PY{o}{=} \PY{n}{state}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{player}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{value} \PY{o}{=} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{value}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{alpha}\PY{p}{)} \PY{o}{+} \PY{n}{struct}\PY{o}{.}\PY{n}{pack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{beta}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{r}\PY{o}{.}\PY{n}{set}\PY{p}{(}\PY{n}{key}\PY{p}{,}\PY{n}{value}\PY{p}{)}

    \PY{k}{def} \PY{n+nf}{read}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{player}\PY{p}{:} \PY{n+nb}{bool}\PY{p}{,} \PY{n}{limit}\PY{p}{:} \PY{n+nb}{int}\PY{p}{)}\PY{p}{:}
        \PY{n}{key} \PY{o}{=} \PY{n}{state}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{player}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o}{+} \PY{n}{limit}\PY{o}{.}\PY{n}{to\PYZus{}bytes}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{big}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{value} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{r}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{key}\PY{p}{)}
        \PY{k}{return} \PY{p}{(}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{p}{:}\PY{l+m+mi}{8}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{l+m+mi}{8}\PY{p}{:}\PY{l+m+mi}{16}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
            \PY{n}{struct}\PY{o}{.}\PY{n}{unpack}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{d}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{value}\PY{p}{[}\PY{l+m+mi}{16}\PY{p}{:}\PY{l+m+mi}{24}\PY{p}{]}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
        \PY{p}{)} \PY{k}{if} \PY{n}{value} \PY{k}{else} \PY{k+kc}{None}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{test}{%
\subsection{Test}\label{test}}

Als Vorbereitung des Tests werden zunächst Instanzen der einzelnen
\texttt{CacheTest} Implementierungen erstellt. Außerdem werden
Einstellungen für die Tests vorgenommen:

\begin{itemize}
\tightlist
\item
  \texttt{count} ist die Anzahl der Elemente, die in die Caches
  geschrieben werden sollen;
\item
  \texttt{start} bis \texttt{end} ist das Intervall in dem Zustände
  generiert werden. Ein Zustand ist in diesem Test jedeglich eine Zahl.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{pc} \PY{o}{=} \PY{n}{PythonCache}\PY{p}{(}\PY{p}{)}
\PY{n}{rc} \PY{o}{=} \PY{n}{RedisCache}\PY{p}{(}\PY{p}{)}

\PY{n}{count} \PY{o}{=}     \PY{l+m+mi}{1\PYZus{}000\PYZus{}000}
\PY{n}{start} \PY{o}{=} \PY{l+m+mi}{1\PYZus{}000\PYZus{}000\PYZus{}000}
\PY{n}{end}   \PY{o}{=} \PY{n}{start}\PY{o}{+}\PY{n}{count}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{test-der-schreibgeschwindigkeit}{%
\subsubsection{Test der
Schreibgeschwindigkeit}\label{test-der-schreibgeschwindigkeit}}

Durch die Einstellung \texttt{count} gesteuert werden zufällige Werte in
den Caches gespeichert. In diesem Fall sind es eine Millionen Einträge.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}\PYZpc{}time}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Python Cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{for} \PY{n}{state} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{player} \PY{o+ow}{in} \PY{p}{[}\PY{k+kc}{True}\PY{p}{,} \PY{k+kc}{False}\PY{p}{]}\PY{p}{:}
        \PY{k}{for} \PY{n}{limit} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{:}
            \PY{n}{pc}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{,} \PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}\PYZpc{}time}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Redis Cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{k}{for} \PY{n}{state} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{player} \PY{o+ow}{in} \PY{p}{[}\PY{k+kc}{True}\PY{p}{,} \PY{k+kc}{False}\PY{p}{]}\PY{p}{:}
        \PY{k}{for} \PY{n}{limit} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{:}
            \PY{n}{rc}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{,} \PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{random}\PY{o}{.}\PY{n}{random}\PY{p}{(}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Im Vergleich zu dem \texttt{PythonCache} ist der \texttt{RedisCache} bei
dem Schreibvorgang der Einträge etwa um den Faktor \(90\) langsamer.

    \hypertarget{testen-der-lesegeschwindigkeit}{%
\subsubsection{Testen der
Lesegeschwindigkeit}\label{testen-der-lesegeschwindigkeit}}

Bei dem Test der Lesegeschwindigkeit wird gemessen, wie schnell die
Werte für zufällig ermittelte Zustände zurück gegeben werden können.
Dabei wird auf die oben generierten Einträge zurück gegriffen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}\PYZpc{}time}
\PY{n}{valid} \PY{o}{=} \PY{l+m+mi}{0}
\PY{k}{for} \PY{n}{count} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n}{count}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{n}{state} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{limit} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
    \PY{n}{player} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{choice}\PY{p}{(}\PY{p}{[}\PY{k+kc}{True}\PY{p}{,} \PY{k+kc}{False}\PY{p}{]}\PY{p}{)}
    \PY{n}{result} \PY{o}{=} \PY{n}{pc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
    \PY{k}{if} \PY{n}{result} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{valid} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{valid}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}\PYZpc{}time}
\PY{n}{valid} \PY{o}{=} \PY{l+m+mi}{0}
\PY{k}{for} \PY{n}{count} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n}{count}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{n}{state} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{limit} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{randint}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
    \PY{n}{player} \PY{o}{=} \PY{n}{random}\PY{o}{.}\PY{n}{choice}\PY{p}{(}\PY{p}{[}\PY{k+kc}{True}\PY{p}{,} \PY{k+kc}{False}\PY{p}{]}\PY{p}{)}
    \PY{n}{result} \PY{o}{=} \PY{n}{rc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
    \PY{k}{if} \PY{n}{result} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{valid} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{valid}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Während die Lesegeschwindigkeit beim \texttt{RedisCache} deutlich höher
als die Schreibgeschwindigkeit ist, ist diese dennoch um etwa den Faktor
\(4\) langsamer als die des \texttt{PythonCache}s.

    \hypertarget{resumee}{%
\subsection{Resumee der Cache Implementierungen}\label{resumee}}

Sowohl die Lese- als auch die Schreibgeschwindigkeit ist beim
\texttt{PythonCache} deutlich höher als beim \texttt{RedisCache}. Wobei
die Geschwindigkeitsdifferenz beim Schreiben stärker ausfällt als beim
Lesen. Dies ist höchst wahrscheinlich auf den Overhead der Verbindung
zwischen Datenbank und dem Python-Programm zurückzuführen.

Aus diesem Grund wurde sich dafür entschieden, den Cache als
Python-Dictionary zu implementieren und anschließend als Datei auf dem
Datenträger zu persistieren. Hierbei wird in Kauf genommen, dass die
wachsende Größe des Caches zu einer starken Auslastung des
Arbeitsspeicher führen kann.









\hypertarget{rote-learning-training}{%
\section{nmm-rote-training: Rote-Learning Training}\label{rote-learning-training}}


    Der Rote-Learning Algorithmus muss im wahrsten Sinne des Wortes
auswendig lernen und das Spiel trainieren. Dazu werden möglichst viele
Spiele hintereinander gespielt und die Transpositionstabelle mit immer
mehr und genaueren Daten gefüllt.

Zunächst werden beide implementierte Algorithmen geladen:
\texttt{AlphaBetaPruning} und \texttt{Minimax}. Die \texttt{Match}
Implementierung aus dem \texttt{Tournament} Notebook kann ebenfalls
wieder verwendet werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}alpha\PYZhy{}beta\PYZhy{}pruning.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}minimax.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}tournament.ipynb
\end{Verbatim}
\end{tcolorbox}

    Um eine übersichtlichere Entwicklung zu ermöglichen, werden
Typdefinitionen geladen, welche später im Code verwendet werden. Das
Paket \texttt{tqdm} ermöglicht eine einfache Fortschrittsanzeige.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{typing} \PY{k+kn}{import} \PY{n}{Optional}\PY{p}{,} \PY{n}{Union}\PY{p}{,} \PY{n}{List}\PY{p}{,} \PY{n}{Callable}
\PY{k+kn}{from} \PY{n+nn}{tqdm}\PY{n+nn}{.}\PY{n+nn}{notebook} \PY{k+kn}{import} \PY{n}{tqdm}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{training}{%
\subsection{Training}\label{training}}

Innerhalb eines Trainings spielt eine künstliche Intelligenz viele Male
gegen sich selbst und erweitert so ihre Transpositionstabelle. Bei jedem
Spiel gegen sich selbst ist eine höhere Rekursionstiefe erreichbar, da
der Cache bereits Werte von vorherigen Runden beinhaltet. Da die
Implementierung der Transpositionstablle die gespeicherten Werte auf den
weißen Spieler normiert, ist es sogar effizient möglich, dass sich beide
künstliche Intelligenzen (weiß und schwarz) einen Cache teilen.

Innerhalb eines Trainings werden nur die ersten 18 Runden eines jeden
Spieles gespielt, da alle diese Runden gezwungenermaßen in der ersten
Spielphase \texttt{Placing} sind. Jeder Spieler muss alle seine 9 Steine
zu Beginn der Runde setzen. Dadurch werden innerhalb der 18 Runden alle
Steine von beiden Spielern gesetzt. Es wird nur die Spielphase
\texttt{Placing} trainiert, da diese Phase im Vergleich zur zweiten
Phase \texttt{Moving} um einiges komplexer ist. Bei jedem Zug kann jeder
neue Stein eines Spielers auf jedes freie Feld bewegt werden, in der
\texttt{Moving} Phase sind hingengen nur benachbarte leere Felder
möglich. Dadurch ist der Suchraum für die Algorithmen zu Beginn des
Spieles besonders groß und die künstliche Intelligenz kann
dementsprechend weniger Züge in die Zukunft schauen. Durch das
Auswendiglernen dieser Phase gewinnen die Algorithmen einen größeren
Vorteil.

Auch die letzte Phase \texttt{Flying} ist sehr komplex und würde vom
Auswendiglernen profitieren, allerdings wird hierzu eine
Endspieldatenbank implementiert. Diese Datenbank deckt die letzte Phase
besser ab als das Auswendiglernen.

    Die Klasse \texttt{Training} implementiert solch ein Training und
benötigt mehrere Parameter:

Verpflichtend: 
\begin{itemize}
    \tightlist
    \item \texttt{cache} ist die Instanz der
    Transpositionstabelle, die innerhalb des Trainings verwendet und damit
    trainiert werden soll;
    \item \texttt{artificial\_intelligence} ist eine
    Funktion die eine \texttt{ArtificialIntelligence} Instanz produziert,
    die jeweils für den weißen und den schwarzen Spieler aufgerufen wird;
\end{itemize}

Optional:
\begin{itemize}
    \tightlist
    \item \texttt{trainings} ist die Anzahl der Runden in denen
    trainiert werden sollen;
    \item \texttt{seed\_offset} ist die Zahl, die auf
    den Seed addiert werden soll um verschiedene Trainingsläufe erstellen zu
    können;
    \item \texttt{path\_prefix} ist der Prefix der vor den Dateinamen
    geschrieben wird, um den Cache Zwischenstand zu speichern;
    \item \texttt{save\_interval} ist das Intervall in dem der Cache auf der
    Festplatte zwischen gespeichert werden soll.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Training}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}
        \PY{n+nb+bp}{self}\PY{p}{,}
        \PY{n}{cache}\PY{p}{:} \PY{n}{Cache}\PY{p}{,}
        \PY{n}{artificial\PYZus{}intelligence}\PY{p}{:} \PY{n}{Callable}\PY{p}{[}\PY{p}{[}\PY{n}{Cache}\PY{p}{]}\PY{p}{,} \PY{n}{ArtificialIntelligence}\PY{p}{]}\PY{p}{,}
        \PY{n}{trainings}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{100}\PY{p}{,}
        \PY{n}{seed\PYZus{}offset}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{0}\PY{p}{,}
        \PY{n}{path\PYZus{}prefix}\PY{p}{:} \PY{n+nb}{str} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{training\PYZhy{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
        \PY{n}{save\PYZus{}interval}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{10}
    \PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{n}{cache}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{artificial\PYZus{}intelligence} \PY{o}{=} \PY{n}{artificial\PYZus{}intelligence}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{trainings} \PY{o}{=} \PY{n}{trainings}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset} \PY{o}{=} \PY{n}{seed\PYZus{}offset}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{path\PYZus{}prefix} \PY{o}{=} \PY{n}{path\PYZus{}prefix}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{save\PYZus{}interval} \PY{o}{=} \PY{n}{save\PYZus{}interval}
\end{Verbatim}
\end{tcolorbox}

    Für Entwicklungszwecke wird eine Stringdarstellung für die Klasse
\texttt{Training} implementiert. Hierzu wird durch die Funktion
\texttt{\_\_repr\_\_} ein String zurückgegeben, der alle Parameter der
Klasse beinhaltet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Training}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Training(cache=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
           \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{artificial\PYZus{}intelligence=}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{type}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{artificial\PYZus{}intelligence}\PY{p}{)}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
           \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{trainings=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{trainings}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, seed\PYZus{}offset=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
           \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{path\PYZus{}prefix=}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{path\PYZus{}prefix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{, save\PYZus{}interval=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{save\PYZus{}interval}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{Training}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{train} trainiert die gespeicherte
Transpositionstabelle indem für die Anzahl der zu spielenden Runden
(\texttt{trainings}) ein Spiel (\texttt{Match}) erstellt wird. Dieses
Spiel wird von zwei \texttt{ArtificialIntelligence} Instanzen gespielt,
welche durch die gespeicherte Funktion \texttt{artificial\_intelligence}
erstellt werden. Pro Spiel werden maximal 18 Runden, also nur die
\texttt{Placing} Phase gespielt. Nach \texttt{save\_interval} Spielen
sowie am Ende wird die Transpositionstabelle mit der Rundennummer auf
der Festplatte zwischengespeichert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{train}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Training}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{tqdm}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{trainings}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{n}{name} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{path\PYZus{}prefix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+si}{\PYZob{}}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{l+s+si}{:}\PY{l+s+s2}{0\PYZgt{}3}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}
        \PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset} \PY{o}{+} \PY{n}{i}\PY{p}{)}
        \PY{n}{match} \PY{o}{=} \PY{n}{Match}\PY{p}{(}
            \PY{n}{white}     \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{artificial\PYZus{}intelligence}\PY{p}{(}\PY{n}{cache} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{p}{,}
            \PY{n}{black}     \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{artificial\PYZus{}intelligence}\PY{p}{(}\PY{n}{cache} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{)}\PY{p}{,}
            \PY{n}{max\PYZus{}turns} \PY{o}{=} \PY{l+m+mi}{18}\PY{p}{,}
            \PY{n}{name}      \PY{o}{=} \PY{n}{name}
        \PY{p}{)}
        
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Training \PYZsh{}}\PY{l+s+si}{\PYZob{}}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{match}\PY{o}{.}\PY{n}{play}\PY{p}{(}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ \PYZgt{} }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        
        \PY{k}{if} \PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{save\PYZus{}interval} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZgt{} Saving to }\PY{l+s+s2}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{.cache}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{...}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{save}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{.cache}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{p}{)}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{save}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{path\PYZus{}prefix}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{final.cache}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n}{Training}\PY{o}{.}\PY{n}{train} \PY{o}{=} \PY{n}{train}
\PY{k}{del} \PY{n}{train}
\end{Verbatim}
\end{tcolorbox}











    \hypertarget{anwendung}{%
\section{Anwendung}\label{anwendung}}

Um den bei Rote-Learning beschriebenen Lerneffekt zu erzielen und die
Zustände zu Speichern, wurde eine Transpositionstabelle als Klasse
\texttt{Cache} in dem Notebook \texttt{nmm-cache} implementiert. Diese
Klasse verfügt über fünf Methoden zur Verwaltung des Caches:

\begin{itemize}
\tightlist
\item
  \texttt{write} speichert einen neuen Zustand und die errechneten Werte
  ab;
\item
  \texttt{read} liest die gespeicherten Werte eines Zustandes aus dem
  Cache aus;
\item
  \texttt{save} legt den Inhalt des Caches in einer Datei auf einem
  Datenträger ab;
\item
  \texttt{load} lädt die Daten des Caches aus einer Datei auf dem
  Datenträger;
\item
  \texttt{clean} löscht Einträge aus dem Cache, falls die Anzahl der
  Einträge \texttt{max\_size} überschritten wurde.
\end{itemize}

Um die einzelnen Werte für die Zustände im Cache abzulegen, werden
sowohl die Zustände als auch die Werte in ein Byte-Array konvertiert.
Insgesamt ist ein Eintrag des Caches somit 32 Bytes groß. Um zu
verhindern, dass der Cache zu groß wird um ihn im Arbeitsspeicher oder
auf dem Datenträger speichern zu können, wurde der Parameter
\texttt{max\_size} eingeführt. Dieser begrenzt den Cache auf eine
maximale Anzahl an Einträgen. Um die Performance zu steigern, wird dies
jedoch nicht beim jedem Aufruf der \texttt{write} Methode geprüft
sondern nur beim Aufruf der Methode \texttt{clean}. Dies kann dazu
führen, dass zwischen den Aufrufen der \texttt{clean} Methode mehr
Einträge im Cache vorhanden sind, als durch \texttt{max\_size} erlaubt.
Wird der Cache auf dem Datenträger abgelegt, entspricht die Dateigröße
genau der Anzahl an Elementen multipliziert mit 32 Bytes. Die Größe das
Caches im Arbeitsspeicher ist jedoch um einen Faktoren von ca. \(6\)
größer, da Python weiteren Arbeitsspeicher, beispielsweise für den
Datentyp, reserviert.

Der folgende Befehl erstellt einen Cache mit einer Größe von 50
Millionen Zuständen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{cache} \PY{o}{=} \PY{n}{Cache}\PY{p}{(}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{50\PYZus{}000\PYZus{}000}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{anbindung-an-ux3b1-ux3b2-pruning}{%
\subsection{Anbindung an
$\alpha$-$\beta$-Pruning}\label{anbindung-an-ux3b1-ux3b2-pruning}}

Da im $\alpha$-$\beta$-Pruning Algorithmus bereits die Verwendung eines
In-Memory-Caches vorgesehen ist, mussten nur kleine Anpassungen
vorgenommen werden. Es musste sichergestellt werden, dass sowohl zum
Schreiben als auch zum Lesen der Werte aus dem Cache die richtigen
Methoden aufgerufen werden, sowie dass ein Cache entweder als Parameter
übergeben werden kann oder ein neuer instanziiert wird. Nach jeder
Berechnung der nächsten besten Züge mit Hilfe der \texttt{bestMoves}
Methode, wurde der Aufruf der \texttt{clean} Methode hinterlegt, um die
Größe des Caches anzupassen.

    \hypertarget{traingingsprozess}{%
\subsection{Traingingsprozess}\label{traingingsprozess}}

Um die Transpositionstabelle zu trainieren und somit das Rote-Learning
umzusetzen, wird die Klasse \texttt{Training} aus dem Notebook
\texttt{nmm-rote-training} verwendet. Dazu muss zuerst eine Methode
erstellt werden, welche den Algorithmus für die künstliche Intelligenz
konfiguriert und generiert. Diese Methode wird
\texttt{artificial\_intelligence\_generator} genannt und generiert eine
AlphaBetaPruning Instanz, welche den übergebenen Cache und eine
benutzerdefinierte Heuristiken verwendet. Die verwendeten Heuristiken
wurden bereits im Rahmen der Studienarbeit ermittelt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{artificial\PYZus{}intelligence\PYZus{}generator}\PY{p}{(}\PY{n}{cache}\PY{p}{:} \PY{n}{Cache}\PY{p}{)}\PY{p}{:}
    \PY{n}{customWeights} \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{stash} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{mills} \PY{o}{=} \PY{l+m+mi}{2}\PY{p}{,} \PY{n}{possible\PYZus{}mills} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{)}
    \PY{k}{return} \PY{n}{AlphaBetaPruning}\PY{p}{(}\PY{n}{cache} \PY{o}{=} \PY{n}{cache}\PY{p}{,} \PY{n}{weights} \PY{o}{=} \PY{n}{customWeights}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Für den Cache wurde sich für eine maximale Größe von 50.000.000
Einträgen entschieden. Dies resultiert in eine maximal Größe des Caches
von ca. 1,6Gb auf dem Datenträger. Des Weiteren werden die Standardwerte
der Training-Klasse verwendet. Das heißt, dass ingesamt 100 Spiele
gespielt werden und der Seed für den Zufallsgenerator nicht angepasst
wird. Alle 10 Spiele wird der Cache auf dem Datenträger gespeichert und
wird der Prefix \texttt{training-} für den Dateinamen verwendet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{training} \PY{o}{=} \PY{n}{Training}\PY{p}{(}
    \PY{n}{cache} \PY{o}{=} \PY{n}{cache}\PY{p}{,} 
    \PY{n}{artificial\PYZus{}intelligence} \PY{o}{=} \PY{n}{artificial\PYZus{}intelligence\PYZus{}generator}\PY{p}{,}
    \PY{n}{path\PYZus{}prefix} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{training\PYZhy{}small\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Der Trainingsprozess wird durch den Aufruf der Funktion \texttt{train}
gestartet und dauert mit der oben genannten Konfiguration in etwa 4,5
Stunden. Dabei werden bis zu 10 Gb Arbeitsspeicher benötigt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{mem\PYZus{}usage} \PY{o}{=} \PY{n}{memory\PYZus{}usage}\PY{p}{(}\PY{n}{training}\PY{o}{.}\PY{n}{train}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Maximum memory usage: }\PY{l+s+si}{\PYZpc{}s}\PY{l+s+s1}{ MB.}\PY{l+s+s1}{\PYZsq{}} \PY{o}{\PYZpc{}} \PY{n+nb}{max}\PY{p}{(}\PY{n}{mem\PYZus{}usage}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{trainings-limitierungen}{%
\subsubsection{Trainings Limitierungen}\label{trainings-limitierungen}}

Auf den ersten Blick scheint es so, dass man den Cache unendlich weiter
trainieren kann. Dies jedoch mit der aktuellen Implementierung nicht
zielführend. Ab einem gewissen Trainingszeitpunkt ist das
Rekursionslimit der Einträge im Cache so hoch, dass dieses durch
weiteres Training nicht erneut erreicht werden können. Dies ist lässt
sich gut an nachfolgendem Beispiel erkennen:

Durch die geringe Größe des Caches sowie dem kleinen Wert für
\texttt{max\_states} kommt man sehr schnell an den Punkt, an dem das
Cache-Limit auf 3 erhöht wird. Dadurch werden fast alle Einträge aus dem
Cache gelöscht und es verbleiben nur noch \texttt{48} im Cache. Dies
passiert mehrere Male und ist ein Zeichen dafür, dass der Cache nicht
mehr weiter trainiert werden kann, da dieser zu klein ist um genügend
Einträge zu halten, damit mehr Einträge mit \texttt{limit\ =\ 3}
berechnet werden können bevor der \texttt{max\_states} Wert
überschritten wird.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{t} \PY{o}{=} \PY{n}{Training}\PY{p}{(}
    \PY{n}{cache}                   \PY{o}{=} \PY{n}{Cache}\PY{p}{(}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{1\PYZus{}000}\PY{p}{)}\PY{p}{,}
    \PY{n}{artificial\PYZus{}intelligence} \PY{o}{=} \PY{k}{lambda} \PY{n}{cache}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}
        \PY{n}{cache}      \PY{o}{=} \PY{n}{cache}\PY{p}{,}
        \PY{n}{max\PYZus{}states} \PY{o}{=} \PY{l+m+mi}{1\PYZus{}000}
    \PY{p}{)}\PY{p}{,}
    \PY{n}{path\PYZus{}prefix}             \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{max\PYZhy{}learning\PYZhy{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
    \PY{n}{save\PYZus{}interval}           \PY{o}{=} \PY{l+m+mi}{1}
\PY{p}{)}
\PY{n}{t}\PY{o}{.}\PY{n}{train}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{auswertung}{%
\subsection{Auswertung}\label{auswertung}}

Bei der Auswertung wird auf die Klasse \texttt{Tournament} aus dem
Notebook \texttt{nmm-tournament} zurück gegriffen. Diese Klasse besitzt
die Methode \texttt{play}, welche es ermöglicht verschiedene Algorithmen
gegeneinander Antreten zu lassen und die Ergebnisse zu speichern.

Um zu ermitteln ob die Rote-Learning-Methode einen Vorteil gegenüber
einem normalen Cache bietet, tritt eine über 100 Spiele trainierte
Trainspositionstabelle gegen eine untrainierte Transpositionstabelle an.
Dies wird zehn mal mit verschiedenen Seeds wiederholt. Das verändern der
Seeds sorgt dabei für einen veränderten Spielverlauf. Somit sollte
ermittelt werden können, ob durch das Training eine Verbesserung der
künstlichen Intelligenz eintritt und wenn ja, wie deutlich diese
Verbesserung ausfällt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}\PY{p}{:}
    \PY{n}{Tournament}\PY{p}{(}
        \PY{p}{[}
            \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}
                \PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{New Cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
                \PY{n}{weights} \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{stash} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{mills} \PY{o}{=} \PY{l+m+mi}{2}\PY{p}{,} \PY{n}{possible\PYZus{}mills} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}
                \PY{n}{cache} \PY{o}{=} \PY{n}{Cache}\PY{p}{(}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{50\PYZus{}000\PYZus{}000}\PY{p}{)}
            \PY{p}{)}\PY{p}{,}
            \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}
                \PY{n}{name}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Trained Cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
                \PY{n}{weights} \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{stash} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{mills} \PY{o}{=} \PY{l+m+mi}{2}\PY{p}{,} \PY{n}{possible\PYZus{}mills} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,}
                \PY{n}{cache} \PY{o}{=} \PY{n}{Cache}\PY{p}{(}\PY{n}{max\PYZus{}size} \PY{o}{=} \PY{l+m+mi}{50\PYZus{}000\PYZus{}000}\PY{p}{,} \PY{n}{path} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{training\PYZhy{}small\PYZhy{}final.cache}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
            \PY{p}{)}
        \PY{p}{]}\PY{p}{,}
        \PY{n}{instances\PYZus{}per\PYZus{}round} \PY{o}{=} \PY{l+m+mi}{1}\PY{p}{,}
        \PY{n}{seed\PYZus{}offset}         \PY{o}{=} \PY{n}{i}\PY{p}{,}
        \PY{n}{name}                \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{small\PYZhy{}full\PYZhy{}}\PY{l+s+si}{\PYZob{}}\PY{n}{i}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZhy{}seed}\PY{l+s+s2}{\PYZdq{}}
    \PY{p}{)}\PY{o}{.}\PY{n}{play}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Auswertung hat ergeben, dass von insgesamt von 20 gespielten Spielen
10 gewonnen wurden. Bei 5 lief es auf ein Unentschieden herraus und 5
wurden verloren. Damit lässt sich mit ziemlicher Sicherheit sagen, dass
das Training der ersten Spielphase durch Rote-Learning einen Vorteil im
gesamten Spielverlauf bietet.

    \hypertarget{fazit}{%
\section{Fazit}\label{fazit}}

Das Ziel dieser Arbeit war die Implementierung des in dem Paper
\texttt{Some\ Studies\ in\ Machine\ Learning\ Using\ the\ Game\ of\ Checkers}
von \texttt{A.L.Samuel} beschriebene Prinzip von Rote-Learning zu
erarbeiten. Das Ziel wurde erfolgreich durch eine Python-Implementierung
erreicht und durch eine Verbesserung der Leistung einer künstlichen
Intelligenz bestätigt. Im Laufe der Arbeit wurde sich neben der
Implementierung in Python auch mit den dem $\alpha$-$\beta$-Pruning Algorithmus sowie
verschiedenen Methoden zur Persistierung eines Caches beschäftigt.

Während in dem Paper jedoch zwei Methoden beschrieben werden, um
Einträge aus einem zu großen Cache zu löschen, wird sich in dieser
Arbeit nur auf eine Methode konzentriert. Im Paper wird zum einen die
Aufruf-Frequenz oder zum anderen das Rekursionslimit des Eintrags. Diese
Arbeit behandelt nur das Löschen von Einträgen basierend auf dem
Rekursionslimit.

Dennoch lässt sich sagen, dass diese Arbeit ein Erfolg war, da eine
deutliche Verbesserung des $\alpha$-$\beta$-Pruning mit einem trainierten Cache
erreicht werden konnte, sodass nach 100 Trainingsrunden nur noch 25\%
der Spiele gegen eine nicht trainierte künstliche Intelligenz verloren
wurden.


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
