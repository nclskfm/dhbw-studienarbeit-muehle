\documentclass[11pt]{article}
    
    \usepackage[breakable]{tcolorbox}
    \usepackage{parskip} % Stop auto-indenting (to mimic markdown behaviour)
    
    \usepackage{iftex}
    \ifPDFTeX
    	\usepackage[T1]{fontenc}
    	\usepackage{mathpazo}
    \else
    	\usepackage{fontspec}
    \fi

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % Maintain compatibility with old templates. Remove in nbconvert 6.0
    \let\Oldincludegraphics\includegraphics
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionFormat{nocaption}{}
    \captionsetup{format=nocaption,aboveskip=0pt,belowskip=0pt}

    \usepackage{float}
    \floatplacement{figure}{H} % forces figures to be placed at the correct location
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range
    \makeatletter % fix for old versions of grffile with XeLaTeX
    \@ifpackagelater{grffile}{2019/11/01}
    {
      % Do nothing on new versions
    }
    {
      \def\Gread@@xetex#1{%
        \IfFileExists{"\Gin@base".bb}%
        {\Gread@eps{\Gin@base.bb}}%
        {\Gread@@xetex@aux#1}%
      }
    }
    \makeatother
    \usepackage[Export]{adjustbox} % Used to constrain images to a maximum size
    \adjustboxset{max size={0.9\linewidth}{0.9\paperheight}}

    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    % The default LaTeX title has an obnoxious amount of whitespace. By default,
    % titling removes some of it. It also provides customization options.
    \usepackage{titling}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    \usepackage{mathrsfs}
    

    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}
    \definecolor{ansi-default-inverse-fg}{HTML}{FFFFFF}
    \definecolor{ansi-default-inverse-bg}{HTML}{000000}

    % common color for the border for error outputs.
    \definecolor{outerrorbackground}{HTML}{FFDFDF}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatibility definitions
    \def\gt{>}
    \def\lt{<}
    \let\Oldtex\TeX
    \let\Oldlatex\LaTeX
    \renewcommand{\TeX}{\textrm{\Oldtex}}
    \renewcommand{\LaTeX}{\textrm{\Oldlatex}}
    % Document parameters
    % Document title
    \title{Studienarbeit zur Erstellung einer kÃ¼nstlichen Intelligenz zum Spielen des Brettspiels MÃ¼hle}
    
    
    
    
    
% Pygments definitions
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\@namedef{PY@tok@w}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\@namedef{PY@tok@c}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cp}{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\@namedef{PY@tok@k}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kt}{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\@namedef{PY@tok@o}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ow}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@nb}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nf}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@nn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@ne}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\@namedef{PY@tok@nv}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@no}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\@namedef{PY@tok@nl}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\@namedef{PY@tok@ni}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\@namedef{PY@tok@na}{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\@namedef{PY@tok@nt}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@nd}{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\@namedef{PY@tok@s}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sd}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@si}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@se}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\@namedef{PY@tok@sr}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\@namedef{PY@tok@ss}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sx}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@m}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@gh}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@gu}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\@namedef{PY@tok@gd}{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\@namedef{PY@tok@gi}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\@namedef{PY@tok@gr}{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\@namedef{PY@tok@ge}{\let\PY@it=\textit}
\@namedef{PY@tok@gs}{\let\PY@bf=\textbf}
\@namedef{PY@tok@gp}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\@namedef{PY@tok@go}{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\@namedef{PY@tok@gt}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\@namedef{PY@tok@err}{\def\PY@bc##1{{\setlength{\fboxsep}{\string -\fboxrule}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}}
\@namedef{PY@tok@kc}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kd}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kn}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@kr}{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@bp}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\@namedef{PY@tok@fm}{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\@namedef{PY@tok@vc}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vg}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vi}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@vm}{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\@namedef{PY@tok@sa}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sb}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sc}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@dl}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s2}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@sh}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@s1}{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\@namedef{PY@tok@mb}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mf}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mh}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mi}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@il}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@mo}{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\@namedef{PY@tok@ch}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cm}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cpf}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@c1}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\@namedef{PY@tok@cs}{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % For linebreaks inside Verbatim environment from package fancyvrb. 
    \makeatletter
        \newbox\Wrappedcontinuationbox 
        \newbox\Wrappedvisiblespacebox 
        \newcommand*\Wrappedvisiblespace {\textcolor{red}{\textvisiblespace}} 
        \newcommand*\Wrappedcontinuationsymbol {\textcolor{red}{\llap{\tiny$\m@th\hookrightarrow$}}} 
        \newcommand*\Wrappedcontinuationindent {3ex } 
        \newcommand*\Wrappedafterbreak {\kern\Wrappedcontinuationindent\copy\Wrappedcontinuationbox} 
        % Take advantage of the already applied Pygments mark-up to insert 
        % potential linebreaks for TeX processing. 
        %        {, <, #, %, $, ' and ": go to next line. 
        %        _, }, ^, &, >, - and ~: stay at end of broken line. 
        % Use of \textquotesingle for straight quote. 
        \newcommand*\Wrappedbreaksatspecials {% 
            \def\PYGZus{\discretionary{\char`\_}{\Wrappedafterbreak}{\char`\_}}% 
            \def\PYGZob{\discretionary{}{\Wrappedafterbreak\char`\{}{\char`\{}}% 
            \def\PYGZcb{\discretionary{\char`\}}{\Wrappedafterbreak}{\char`\}}}% 
            \def\PYGZca{\discretionary{\char`\^}{\Wrappedafterbreak}{\char`\^}}% 
            \def\PYGZam{\discretionary{\char`\&}{\Wrappedafterbreak}{\char`\&}}% 
            \def\PYGZlt{\discretionary{}{\Wrappedafterbreak\char`\<}{\char`\<}}% 
            \def\PYGZgt{\discretionary{\char`\>}{\Wrappedafterbreak}{\char`\>}}% 
            \def\PYGZsh{\discretionary{}{\Wrappedafterbreak\char`\#}{\char`\#}}% 
            \def\PYGZpc{\discretionary{}{\Wrappedafterbreak\char`\%}{\char`\%}}% 
            \def\PYGZdl{\discretionary{}{\Wrappedafterbreak\char`\$}{\char`\$}}% 
            \def\PYGZhy{\discretionary{\char`\-}{\Wrappedafterbreak}{\char`\-}}% 
            \def\PYGZsq{\discretionary{}{\Wrappedafterbreak\textquotesingle}{\textquotesingle}}% 
            \def\PYGZdq{\discretionary{}{\Wrappedafterbreak\char`\"}{\char`\"}}% 
            \def\PYGZti{\discretionary{\char`\~}{\Wrappedafterbreak}{\char`\~}}% 
        } 
        % Some characters . , ; ? ! / are not pygmentized. 
        % This macro makes them "active" and they will insert potential linebreaks 
        \newcommand*\Wrappedbreaksatpunct {% 
            \lccode`\~`\.\lowercase{\def~}{\discretionary{\hbox{\char`\.}}{\Wrappedafterbreak}{\hbox{\char`\.}}}% 
            \lccode`\~`\,\lowercase{\def~}{\discretionary{\hbox{\char`\,}}{\Wrappedafterbreak}{\hbox{\char`\,}}}% 
            \lccode`\~`\;\lowercase{\def~}{\discretionary{\hbox{\char`\;}}{\Wrappedafterbreak}{\hbox{\char`\;}}}% 
            \lccode`\~`\:\lowercase{\def~}{\discretionary{\hbox{\char`\:}}{\Wrappedafterbreak}{\hbox{\char`\:}}}% 
            \lccode`\~`\?\lowercase{\def~}{\discretionary{\hbox{\char`\?}}{\Wrappedafterbreak}{\hbox{\char`\?}}}% 
            \lccode`\~`\!\lowercase{\def~}{\discretionary{\hbox{\char`\!}}{\Wrappedafterbreak}{\hbox{\char`\!}}}% 
            \lccode`\~`\/\lowercase{\def~}{\discretionary{\hbox{\char`\/}}{\Wrappedafterbreak}{\hbox{\char`\/}}}% 
            \catcode`\.\active
            \catcode`\,\active 
            \catcode`\;\active
            \catcode`\:\active
            \catcode`\?\active
            \catcode`\!\active
            \catcode`\/\active 
            \lccode`\~`\~ 	
        }
    \makeatother

    \let\OriginalVerbatim=\Verbatim
    \makeatletter
    \renewcommand{\Verbatim}[1][1]{%
        %\parskip\z@skip
        \sbox\Wrappedcontinuationbox {\Wrappedcontinuationsymbol}%
        \sbox\Wrappedvisiblespacebox {\FV@SetupFont\Wrappedvisiblespace}%
        \def\FancyVerbFormatLine ##1{\hsize\linewidth
            \vtop{\raggedright\hyphenpenalty\z@\exhyphenpenalty\z@
                \doublehyphendemerits\z@\finalhyphendemerits\z@
                \strut ##1\strut}%
        }%
        % If the linebreak is at a space, the latter will be displayed as visible
        % space at end of first line, and a continuation symbol starts next line.
        % Stretch/shrink are however usually zero for typewriter font.
        \def\FV@Space {%
            \nobreak\hskip\z@ plus\fontdimen3\font minus\fontdimen4\font
            \discretionary{\copy\Wrappedvisiblespacebox}{\Wrappedafterbreak}
            {\kern\fontdimen2\font}%
        }%
        
        % Allow breaks at special characters using \PYG... macros.
        \Wrappedbreaksatspecials
        % Breaks at punctuation characters . , ; ? ! and / need catcode=\active 	
        \OriginalVerbatim[#1,codes*=\Wrappedbreaksatpunct]%
    }
    \makeatother

    % Exact colors from NB
    \definecolor{incolor}{HTML}{303F9F}
    \definecolor{outcolor}{HTML}{D84315}
    \definecolor{cellborder}{HTML}{CFCFCF}
    \definecolor{cellbackground}{HTML}{F7F7F7}
    
    % prompt
    \makeatletter
    \newcommand{\boxspacing}{\kern\kvtcb@left@rule\kern\kvtcb@boxsep}
    \makeatother
    \newcommand{\prompt}[4]{
        {\ttfamily\llap{{\color{#2}[#3]:\hspace{3pt}#4}}\vspace{-\baselineskip}}
    }
    

    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

\begin{document}
    
    \maketitle
    
    

    
    \hypertarget{einleitung}{%
\section{Einleitung}\label{einleitung}}

Im Rahmen dieser Studienarbeit wird eine kÃ¼nstliche Intelligenz
entwickelt, die das Brettspiel MÃ¼hle spielen kann. DafÃ¼r werden die
beiden Algorithmen \emph{Minimax} und \emph{$\alpha$-$\beta$-Pruning} implementiert.

Die Arbeit wurde von Joost Ole Seddig, Benedikt Funke und Niclas
Kaufmann im dritten Studienjahr des Bachelorstudiengangs
\emph{Angewandte Informatik} im Kurs TINF18AI2 angefertigt. Der Betreuer
der Studienarbeit ist Prof.~Dr.~Karl Stroetmann.

    \hypertarget{muehle}{%
\subsection{MÃ¼hle}\label{muehle}}

MÃ¼hle ist ein Brettspiel fÃ¼r zwei Personen. Das Spielbrett besteht aus
drei Quadraten, die in den Seitenmitten verbunden sind. Jeder Spieler
(meistens mit \emph{schwarz} und \emph{weiÃ} bezeichnet) startet mit 9
Steinen, die nacheinander auf das Spielbrett gelegt werden. Gewonnen ist
das Spiel, wenn der Gegenspieler keinen Zug mehr spielen kann oder er
weniger als drei Steine auf dem Spielbrett hat. Ein Spieler kann eine
sogenannte MÃ¼hle bilden, wenn er drei seiner Spielsteine in eine Reihe
ziehen kann. Daraufhin darf er dem Gegenspieler einen Spielstein vom
Brett entfernen. Die exakten Spielregeln kÃ¶nnen in den
\href{http://www.muehlespiel.eu/images/pdf/WMD_Turnierreglement.pdf}{offiziellen
Turnierregeln} des \emph{WeltmÃ¼hlespiel Dachverband} nachgelesen werden.

Die beiden Algorithmen \emph{Minimax} und \emph{$\alpha$-$\beta$-Pruning} sind
Suchalgorithmen zur Bestimmung eines optimalen Zuges bei einem
Zwei-Personenspiel. Im weiteren Verlauf der Studienarbeit werden die
Suchalgorithmus durch die Verwendung von Symmetrie und iterativer
Tiefensuche weiter verbessert. Symmetrie bedeutet in diesem Fall, dass
man es sich zu Nutze macht, dass MÃ¼hle ein quadratische Spielfeld nutzt
und man durch Drehungen und Spiegelungen gleiche ZustÃ¤nde erhÃ¤lt.
Iterative Tiefensuche ist ein Verfahren, mit dem man kontinuierlich die
Suchtiefe des Algorithmus erhÃ¶ht.

ZusÃ¤tzlich zu dem Spiel soll eine graphische OberflÃ¤che entwickelt
werden, damit das Spiel auch vom Menschen gespielt werden kann.

Zum Abschluss der Arbeit wird eine Art Turnier gespielt, die die beiden
Algorithmen sowie verschiedene Heuristiken gegeneinander spielen lÃ¤sst.
Somit soll eine quantitative Bewertung der Implementierung ermÃ¶glicht
werden.

    \hypertarget{inhaltsverzeichnis}{%
\subsection{Inhaltsverzeichnis}\label{inhaltsverzeichnis}}

Die gesamte Studienarbeit wird in Jupyter Notebooks mit der
Progammiersprache Python geschrieben. So kÃ¶nnen die Implementierungen
direkt erklÃ¤rt werden. Zum Lesen der Studienarbeit wird folgende
Lesereihenfolge empfohlen:

\hypertarget{nmm-game-utils.ipynb}{%
\subsubsection{nmm-game-utils.ipynb}\label{nmm-game-utils.ipynb}}

Dieses Notebook beschreibt Hilfsfunktionen, die fÃ¼r die allgemeine
MÃ¼hle-Implementierung benÃ¶tigt werden.

\hypertarget{nmm-game.ipynb}{%
\subsubsection{nmm-game.ipynb}\label{nmm-game.ipynb}}

In diesem Notebook wird das Spiel MÃ¼hle implementiert.

\hypertarget{nmm-artificial-intelligence.ipynb}{%
\subsubsection{nmm-artificial-intelligence.ipynb}\label{nmm-artificial-intelligence.ipynb}}

Dieses Notebook implementiert eine abstrake Superklasse
\texttt{ArtificialIntelligence}, um die Implementierung von
\emph{Minimax} und \emph{$\alpha$-$\beta$-Pruning} zu vereinheitlichen.

\hypertarget{nmm-heuristic.ipynb}{%
\subsubsection{nmm-heuristic.ipynb}\label{nmm-heuristic.ipynb}}

Falls die maximale Suchtiefe erreicht wird und der betrachtete Zustand
das Spiel nicht beendet, muss der Wert des Zustandes geschÃ¤tzt werden.
Diesen Wert schÃ¤tzt eine Heuristik, die in diesem Notebook implementiert
wird.

\hypertarget{nmm-symmetry.ipynb}{%
\subsubsection{nmm-symmetry.ipynb}\label{nmm-symmetry.ipynb}}

Dieses Notebook definiert die verschiedenen Symmetrien, die fÃ¼r ein
Spielbrett erkannt werden sollen.

\hypertarget{nmm-minimax.ipynb}{%
\subsubsection{nmm-minimax.ipynb}\label{nmm-minimax.ipynb}}

In diesem Notebook wird der erste Algorithmus \emph{Minimax}
implementiert.

\hypertarget{nmm-alpha-beta-pruning.ipynb}{%
\subsubsection{nmm-alpha-beta-pruning.ipynb}\label{nmm-alpha-beta-pruning.ipynb}}

Der Algorithmus \emph{$\alpha$-$\beta$-Pruning} wird in diesem Notebook beschrieben
und entwickelt.

\hypertarget{nmm-gui-utils.ipynb}{%
\subsubsection{nmm-gui-utils.ipynb}\label{nmm-gui-utils.ipynb}}

Dieses Notebook beschreibt Hilfsfunktionen, die fÃ¼r das Zeichnen der
graphischen OberflÃ¤che und Spielen in dieser benÃ¶tigt werden.

\hypertarget{nmm-gui.ipynb}{%
\subsubsection{nmm-gui.ipynb}\label{nmm-gui.ipynb}}

Das Spielen in der graphischen OberflÃ¤che wird in diesem Notebook
implementiert.

\hypertarget{nmm-tournament.ipynb}{%
\subsubsection{nmm-tournament.ipynb}\label{nmm-tournament.ipynb}}

Um eine Analyse der beiden Algorithmen \emph{Minimax} und
\emph{$\alpha$-$\beta$-Pruning} und verschiedener Heuristiken durchfÃ¼hren zu kÃ¶nnen,
wird in diesem Notebook eine Art Turnier implementiert. Dieses Turnier
ermÃ¶glicht es, dass verschiedene AusfÃ¼hrungen der Algorithmen
automatisch gegeneinander spielen kÃ¶nnen und die SpielverlÃ¤ufe und
Ergebnisse aufgezeichnet werden.

\hypertarget{nmm-conclusion.ipynb}{%
\subsubsection{nmm-conclusion.ipynb}\label{nmm-conclusion.ipynb}}

Zum Abschluss der Studienarbeit wird das Turnier aus dem vorherigen
Notebook gespielt und die Algorithmen und Heuristiken ausgewertet. In
dem Fazit werden auÃerdem Verbesserungen fÃ¼r die Implementierung
aufgezeigt.


    % Add a bibliography block to the postdoc
    
 
    
    
    

    
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktionen-fuxfcr-die-spielimplementierung}{%
\section{Hilfsfunktionen fÃ¼r die
Spielimplementierung}\label{hilfsfunktionen-fuxfcr-die-spielimplementierung}}

In dieser Dateien werden Hilfsfunktionien implementiert, die fÃ¼r die
grundlegende Spielimplementierung benÃ¶tigt werden.

    \hypertarget{hilfsfunktionen-fuxfcr-spielsteine}{%
\subsection{Hilfsfunktionen fÃ¼r
Spielsteine}\label{hilfsfunktionen-fuxfcr-spielsteine}}

Nachfolgend werden alle Hilfsfunktionen implementiert, die fÃ¼r das
Interagieren mit den Spielsteinen benÃ¶tigt werden.

    Die Funktion \texttt{hasPlaceableStones} Ã¼berprÃ¼ft, ob ein Spieler fÃ¼r
einen Zustand noch zusetzende Steine auf dem Stapel (\emph{stash})
besitzt. Die Funktion hat zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{s} \(\in States\);
\item
  \texttt{p} \(\in Player\).
\end{itemize}

Die Funktion gibt ein booleschen Wert zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{hasPlaceableStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{p}{(}\PY{p}{(}\PY{n}{cw}\PY{p}{,} \PY{n}{cb}\PY{p}{)}\PY{p}{,} \PY{n}{\PYZus{}}\PY{p}{)} \PY{o}{=} \PY{n}{s}
    \PY{k}{return} \PY{n}{cw} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{l+m+mi}{1} \PY{k}{if} \PY{n}{p} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}} \PY{k}{else} \PY{n}{cb} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{l+m+mi}{1}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{countStones} zÃ¤hlt die Steine eines Spieler auf
einem Spielbrett. Die Funktion hat zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{s} \(\in States\);
\item
  \texttt{p} \(\in Player\).
\end{itemize}

Die Funktion zÃ¤hlt nur die Steine auf dem Brett, nicht die Steine auf
dem Stapel und gibt diese als Ganzzahl zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{countStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{p}{(}\PY{n}{\PYZus{}}\PY{p}{,} \PY{n}{board}\PY{p}{)} \PY{o}{=} \PY{n}{s}
    \PY{k}{return} \PY{p}{[}\PY{n}{cell} \PY{k}{for} \PY{n}{ring} \PY{o+ow}{in} \PY{n}{board} \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n}{ring}\PY{p}{]}\PY{o}{.}\PY{n}{count}\PY{p}{(}\PY{n}{p}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{isAllowedToJump} Ã¼berprÃ¼ft, ob ein Spieler bei
einem gegebenen Zustand seine Steine beliebig bewegen darf. Die Funktion
hat zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{s} \(\in States\);
\item
  \texttt{p} \(\in Player\).
\end{itemize}

Ein Spieler darf mit seinen Steinen springen, g.d.w. er weniger als drei
Steine auf dem Spielbrett hat und sich keine Steine mehr von dem Spieler
auf dem Stapel befinden. Die zweite Bedingung wird nicht Ã¼berprÃ¼ft, weil
davon ausgegangen wird, dass die Funktion \texttt{hasPlaceableStones}
zuvor aufgerufen wird.

Die Funktion gibt einen booleschen Wert zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{isAllowedToJump}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{countStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{3}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{hasEnoughStones} Ã¼berprÃ¼ft, ob ein Spieler noch
genÃ¼gend Steine zum Weiterspielen Ã¼brig hat. Die Funktion hat zwei
Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{s} \(\in States\);
\item
  \texttt{p} \(\in Player\).
\end{itemize}

Ein Spieler hat genau dann genÃ¼gend Steine, wenn er noch Steine zum
Setzen auf dem Stapel hat oder er mindestes drei Steine auf dem
Spielbrett besitzt.

Die Funktion gibt einen booleschen Wert zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{hasEnoughStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{hasPlaceableStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)} \PY{o+ow}{or} \PY{n}{countStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{l+m+mi}{3}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{removeFromStash} entfernt einen Stein von dem
Stapel des gegebenen Spielers. Die Funktion hat zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{stash} ist ein Stapel;
\item
  \texttt{p} \(\in Player\).
\end{itemize}

Die Funktion gibt den neuen Stapel zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{removeFromStash}\PY{p}{(}\PY{n}{stash}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{(}
        \PY{n}{stash}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{p}{(}\PY{l+m+mi}{1} \PY{k}{if} \PY{n}{p} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}} \PY{k}{else} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,}
        \PY{n}{stash}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{p}{(}\PY{l+m+mi}{1} \PY{k}{if} \PY{n}{p} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}} \PY{k}{else} \PY{l+m+mi}{0}\PY{p}{)}
    \PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktionen-fuxfcr-spieler}{%
\subsection{Hilfsfunktionen fÃ¼r
Spieler}\label{hilfsfunktionen-fuxfcr-spieler}}

In diesem Kapitel werden Hilfsfunktionen fÃ¼r die Spieler implementiert.

    Die Funktion \texttt{opponent} nimmt einen Spieler und gibt den
Gegenspieler zurÃ¼ck. Die Funktion hat ein Argument:

\begin{itemize}
\tightlist
\item
  \texttt{p} \(\in Player\).
\end{itemize}

Da MÃ¼hle ein Zwei-Personen-Spiel ist, gibt es fÃ¼r die Funktion nur zwei
FÃ¤lle:

\begin{itemize}
\tightlist
\item
  bei dem weiÃen Spieler \texttt{\textquotesingle{}w\textquotesingle{}}
  wird der Gegenspieler schwarz
  \texttt{\textquotesingle{}b\textquotesingle{}} zurÃ¼ckgegeben,
\item
  ansonsten wird standardmÃ¤Ãig weiÃ
  \texttt{\textquotesingle{}w\textquotesingle{}} als Gegenspieler
  zurÃ¼ckgegeben.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{opponent}\PY{p}{(}\PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{p} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}} \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{getPlayerAt} gibt den Spieler an der gegeben
Koordinate des Spielbrettes zurÃ¼ck. Die Funktion hat zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{coord} ist eine Koordinate, die Ã¼berprÃ¼ft werden soll.
\end{itemize}

Die Funktion gibt einen Spieler zurÃ¼ck. Falls an dieser Koordinate sich
kein Spielerstein befinden sollte, wird entsprechend
\texttt{\textquotesingle{}\ \textquotesingle{}} zurÃ¼ckgegeben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{getPlayerAt}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{coord}\PY{p}{)}\PY{p}{:}
    \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)} \PY{o}{=} \PY{n}{coord}
    \PY{k}{return} \PY{n}{board}\PY{p}{[}\PY{n}{r}\PY{p}{]}\PY{p}{[}\PY{n}{c}\PY{p}{]}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{playerPhase} berechnet fÃ¼r einen gegebenen Zustand
und einen Spieler die aktuelle Phase des Spielers. Die Funktion hat zwei
Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{s} \(\in States\);
\item
  \texttt{p} \(\in Player\).
\end{itemize}

Die Funktion Ã¼berprÃ¼ft mit den beiden Hilfsfunktionen
\texttt{hasPlaceableStones} und \texttt{isAllowedToJump} die
Spielerphase und gibt diese als Ganzzahl zurÃ¼ck:

\begin{itemize}
\tightlist
\item
  \texttt{1} fÃ¼r die \emph{placing} Phase, g.d.w. der Spieler noch
  Steine auf dem Stapel hat (\texttt{hasPlaceableStones});
\item
  \texttt{2} fÃ¼r die \emph{moving} Phase, g.d.w. der Spieler nicht in
  Phase 1 oder 3 ist;
\item
  \texttt{3} fÃ¼r die \emph{flying} Phase, g.d.w. der Spieler springen
  darf (\texttt{isAllowedToJump}).
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{playerPhase}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{hasPlaceableStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{l+m+mi}{1}
    \PY{k}{elif} \PY{n}{isAllowedToJump}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{l+m+mi}{3}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{return} \PY{l+m+mi}{2}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktionen-fuxfcr-zellen}{%
\subsection{Hilfsfunktionen fÃ¼r
Zellen}\label{hilfsfunktionen-fuxfcr-zellen}}

In diesem Kapitel werden Hilfsfunktionen fÃ¼r die VerÃ¤nderung oder
Untersuchung von Zelleneigenschaften implementiert.

    Die Funktion \texttt{findCellsOf} sucht auf einem Spielbrett
\texttt{board} nach allen Zellen, welche durch Steine des Spielers
\texttt{p} belegt sind. Die Funktion hat folgende Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{p} \(\in Player\).
\end{itemize}

ZurÃ¼ckgegeben wird die Menge aller Zellen wo gilt
\texttt{board{[}r{]}{[}c{]}\ =\ p}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{findCellsOf}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{\PYZob{}}\PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)} \PY{k}{for} \PY{n}{r} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)} \PY{k}{for} \PY{n}{c} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{)} \PY{k}{if} \PY{n}{board}\PY{p}{[}\PY{n}{r}\PY{p}{]}\PY{p}{[}\PY{n}{c}\PY{p}{]} \PY{o}{==} \PY{n}{p}\PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{findEmptyCells} sucht auf dem Spielfeld
\texttt{board} nach allen leeren Zellen. Die Funkion nimmt lediglich ein
Argument:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett.
\end{itemize}

Die Funktion ruft die Funktion \texttt{findCellsOf} mit
\texttt{\textquotesingle{}\ \textquotesingle{}} als Spieler auf und gibt
das erhaltene Ergebnis zurÃ¼ck. Somit ist jeder erhaltenen Zelle kein
Spieler \texttt{\textquotesingle{}b\textquotesingle{}} oder
\texttt{\textquotesingle{}w\textquotesingle{}} zugeordnet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{findEmptyCells}\PY{p}{(}\PY{n}{board}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{findCellsOf}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{findNeighboringEmptyCells} sucht fÃ¼r eine gegebene
Zelle \texttt{coordinates} die freien Nachbarzellen. Die Funktion hat
zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{coordinates} ist ein Tupel mit den Koordinaten der
  Ausgangszelle.
\end{itemize}

Die Funktion Ã¼berprÃ¼ft, welche der angrenzenden Zellen in der Menge von
\texttt{findEmptyCells} enthalten ist und gibt diese zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{findNeighboringEmptyCells}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{coordinates}\PY{p}{)}\PY{p}{:}
    \PY{p}{(}\PY{n}{rootR}\PY{p}{,} \PY{n}{rootC}\PY{p}{)} \PY{o}{=} \PY{n}{coordinates}
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)}
        \PY{k}{for} \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)} \PY{o+ow}{in} \PY{n}{findEmptyCells}\PY{p}{(}\PY{n}{board}\PY{p}{)}
        \PY{k}{if} \PY{p}{(}\PY{n}{r} \PY{o}{==} \PY{n}{rootR} \PY{o+ow}{and} \PY{p}{(}\PY{n}{c} \PY{o}{==} \PY{p}{(}\PY{n}{rootC} \PY{o}{+} \PY{l+m+mi}{7}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{l+m+mi}{8} \PY{o+ow}{or} \PY{n}{c} \PY{o}{==} \PY{p}{(}\PY{n}{rootC} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)} \PY{o}{\PYZpc{}} \PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
        \PY{o+ow}{or} \PY{p}{(}\PY{n}{c} \PY{o}{\PYZpc{}} \PY{l+m+mi}{2} \PY{o}{==} \PY{l+m+mi}{1} \PY{o+ow}{and} \PY{n}{c} \PY{o}{==} \PY{n}{rootC} \PY{o+ow}{and} \PY{p}{(}\PY{n}{r} \PY{o}{==} \PY{n}{rootR} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1} \PY{o+ow}{or} \PY{n}{r} \PY{o}{==} \PY{n}{rootR} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{place} platziert den Stein eines Spielers
\texttt{player} auf dem Spielbrett \texttt{board}. Folgende Argumente
benÃ¶tigt die Funktion:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{coordinates} ist ein Tupel mit den Koordinaten des zu
  platzierenden Steins;
\item
  \texttt{player} \(\in Player\).
\end{itemize}

Die Funktion platziert den Stein an den angegebenen Koordinaten und gibt
das neue Spielbrett zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{place}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{coordinates}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{:}
    \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)} \PY{o}{=} \PY{n}{coordinates}
    \PY{k}{return} \PY{n+nb}{tuple}\PY{p}{(}
        \PY{n+nb}{tuple}\PY{p}{(}
            \PY{n}{player} \PY{k}{if} \PY{p}{(}\PY{n}{c} \PY{o}{==} \PY{n}{ic}\PY{p}{)} \PY{o+ow}{and} \PY{p}{(}\PY{n}{r} \PY{o}{==} \PY{n}{ir}\PY{p}{)} \PY{k}{else} \PY{n}{board}\PY{p}{[}\PY{n}{ir}\PY{p}{]}\PY{p}{[}\PY{n}{ic}\PY{p}{]}
            \PY{k}{for} \PY{n}{ic} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{)}
        \PY{p}{)} \PY{k}{for} \PY{n}{ir} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
    \PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{move} bewegt einen bereits plazierten Stein auf dem
Spielbrett \texttt{board}. Die Funktion erhÃ¤lt drei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{src} ist ein Tupel mit den Koordinaten der Ausgangszelle;
\item
  \texttt{des} ist ein Tupel mit den Koordinaten der Zielzelle.
\end{itemize}

Die Funktion platziert den Wert der Ausgangszelle in die Zielzelle,
entfernt den Stein aus der Ausgangszelle und gibt das neue Spielbrett
zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{move}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{src}\PY{p}{,} \PY{n}{des}\PY{p}{)}\PY{p}{:}
    \PY{n}{src\PYZus{}r}\PY{p}{,} \PY{n}{src\PYZus{}c} \PY{o}{=} \PY{n}{src}
    \PY{n}{des\PYZus{}r}\PY{p}{,} \PY{n}{des\PYZus{}c} \PY{o}{=} \PY{n}{des}
    \PY{n}{content\PYZus{}src} \PY{o}{=} \PY{n}{board}\PY{p}{[}\PY{n}{src\PYZus{}r}\PY{p}{]}\PY{p}{[}\PY{n}{src\PYZus{}c}\PY{p}{]}
    \PY{k}{return} \PY{n+nb}{tuple}\PY{p}{(}
        \PY{n+nb}{tuple}\PY{p}{(}
            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{p}{(}\PY{n}{r}\PY{p}{,}\PY{n}{c}\PY{p}{)} \PY{o}{==} \PY{n}{src} \PY{k}{else} \PY{p}{(}\PY{n}{content\PYZus{}src} \PY{k}{if} \PY{p}{(}\PY{n}{r}\PY{p}{,}\PY{n}{c}\PY{p}{)} \PY{o}{==} \PY{n}{des} \PY{k}{else} \PY{n}{board}\PY{p}{[}\PY{n}{r}\PY{p}{]}\PY{p}{[}\PY{n}{c}\PY{p}{]}\PY{p}{)}
            \PY{k}{for} \PY{n}{c} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{)}
        \PY{p}{)} \PY{k}{for} \PY{n}{r} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
    \PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktionen-fuxfcr-muxfchlen}{%
\subsection{Hilfsfunktionen fÃ¼r
MÃ¼hlen}\label{hilfsfunktionen-fuxfcr-muxfchlen}}

In diesem Kapitel werden Hilfsfunktionen implementiert, die fÃ¼r MÃ¼hlen
nÃ¼tzlich sind.

    Die Konstante \texttt{MILL\_COORDINATES} beinhaltet alle MÃ¼hlen und
deren Koordinaten, die auf dem Spielfeld mÃ¶glich sind.

\begin{itemize}
\tightlist
\item
  ZunÃ¤chst werden alle MÃ¼hlen entlang der Ringe ermittelt. Dazu werden,
  beginnend an jeder Ecke, die nÃ¤chsten drei Koordinaten in einer Menge
  (bzw. \texttt{frozenset}) gespeichert.
\item
  FÃ¼r die MÃ¼hlen entlang der Verbindungslinien zwischen den Ringen, wird
  das gleiche Prinzip verwendet. Hier werden alle Koordinaten in der
  Mitte einer Seite gespeichert.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{MILL\PYZus{}COORDINATES} \PY{o}{=} \PY{p}{\PYZob{}}
    \PY{c+c1}{\PYZsh{} Calculate all mills on the rings}
    \PY{n+nb}{frozenset}\PY{p}{(}
        \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{p}{(}\PY{n}{c}\PY{o}{+}\PY{n}{o}\PY{p}{)}\PY{o}{\PYZpc{}}\PY{k}{8})
        \PY{k}{for} \PY{n}{o} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
    \PY{p}{)}
    \PY{k}{for} \PY{n}{r} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
    \PY{k}{for} \PY{n}{c} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
\PY{p}{\PYZcb{}} \PY{o}{|} \PY{p}{\PYZob{}}
    \PY{c+c1}{\PYZsh{} Calculate all mills crossing the rings}
    \PY{n+nb}{frozenset}\PY{p}{(}
        \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)}
        \PY{k}{for} \PY{n}{r} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
    \PY{p}{)}
    \PY{k}{for} \PY{n}{c} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{8}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
\PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{findMills} berechnet fÃ¼r ein Spielbrett und einen
Spieler alle MÃ¼hlen, die dieser Spieler aktuell hat. Die Funktion hat
zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{p} \(\in Players\).
\end{itemize}

Der RÃ¼ckgabewert der Funktion ist eine Menge von MÃ¼hlen. Eine MÃ¼hle wird
dabei als Menge (bzw. \texttt{frozenset}) dargestellt, die die
Koordinaten der Steine als Tupel beinhaltet.

Zum Berechnen aller MÃ¼hlen, die ein Spieler aktuell hat, wird Ã¼ber die
zuvor berechneten konstanten Menge \texttt{MILL\_COORDINATES} iteriert
und fÃ¼r jede MÃ¼hlenposition Ã¼berprÃ¼ft, ob dort der Spieler einen Stein
hat.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{findMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{n}{mill}
        \PY{k}{for} \PY{n}{mill} \PY{o+ow}{in} \PY{n}{MILL\PYZus{}COORDINATES}
        \PY{k}{if} \PY{n+nb}{all}\PY{p}{(}
            \PY{n}{board}\PY{p}{[}\PY{n}{r}\PY{p}{]}\PY{p}{[}\PY{n}{c}\PY{p}{]} \PY{o}{==} \PY{n}{p}
            \PY{k}{for} \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)} \PY{o+ow}{in} \PY{n}{mill}
        \PY{p}{)}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{findPossibleMills} berechnet fÃ¼r ein Spielbrett und
einen Spieler alle mÃ¶glichen MÃ¼hlen. Eine mÃ¶gliche MÃ¼hle ist eine MÃ¼hle,
bei der eine Zelle noch leer ist, hierbei wird nicht betrachtet, ob es
im nÃ¤chsten Zug mÃ¶glich ist, diese MÃ¼hle zu vervollstÃ¤ndigen. Dabei wird
Die Funktion hat zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{p} \(\in Players\).
\end{itemize}

Der RÃ¼ckgabewert der Funktion ist eine Menge von mÃ¶glichen MÃ¼hlen. Eine
mÃ¶gliche MÃ¼hle wird dabei als Menge (bzw. \texttt{frozenset})
dargestellt, die alle Koordinaten der MÃ¼hle als Tupel beinhaltet.

Zum Berechnen aller mÃ¶glichen MÃ¼hlen, die ein Spieler aktuell hat, wird
Ã¼ber die zuvor berechnete Menge \texttt{MILL\_COORDINATES} iteriert und
fÃ¼r jede MÃ¼hle Ã¼berprÃ¼ft, ob der Spieler dort zwei Steine hat und eine
Zelle leer ist.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{findPossibleMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{n}{mill}
        \PY{k}{for} \PY{n}{mill} \PY{o+ow}{in} \PY{n}{MILL\PYZus{}COORDINATES}
        \PY{k}{if} \PY{n+nb}{sorted}\PY{p}{(}\PY{n}{board}\PY{p}{[}\PY{n}{r}\PY{p}{]}\PY{p}{[}\PY{n}{c}\PY{p}{]} \PY{k}{for} \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)} \PY{o+ow}{in} \PY{n}{mill}\PY{p}{)} \PY{o}{==} \PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{p}\PY{p}{,} \PY{n}{p}\PY{p}{]}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{countNewMills} berechnet fÃ¼r ein Spielbrett, eine
Menge bereits existierender MÃ¼hlen und einen Spieler die Anzahl der
MÃ¼hlen, die neu entstanden sind. Die Funktion hat 3 Parameter:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{oldMills} ist eine Menge von MÃ¼hlen (Menge von Koordinaten);
\item
  \texttt{p} \(\in Players\).
\end{itemize}

Der RÃ¼ckgabewert dieser Funktion ist eine Ganzzahl fÃ¼r die gilt
\(return \in \{0,1,2\}\). Indem die Menge der bereits existierenden
MÃ¼hlen von der Menge der aktuellen MÃ¼hlen abgezogen wird, erhÃ¤lt man die
Menge der aktuellen MÃ¼hlen. Von diesen kann die Anzahl berechnet werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{countNewMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{oldMills}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n+nb}{len}\PY{p}{(}\PY{n}{findMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)} \PY{o}{\PYZhy{}} \PY{n}{oldMills}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{getCellsPoundable} berechnet fÃ¼r ein Spielbrett und
einen Spieler, welche Steine des Gegeners dieser schlagen darf. Ein
Stein darf geschlagen werden, wenn er sich nicht in einer MÃ¼hle
befindet. Wenn sich alle Steine in einer MÃ¼hle befinden, dÃ¼rfen alle
Steine geschlagen werden. Die Funktion hat 2 Parameter:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{p} \(\in Players\).
\end{itemize}

Der RÃ¼ckgabewert ist eine Menge von Koordinaten. Die Menge aller
Koordinaten der Steine des Gegeners, sowie die Menge aller Koordinaten
aller Steine aus den MÃ¼hlen des Gegeners werden errechnet und
voneinander abgezogen. Falls diese Menge nicht leer ist, dÃ¼rfen nur an
diesen Positionen Steine geschlagen werden, ansonsten dÃ¼rfen alle Steine
des Gegners geschlagen werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{getCellsPoundable}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{n}{opponentCells} \PY{o}{=} \PY{n}{findCellsOf}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{opponent}\PY{p}{(}\PY{n}{p}\PY{p}{)}\PY{p}{)}
    
    \PY{n}{opponentCellsInMills} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{cell}
        \PY{k}{for} \PY{n}{mill} \PY{o+ow}{in} \PY{n}{findMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{opponent}\PY{p}{(}\PY{n}{p}\PY{p}{)}\PY{p}{)}
        \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n}{mill}
    \PY{p}{\PYZcb{}}
    
    \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{opponentCells} \PY{o}{\PYZhy{}} \PY{n}{opponentCellsInMills}\PY{p}{)} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{k}{return} \PY{n}{opponentCells} \PY{o}{\PYZhy{}} \PY{n}{opponentCellsInMills}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{return} \PY{n}{opponentCells}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{poundMills} errechnet aus einem Spielbrett, einer
Anzahl an zu schlagenden Steinen und einem Spieler alle mÃ¶glichen
Spielbrettkonfigurationen, bei denen der Spieler die gegebene Anzahl an
Steinen geschlagen hat. Die Funktion hat 3 Parameter:

\begin{itemize}
\tightlist
\item
  \texttt{board} ist ein Spielbrett;
\item
  \texttt{count} \(\in \{0, 1, 2\}\);
\item
  \texttt{p} \(\in Players\).
\end{itemize}

Der RÃ¼ckgabewert ist eine Menge an Spielbrettern. Die Funktion ist
rekursiv implementiert. Wenn kein Stein mehr geschlagen werden muss,
wird eine Menge mit dem aktuellen Spielbrett zurÃ¼ck gegeben. Ansonsten
wird rekursiv die Menge aller mÃ¶glichen Spielbrettkonfigurationen mit
einem zu schlagenden Stein weniger errechnet. Aus allen diesen
Spielbrettern wird ein weiterer Stein entfernt, der geschlagen werden
darf.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{poundMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{count}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{count} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{k}{return} \PY{p}{\PYZob{}} \PY{n}{board} \PY{p}{\PYZcb{}}

    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{n}{place}\PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{cell}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{for} \PY{n}{b} \PY{o+ow}{in} \PY{n}{poundMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{count}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{p}\PY{p}{)}
        \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n}{getCellsPoundable}\PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{p}\PY{p}{)}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
 
    
    
    

    
    \hypertarget{spiel-definition}{%
\section{Spiel Definition}\label{spiel-definition}}

In diesem Kapitel werden Funktionen diskutiert, die nÃ¶tig sind, um das
Spiel MÃ¼hle

\[G_{Nine Men's Morris} = ãStates,s_0,Players,nextStates,finished,utilityã\]

zu definieren. Es werden die
\href{http://www.muehlespiel.eu/images/pdf/WMD_Turnierreglement.pdf}{offizellen
Tunierregeln} in der Version \texttt{3.0} vom 11. Mai 2019 des
WeltmÃ¼hlespiel Dachverbandes verwendet. Jedoch werden die Regeln fÃ¼r
Unentschieden ausgelassen, da diese die ZustÃ¤nde zu groÃ machen wÃ¼rden.
Eine Implementierung dieser Regeln ist im Kapitel Ã¼ber die GUI zu
finden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Mit Hilfe des Magic Command \texttt{\%run} werden Hilfsmethoden geladen,
die in einem eigenen Kapitel beschrieben werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}game\PYZhy{}utils.ipynb
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{spieler}{%
\subsection{Spieler}\label{spieler}}

ZunÃ¤chst soll die Menge der Spieler definiert werden. Da MÃ¼hle mit zwei
Spielern gespielt wird, die jeweils weiÃe oder schwarze Steine legen,
werden die Spieler Ã¤quivalent benannt.

\begin{itemize}
    \item Der beginnende Spieler weiÃ wird als \texttt{w} dargestellt,
    \item der gegnerische Spieler als \texttt{b}.
\end{itemize}

FÃ¼r die Implementierung der Funktionen ist diese Menge nicht nÃ¶tig. Aus
GrÃ¼nden der VollstÃ¤ndigkeit soll diese hier dennoch definiert werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Player} \PY{o}{=} \PY{p}{\PYZob{}}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{zustuxe4nde}{%
\subsection{ZustÃ¤nde}\label{zustuxe4nde}}

Die vollstÃ¤ndige Menge aller ZustÃ¤nde ist aufwendig zu berechnen und
wird ebenfalls nicht fÃ¼r die Implementierung benÃ¶tigt. Da die ZustÃ¤nde
berechnet werden, sobald diese benÃ¶tigt werden. Deswegen wird hier auf
eine Definition von \(States\) verzichtet.

Der Startzustand \(s_0\) hingegen wird zu Beginn des Spiel benÃ¶tigt und
ist im Folgenden definiert. Er bezeichnet ein leeres Spielbrett, bei dem
beide Spieler noch alle ihre Steine legen mÃ¼ssen. Ein Zustand
(\texttt{state}) ist eine Tupel die 1. den Stapel (\texttt{stash}) von
zu legenden Steinen und 2. das Spielbrett (\texttt{board}) selbst
beinhaltet.

Der Stapel ist eine Tupel \(\langle w, b \rangle\), die die Anzahl der
zu legenden Steine von WeiÃ \(w\) und Schwarz \(b\) beinhaltet. Diese
werden in der genannten Reihenfolge als Zahlen dargestellt.
\[w, b \in \{0...9\}\]

Das Spielbrett wird durch eine Tripel beschrieben, die die Ringe des
Spielbretts beinhaltet. Alle zusammengehÃ¶rigen Spielbrettpositionen, die
sich auf dem gleichen Ring befinden, sind in der folgenden Abbildung
durch eine Farbe markiert. Der Ã¤uÃere Ring ist \(rot\), der mittlere
\(grÃ¼n\) und der innere \(blau\) dargestellt, damit gilt fÃ¼r einen Index
\(r\) der einen der Ringe bezeichnet \(r \in \{0...2\}\).

\includegraphics{../images/nmm-rings.png}

Die Spielpositionen (\texttt{cells}) \(c\) auf den Ringen sind beginnend
mit \(c=0\) ab der oberen linken Ecke im Uhrzeigersinn durch nummeriert.
Dadurch ergibt sich, dass \(c \in \{0...7\}\). In der Abbilung sind die
Koordinaten der Spielpositionen eingezeichnet, so liegt beispielsweise
\(\langle r,c \rangle = \langle 2,4 \rangle\) auf dem inneren Ring in
der unteren rechten Ecke. An diesen Spielpositionen wird der Spieler
\(p\) oder eine leere Spielposition gespeichert, fÃ¼r diese gilt
\(p \in Player \cup \{'\ '\}\).

So ist ein State eine Tupel \(\langle stash, board \rangle\) dessen
Parameter 

\begin{itemize}
    \item \texttt{stash} eine weitere Tupel, bestehend aus \(\langle w, b \rangle\) und
    \item \texttt{board} eine Tripel, welche die
    Ringe \(r_0\), \(r_1\) und \(r_2\) beinhaltet. Die Ringe selbst sind
    Neun-Tupel, dessen Elemente die einzelnen Spielpositionen
    \(c \in Player \cup \{'\ '\}\) darstellen.
\end{itemize}

Der Startzustand \(s_0\) wird in Python wie folgt geschrieben:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{s0} \PY{o}{=} \PY{p}{(}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{,} \PY{l+m+mi}{9}\PY{p}{)}\PY{p}{,} \PY{p}{(}
    \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,}
    \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{,}
    \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{folgezustuxe4nde}{%
\subsection{FolgezustÃ¤nde}\label{folgezustuxe4nde}}

FÃ¼r die Definition des Spieles MÃ¼hle \(G_{Nine Men's Morris}\) wird die
Funktion \texttt{nextStates} benÃ¶tigt. Diese nimmt einen Zustand
\texttt{s} und einen Spieler \texttt{p} entgegen und errechnet mit
diesen alle FolgezustÃ¤nde, die entstehen, wenn der gegebene Spieler
einen legalen Zug spielt.

Da das Spiel in drei Phasen aufgeteilt ist, ist auch die Implementierung
aus GrÃ¼nden der Ãbersicht in die folgenden Phasen unterteilt:

\begin{enumerate}
    \item Die
    erste Phase des Spiels heiÃt \emph{placing} Phase, in der die Spieler
    alle ihre Steine aus dem Stapel auf das Spielbrett legen mÃ¼ssen. Hierbei
    dÃ¼rfen bereits MÃ¼hlen gelegt und geschlagen werden. Es muss ein Stein
    platziert werden.
    \item Die zweite Phase heiÃt \emph{moving} Phase und
    beginnt sobald der Stapel des Spielers leer ist. Beide Spieler kommen
    gleichzeitig in die zweite Phase, in der die eigenen Steine nur noch
    entlang der Linien auf die nÃ¤chste Spielposition geschoben werden
    dÃ¼rfen. Es muss ein Stein bewegt werden.
    \item Die letzte Phase heiÃt
    \emph{flying} Phase. Diese Phase beginnt fÃ¼r einen Spieler, sobald
    dieser nur noch \(3\) Steine auf dem Spielbrett liegen hat und sein
    Stapel leer ist. Der Eintritt in die dritte Phase ist nicht vom
    gegnerischen Spieler abhÃ¤ngig, somit kÃ¶nnen Spieler fÃ¼r mehrere ZÃ¼ge
    alleine in der dritten Phase sein. Hierbei kÃ¶nnen die verbleibenden
    Steine beliebig bewegt werden, ohne dass die Positionen direkt
    nebeneinander liegen mÃ¼ssen. Es muss ein Stein bewegt werden.
\end{enumerate}

In der ersten Phase, der \emph{placing} Phase, wird ein Stein vom Stapel
genommen und auf ein freies Feld gelegt. Diese ZÃ¼ge werden in der
Funktion \texttt{nextStatesPlace} implementiert, hierbei wird ein
Spieler \texttt{p} und ein Zustand \texttt{s} erwartet, fÃ¼r den
angenommen wird, dass sich der aktuelle Zustand in der ersten Phase
befindet. Die RÃ¼ckgabe dieser Funktion ist die Menge aller ZustÃ¤nde, die
erreicht werden kÃ¶nnen, in denen der Spieler \texttt{p} einen legalen
Spielzug auf dem Zustand \texttt{s} ausfÃ¼hrt.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  ZunÃ¤chst werden die MÃ¼hlen aus dem aktuellen Zustand mit Hilfe der
  Funktion \texttt{findMills} gespeichert.
\item
  Daraufhin wird auf jede freie Spielposition ein neuer Stein des
  Spielers \texttt{p} gelegt.
\item
  Nun werden unter Verwendung von dem Ergebnis aus \emph{1.} und der
  Funktion \texttt{countNewMills} alle neu entstandenen MÃ¼hlen gezÃ¤hlt.
  FÃ¼r diese Anzahl gilt \(a \in \{0,1,2\}\).
\item
  Um fÃ¼r die neu entstandenen MÃ¼hlen die entsprechende Anzahl an Steinen
  zu schlagen, wird die Hilfsfunktion \texttt{poundMills} verwendet.
\item
  Zum Schluss wird vom Stapel des Spielers \texttt{p} ein Stein weg
  genommen und der Stapel mit den Spielbrettern wieder zu ZustÃ¤nden
  vereint.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{nextStatesPlace}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Extract the count of the stones and the board}
    \PY{p}{(}\PY{p}{(}\PY{n}{cw}\PY{p}{,} \PY{n}{cb}\PY{p}{)}\PY{p}{,} \PY{n}{board}\PY{p}{)} \PY{o}{=} \PY{n}{s}
    \PY{c+c1}{\PYZsh{} Calculate all current mills the player has}
    \PY{n}{mills} \PY{o}{=} \PY{n}{findMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Place a stone in any empty cell}
    \PY{n}{placeBoards} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{place}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)}\PY{p}{,} \PY{n}{p}\PY{p}{)}
        \PY{k}{for} \PY{p}{(}\PY{n}{r}\PY{p}{,} \PY{n}{c}\PY{p}{)} \PY{o+ow}{in} \PY{n}{findEmptyCells}\PY{p}{(}\PY{n}{board}\PY{p}{)}
    \PY{p}{\PYZcb{}}
    \PY{c+c1}{\PYZsh{} Calculate how many new mills were created}
    \PY{n}{boardMills} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{board}\PY{p}{:} \PY{n}{countNewMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{mills}\PY{p}{,} \PY{n}{p}\PY{p}{)}
        \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{placeBoards}
    \PY{p}{\PYZcb{}}

    \PY{c+c1}{\PYZsh{} Here all final boards will be collected}
    \PY{n}{boards} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{result}
        \PY{k}{for} \PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{count}\PY{p}{)} \PY{o+ow}{in} \PY{n}{boardMills}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)} 
        \PY{k}{for} \PY{n}{result} \PY{o+ow}{in} \PY{n}{poundMills}\PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{count}\PY{p}{,} \PY{n}{p}\PY{p}{)}
    \PY{p}{\PYZcb{}}

    \PY{c+c1}{\PYZsh{} Remove one stone from the players stache}
    \PY{p}{(}\PY{n}{cw}\PY{p}{,} \PY{n}{cb}\PY{p}{)} \PY{o}{=} \PY{p}{(}\PY{n}{cw}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{cb}\PY{p}{)} \PY{k}{if} \PY{n}{p} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}} \PY{k}{else} \PY{p}{(}\PY{n}{cw}\PY{p}{,} \PY{n}{cb}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Return all possible states}
    \PY{k}{return} \PY{p}{\PYZob{}} \PY{p}{(}\PY{p}{(}\PY{n}{cw}\PY{p}{,} \PY{n}{cb}\PY{p}{)}\PY{p}{,} \PY{n}{board}\PY{p}{)} \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards} \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    In der \emph{moving} Phase (2) wird ein Stein des aktuellen Spielers
entlang der Linien zu einer benachbarten, leeren Spielposition
geschoben. Die Definition der Funktion \texttt{nextStatesMove} wird
wieder eine Zustand \texttt{s} und ein Spieler \texttt{p} erwartet, die
sich in der zweiten Phase befinden. Die RÃ¼ckgabe dieser Funktion ist die
Menge aller ZustÃ¤nde, die erreicht werden kÃ¶nnen, in denen der Spieler
\texttt{p} einen legalen Spielzug auf dem Zustand \texttt{s} ausfÃ¼hrt.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  ZunÃ¤chst werden die MÃ¼hlen aus dem aktuellen Zustand mit Hilfe der
  Funktion \texttt{findMills} gespeichert.
\item
  Danach werden die Positionen aller Steine des Spielers \texttt{p} und
  dessen leere Nachbarpositionen mit Hilfe der Funktionen
  \texttt{findCellsOf} und \texttt{findNeighboringEmptyCells} errechnet.
  Die Steine werden dort hin bewegt.
\item
  Nun werden unter Verwendung von dem Ergebnis aus \emph{1.} und der
  Funktion \texttt{countNewMills} alle neu entstandenen MÃ¼hlen gezÃ¤hlt.
  FÃ¼r diese Anzahl gilt \(a \in \{0,1\}\).
\item
  Um fÃ¼r die neu entstandenen MÃ¼hlen die entsprechende Anzahl an Steinen
  zu schlagen, wird die Hilfsfunktion \texttt{poundMills} verwendet.
\item
  Zum Schluss wird der Stapel mit den Spielbrettern wieder zu ZustÃ¤nden
  vereint.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{nextStatesMove}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Extract the count of the stones and the board}
    \PY{p}{(}\PY{p}{(}\PY{n}{cw}\PY{p}{,} \PY{n}{cb}\PY{p}{)}\PY{p}{,} \PY{n}{board}\PY{p}{)} \PY{o}{=} \PY{n}{s}
    \PY{c+c1}{\PYZsh{} Calculate all current mills the player has}
    \PY{n}{mills} \PY{o}{=} \PY{n}{findMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Choose any stone of the player and move it to an empty neighbor}
    \PY{n}{moveBoards} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{move}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{src}\PY{p}{,} \PY{n}{des}\PY{p}{)}
        \PY{k}{for} \PY{n}{src} \PY{o+ow}{in} \PY{n}{findCellsOf}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)}
        \PY{k}{for} \PY{n}{des} \PY{o+ow}{in} \PY{n}{findNeighboringEmptyCells}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{src}\PY{p}{)}
    \PY{p}{\PYZcb{}}

    \PY{c+c1}{\PYZsh{} Calculate how many new mills were created}
    \PY{n}{boardMills} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{b}\PY{p}{:} \PY{n}{countNewMills}\PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{mills}\PY{p}{,} \PY{n}{p}\PY{p}{)}
        \PY{k}{for} \PY{n}{b} \PY{o+ow}{in} \PY{n}{moveBoards}
    \PY{p}{\PYZcb{}}

    \PY{c+c1}{\PYZsh{} Here all final boards will be collected}
    \PY{n}{boards} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{result}
        \PY{k}{for} \PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{count}\PY{p}{)} \PY{o+ow}{in} \PY{n}{boardMills}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)} 
        \PY{k}{for} \PY{n}{result} \PY{o+ow}{in} \PY{n}{poundMills}\PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{count}\PY{p}{,} \PY{n}{p}\PY{p}{)}
    \PY{p}{\PYZcb{}}

    \PY{k}{return} \PY{p}{\PYZob{}} \PY{p}{(}\PY{p}{(}\PY{n}{cw}\PY{p}{,} \PY{n}{cb}\PY{p}{)}\PY{p}{,} \PY{n}{board}\PY{p}{)} \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards} \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    Die letzte Hilfsfunktion \texttt{nextStatesFly} wird in der Phase 3
verwendet und erwartet Ã¤quivalent zu den anderen Hilfsmethoden einen
Zustand \texttt{s} und Spieler \texttt{p} in der Phase 3. Hier wird ein
Stein des Spieler \texttt{p} an eine andere Position auf dem Spielbrett
bewegt. Diese Position muss keine Nachbarposition sein und Steine kÃ¶nnen
Ã¼bersprungen werden. Die RÃ¼ckgabe dieser Funktion ist die Menge aller
ZustÃ¤nde, die erreicht werden kÃ¶nnen, in denen der Spieler \texttt{p}
einen legalen Spielzug auf dem Zustand \texttt{s} ausfÃ¼hrt.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  ZunÃ¤chst werden die MÃ¼hlen aus dem aktuellen Zustand mit Hilfe der
  Funktion \texttt{findMills} gespeichert.
\item
  Danach werden die Positionen aller Steine des Spielers \texttt{p} und
  dessen leere Nachbarpositionen mit Hilfe der Funktionen
  \texttt{findCellsOf} und \texttt{findNeighboringEmptyCells} errechnet.
  Die Steine werden dort hin bewegt.
\item
  Nun werden unter Verwendung von dem Ergebnis aus \emph{1.} und der
  Funktion \texttt{countNewMills} alle neu entstandenen MÃ¼hlen gezÃ¤hlt.
  FÃ¼r diese Anzahl gilt \(a \in \{0,1\}\).
\item
  Um fÃ¼r die neu entstandenen MÃ¼hlen die entsprechende Anzahl an Steinen
  zu schlagen, wird die Hilfsfunktion \texttt{poundMills} verwendet.
\item
  Zum Schluss wird der Stapel mit den Spielbrettern wieder zu ZustÃ¤nden
  vereint.
\end{enumerate}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{nextStatesFly}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Extract the count of the stones and the board}
    \PY{p}{(}\PY{p}{(}\PY{n}{cw}\PY{p}{,} \PY{n}{cb}\PY{p}{)}\PY{p}{,} \PY{n}{board}\PY{p}{)} \PY{o}{=} \PY{n}{s}
    \PY{c+c1}{\PYZsh{} Calculate all current mills the player has}
    \PY{n}{mills} \PY{o}{=} \PY{n}{findMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Choose any stone of the player and move it to an empty neighbor}
    \PY{n}{moveBoards} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{move}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{src}\PY{p}{,} \PY{n}{des}\PY{p}{)}
        \PY{k}{for} \PY{n}{src} \PY{o+ow}{in} \PY{n}{findCellsOf}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{n}{p}\PY{p}{)}
        \PY{k}{for} \PY{n}{des} \PY{o+ow}{in} \PY{n}{findEmptyCells}\PY{p}{(}\PY{n}{board}\PY{p}{)}
    \PY{p}{\PYZcb{}}

    \PY{c+c1}{\PYZsh{} Calculate how many new mills were created}
    \PY{n}{boardMills} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{b}\PY{p}{:} \PY{n}{countNewMills}\PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{mills}\PY{p}{,} \PY{n}{p}\PY{p}{)}
        \PY{k}{for} \PY{n}{b} \PY{o+ow}{in} \PY{n}{moveBoards}
    \PY{p}{\PYZcb{}}

    \PY{c+c1}{\PYZsh{} Here all final boards will be collected}
    \PY{n}{boards} \PY{o}{=} \PY{p}{\PYZob{}}
        \PY{n}{result}
        \PY{k}{for} \PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{count}\PY{p}{)} \PY{o+ow}{in} \PY{n}{boardMills}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)} 
        \PY{k}{for} \PY{n}{result} \PY{o+ow}{in} \PY{n}{poundMills}\PY{p}{(}\PY{n}{b}\PY{p}{,} \PY{n}{count}\PY{p}{,} \PY{n}{p}\PY{p}{)}
    \PY{p}{\PYZcb{}}

    \PY{k}{return} \PY{p}{\PYZob{}} \PY{p}{(}\PY{p}{(}\PY{n}{cw}\PY{p}{,} \PY{n}{cb}\PY{p}{)}\PY{p}{,} \PY{n}{board}\PY{p}{)} \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards} \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    Die Implementierung der \texttt{nextStates} Funktion fÃ¼hrt nun die
vorher definierten Funktionen zusammen. Die aktuelle Phase fÃ¼r den
gegebenen Zustand \texttt{s} und Spieler \texttt{p} wird mit der
Hilfsfunktion \texttt{playerPhase} errechnet und auf Grund dessen eine
Fallunterscheidung ausgefÃ¼hrt, sodass gilt

\[
nextStates(s, p) = \begin{cases}
nextStatesPlace(s, p) & falls\ \  playerPhase(s, p) = 1 \\
nextStatesMove(s, p) & falls\ \  playerPhase(s, p) = 2 \\
nextStatesFly(s, p) & falls\ \  playerPhase(s, p) = 3
\end{cases}
\]

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{nextStates}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
    \PY{n}{phase} \PY{o}{=} \PY{n}{playerPhase}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}
    \PY{k}{if} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{1}\PY{p}{:}
        \PY{k}{return} \PY{n}{nextStatesPlace}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}
    \PY{k}{elif} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{2}\PY{p}{:}
        \PY{k}{return} \PY{n}{nextStatesMove}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{k}{return} \PY{n}{nextStatesFly}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{spielende}{%
\subsection{Spielende}\label{spielende}}

    FÃ¼r die Definition des Spieles MÃ¼hle \(G_{Nine Men's Morris}\) werden
zwei weitere Funktionen benÃ¶tigt, die das Ende des Spiels behandeln:
\texttt{finished} und \texttt{utility}.

Die Funktion \texttt{finished} errechnet fÃ¼r einen gegebenen Zustand
\texttt{s}, ob das Spiel beendet ist, wenn Spieler \texttt{p} an der
Reihe ist. Dies ist der Fall, g.d.w.

\begin{itemize}
    \item einer der Spieler
    \(p \in Players\) weniger als 3 Steine hat (\texttt{hasEnoughStones})
    oder
    \item der Spieler \texttt{p} keinen legalen Zug mehr tÃ¤tigen kann.
\end{itemize}

Der optionale Parameter \texttt{ns} ist lediglich eine Optimierung, die
es ermÃ¶glicht, bereits berechnete FolgezustÃ¤nde zu verwenden, anstatt
diese noch einmal errechnen lassen zu mÃ¼ssen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{finished}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{,} \PY{n}{ns}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{ns}\PY{p}{:}
        \PY{n}{ns} \PY{o}{=} \PY{n}{nextStates}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{;}
    \PY{k}{return} \PY{o+ow}{not} \PY{n}{hasEnoughStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o+ow}{or} \PYZbs{}
           \PY{o+ow}{not} \PY{n}{hasEnoughStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} \PY{o+ow}{or} \PYZbs{}
           \PY{n+nb}{len}\PY{p}{(}\PY{n}{ns}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{0}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{utility} errechnet fÃ¼r den gegebenen Zustand
\texttt{s} und Spieler \texttt{p}, falls \(finished(s, p) = true\) gilt,
wer gewonnen hat.

\[
utility(s, p) = \begin{cases}
-1 & falls\ \  p \ verliert \ in \ s \\
 0 & falls\ \  Unentschieden         \\
 1 & falls\ \  p \ gewinnt  \ in \ s
\end{cases}
\]

Sobald ein Spieler zu wenig Steine hat (\texttt{hasEnoughStones}) oder
keinen legalen Zug mehr tÃ¤tigen kann, hat dieser verloren. Dadurch
gewinnt automatisch der gegnerische Spieler. Zwar gibt es im Spiel MÃ¼hle
ein Unentschieden, dies kann aber nicht anhand der ZustÃ¤nde erkannt
werden, da hierbei die vorher gespielten SpielzÃ¼ge betrachtet werden
mÃ¼ssen.

Ãquivalent zu der Funktion \texttt{finished} ist Parameter \texttt{ns}
optional und stellt lediglich eine Optimierung dar, die es ermÃ¶glicht,
bereits berechnete FolgezustÃ¤nde zu verwenden, anstatt diese noch einmal
errechnen lassen zu mÃ¼ssen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{utility}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{,} \PY{n}{ns}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{ns}\PY{p}{:}
        \PY{n}{ns} \PY{o}{=} \PY{n}{nextStates}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{;}
     
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{hasEnoughStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}
    \PY{k}{if} \PY{o+ow}{not} \PY{n}{hasEnoughStones}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{opponent}\PY{p}{(}\PY{n}{p}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{l+m+mi}{1}
    \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n}{nextStates}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{p}\PY{p}{)}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{k}{return} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}

    \PY{c+c1}{\PYZsh{} Should be impossible, as utility() will only be called if finished() returns True}
    \PY{k}{return} \PY{l+m+mi}{0}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
    
    
    

    
    \hypertarget{kuxfcnstliche-intelligenz}{%
\section{KÃ¼nstliche Intelligenz}\label{kuxfcnstliche-intelligenz}}

Diese Studienarbeit implementiert zwei verschiedene Algorithmen als
kÃ¼nstliche Intelligenz: Minimax und $\alpha$-$\beta$-Pruning. Damit diese Algorithmen
leichter wiederverwendet und mit verschiedenen Einstellungen ausgefÃ¼hrt
werden kÃ¶nnen, wird eine abstrakte Superklasse angelegt. Diese bescheibt
welche Funktionen nÃ¶tig sind, damit eine Implementierung den AnsprÃ¼chen
einer kÃ¼nstlichen Intelligenz fÃ¼r MÃ¼hle entspricht.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{bestmoves}{%
\subsection{BestMoves}\label{bestmoves}}

    Die Klasse \texttt{BestMoves} beschreibt das Ergebnis, welches eine
kÃ¼nstliche Intelligenz fÃ¼r MÃ¼hle erzeugen soll. Diese Klasse beschreibt
den RÃ¼ckgabewert der spÃ¤ter definierten Funktion \texttt{bestMoves}. Sie
hat drei Attribute:

\begin{itemize}
\tightlist
\item
  \texttt{states} \(\subset States\);
\item
  \texttt{value} \(\in \mathopen[-1.0,1.0\mathclose]\);
\item
  \texttt{debugInformation} ist ein \texttt{dict}, welches weitere
  Informationen, wie beispielsweise die erreichte Rekursionstiefe oder
  die besuchten ZustÃ¤nde, beinhalten kann.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{BestMoves}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{states}\PY{p}{,} \PY{n}{value}\PY{p}{,} \PY{n}{debugInformation}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{states} \PY{o}{=} \PY{n}{states}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{n}{value}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{debugInformation} \PY{o}{=} \PY{n}{debugInformation}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r Entwicklungszwecke wird eine Stringdarstellung fÃ¼r die Klasse
\texttt{BestMoves} implementiert. Hierzu wird durch die Funktion
\texttt{\_\_repr\_\_} ein String zurÃ¼ckgegeben, der alle Parameter der
Klasse beinhaltet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{BestMoves(states=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{states}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, value=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{value}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, debugInformation=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{debugInformation}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{BestMoves}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{choice} wÃ¤hlt zufÃ¤llig einen der mÃ¶glichen besten
ZÃ¼ge aus einer \texttt{BestMoves} Instanz aus. Dadurch wird
sichergestellt, dass nicht immer der gleiche Zug durch die kÃ¼nstliche
Intelligenz gespielt wird.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{random}
\PY{k}{def} \PY{n+nf}{choice}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{random}\PY{o}{.}\PY{n}{choice}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{states}\PY{p}{)}

\PY{n}{BestMoves}\PY{o}{.}\PY{n}{choice} \PY{o}{=} \PY{n}{choice}
\PY{k}{del} \PY{n}{choice}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{artificialintelligence}{%
\subsection{ArtificialIntelligence}\label{artificialintelligence}}

    FÃ¼r die Definition der abstrakten Superklasse mÃ¼ssen zunÃ¤chst aus dem
Paket \texttt{abc} \emph{Abstract Base Classes} Hilfsklassen und
-funktionen importiert werden. Diese werden benÃ¶tigt um eine abstrakte
Klassen in Python darstellen zu kÃ¶nnen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{abc} \PY{k+kn}{import} \PY{n}{ABC}\PY{p}{,} \PY{n}{abstractmethod}
\end{Verbatim}
\end{tcolorbox}

    Die abstrakte Superklasse \texttt{ArtificialIntelligence} ist selbst
eine Unterklasse von \texttt{ABC}, dadurch wird die Klasse als abstrakt
markiert. \texttt{ArtificialIntelligence} hat eine abstrakte Funktion
\texttt{bestMoves}, die fÃ¼r einen Zustand und einen Spieler alle besten
ZÃ¼ge errechnen soll und diese in Form einer \texttt{BestMoves} Instanz
zurÃ¼ckgeben soll. Sie hat zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{states} \(\in States\);
\item
  \texttt{player} \(\in Players\).
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{ArtificialIntelligence}\PY{p}{(}\PY{n}{ABC}\PY{p}{)}\PY{p}{:}
    \PY{n+nd}{@abstractmethod}
    \PY{k}{def} \PY{n+nf}{bestMoves}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n}{BestMoves}\PY{p}{:}
        \PY{k}{pass}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
    
    
    

    
    \hypertarget{heuristik}{%
\subsection{Heuristik}\label{heuristik}}

Da die Rechenleistung nicht ausreicht um vor jedem Zug den gesamten
Spielbaum abzusuchen, gibt es eine maximale Rekursionstiefe, bei der die
Suche abgebrochen wird. Wenn diese Rekusionstiefe erreicht wird, muss
der Wert des aktuellen Zustands geschÃ¤tzt werden. HierfÃ¼r wird die in
diesem Kapitel beschriebene Heuristik verwendet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}game.ipynb
\end{Verbatim}
\end{tcolorbox}

    Die Klasse \texttt{HeuristicWeights} ist eine Hilfsklasse, dessen
Instanzen beim Aufruf von der spÃ¤ter definierten Funktion
\texttt{heuristic} Ã¼bergeben werden kÃ¶nnen. In dieser Klasse werden alle
Gewichtungen fÃ¼r die einzelnen Eigenschaften eines Zustandes
gespeichert. Dadurch wird es ermÃ¶glicht kÃ¼nstliche Intelligenzen mit
verschiedenen Heuristiken gegeneinander antreten zu lassen, um
herauszufinden welche Heuristik den Wert eines Zustandes am genausten
abbildet.

Eine Instanz der Klasse \texttt{HeuristicWeights} besteht aus vier
Gewichtungen, eine fÃ¼r jede Eigenschaft:

\begin{itemize}
    \item \texttt{stones}: Diese Eigenschaft zÃ¤hlt, wie viele Steine der Spieler auf dem Spielbrett hat.
    \item \texttt{stash}: Die Steine auf dem Stapel werden ebenfalls gezÃ¤hlt.
    \item \texttt{mills}: Die Anzahl der MÃ¼hlen, die ein Spieler auf dem Spielbrett hat, wird durch diese Eigenschaft gezÃ¤hlt.
    \item \texttt{possible\_mills}: Die Anzahl der mÃ¶glichen MÃ¼hlen, dh. MÃ¼hlen
    bei denen eine Zelle noch frei ist, werden ebenfalls gezÃ¤hlt. (Siehe
    \texttt{findPossibleMills} im Kapitel \emph{Hilfsfunktionen fÃ¼r die
    Spielimplementierung} fÃ¼r eine genauere Beschreibung einer mÃ¶glichen
    MÃ¼hle.)
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{HeuristicWeights}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{stones}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{stash}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{mills}\PY{o}{=}\PY{l+m+mi}{4}\PY{p}{,} \PY{n}{possible\PYZus{}mills}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stones} \PY{o}{=} \PY{n}{stones}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stash} \PY{o}{=} \PY{n}{stash}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{mills} \PY{o}{=} \PY{n}{mills}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{possible\PYZus{}mills} \PY{o}{=} \PY{n}{possible\PYZus{}mills}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r Debuggingzwecke wird eine \texttt{\_\_repr\_\_} Funktion
implementiert, die eine String-ReprÃ¤sentation aus einer
\texttt{HeuristicWeights} Instanz mit allen Einstelungen erstellt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{HeuristicWeights}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{HeuristicWeights(stones=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stones}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, stash=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stash}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
           \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{mills=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{mills}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, possible\PYZus{}mills=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{possible\PYZus{}mills}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{HeuristicWeights}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{heuristic} berechnet fÃ¼r einen Spieler den
geschÃ¤tzten Wert eines Zuststandes anhand der oben aufgefÃ¼hrten
Eigenschaften. Die Funktion hat drei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{state} \(\in States\);
\item
  \texttt{player} \(\in Players\);
\item
  optional: \texttt{weights} ist eine Instanz der Klasse
  \texttt{HeuristicWeights}.
\end{itemize}

FÃ¼r die Implementierung werden alle gewichteten Werte der Eigenschaften
fÃ¼r die Spieler weiÃ \texttt{w} und schwarz \texttt{b}, sowie der
maximale Wert fÃ¼r die Eigenschaft errechnet. Damit die SchÃ¤tzung des
Wertes nicht auÃerhalb des Wertebereiches, gegeben durch die
tatsÃ¤chlichen Werte fÃ¼r gewinnende (\texttt{1.0}) und verlierende
(\texttt{-1.0}) ZustÃ¤nde, liegt, wird das Maximum um eins erhÃ¶ht und der
errechnete Wert durch das Maximum skaliert. Zum Schluss wird das
Vorzeichen angepasst, damit der gegebene Spieler berÃ¼cksichtigt wird.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{heuristic}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{weights}\PY{o}{=}\PY{n}{HeuristicWeights}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{p}{(}\PY{p}{(}\PY{n}{stash\PYZus{}white}\PY{p}{,} \PY{n}{stash\PYZus{}black}\PY{p}{)}\PY{p}{,} \PY{n}{board}\PY{p}{)} \PY{o}{=} \PY{n}{state}
    
    \PY{c+c1}{\PYZsh{} Count the stones on the board}
    \PY{n}{white} \PY{o}{=} \PY{n}{weights}\PY{o}{.}\PY{n}{stones} \PY{o}{*} \PY{n}{countStones}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{n}{black} \PY{o}{=} \PY{n}{weights}\PY{o}{.}\PY{n}{stones} \PY{o}{*} \PY{n}{countStones}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Count the stones in the stash}
    \PY{n}{white} \PY{o}{+}\PY{o}{=} \PY{n}{weights}\PY{o}{.}\PY{n}{stash} \PY{o}{*} \PY{n}{stash\PYZus{}white}
    \PY{n}{black} \PY{o}{+}\PY{o}{=} \PY{n}{weights}\PY{o}{.}\PY{n}{stash} \PY{o}{*} \PY{n}{stash\PYZus{}black}
    \PY{c+c1}{\PYZsh{} There can be at maximum 9 stones per player, so the maximum is the maximum of the weights times the stones}
    \PY{n}{maximum} \PY{o}{=} \PY{l+m+mi}{9} \PY{o}{*} \PY{n+nb}{max}\PY{p}{(}\PY{n}{weights}\PY{o}{.}\PY{n}{stones}\PY{p}{,} \PY{n}{weights}\PY{o}{.}\PY{n}{stash}\PY{p}{)}
    
    \PY{c+c1}{\PYZsh{} Count the mills the player currently has}
    \PY{n}{white} \PY{o}{+}\PY{o}{=} \PY{n}{weights}\PY{o}{.}\PY{n}{mills} \PY{o}{*} \PY{n+nb}{len}\PY{p}{(}\PY{n}{findMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
    \PY{n}{black} \PY{o}{+}\PY{o}{=} \PY{n}{weights}\PY{o}{.}\PY{n}{mills} \PY{o}{*} \PY{n+nb}{len}\PY{p}{(}\PY{n}{findMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} There can be at maximum 4 mills for each player}
    \PY{n}{maximum} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{4} \PY{o}{*} \PY{n}{weights}\PY{o}{.}\PY{n}{mills}
    
    \PY{c+c1}{\PYZsh{} Count the possible mills the player currently has}
    \PY{n}{white} \PY{o}{+}\PY{o}{=} \PY{n}{weights}\PY{o}{.}\PY{n}{possible\PYZus{}mills} \PY{o}{*} \PY{n+nb}{len}\PY{p}{(}\PY{n}{findPossibleMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
    \PY{n}{black} \PY{o}{+}\PY{o}{=} \PY{n}{weights}\PY{o}{.}\PY{n}{possible\PYZus{}mills} \PY{o}{*} \PY{n+nb}{len}\PY{p}{(}\PY{n}{findPossibleMills}\PY{p}{(}\PY{n}{board}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} There can be at maximum 8 possible mills for each player}
    \PY{n}{maximum} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{8} \PY{o}{*} \PY{n}{weights}\PY{o}{.}\PY{n}{possible\PYZus{}mills}
    
    \PY{c+c1}{\PYZsh{} Substract the player scores and clamp them into (\PYZhy{}1;+1)}
    \PY{n}{score} \PY{o}{=} \PY{p}{(}\PY{n}{white} \PY{o}{\PYZhy{}} \PY{n}{black}\PY{p}{)} \PY{o}{/} \PY{p}{(}\PY{n}{maximum} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}

    \PY{c+c1}{\PYZsh{} Select the correct player}
    \PY{k}{return} \PY{n}{score} \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}} \PY{k}{else} \PY{o}{\PYZhy{}}\PY{n}{score}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
    
    
    

    
    \hypertarget{symmetrie}{%
\section{Symmetrie}\label{symmetrie}}

Um das Caching noch effektiver zu gestalten, sollen neben
Transpositionen auch Symmetrien erkannt werden. In diesem Kapitel werden
alle Funktionen, die fÃ¼r die Symmetrieerkennung nÃ¶tig sind, vorgestellt
und implementiert.

ZunÃ¤chst werden Hilfsfunktion definiert, die auf den gegebenen
Spielbrettern (\texttt{boards}) eine bestimmte Symmetrie anwenden und
alle resultierenden Spielbretter in einer Menge (\texttt{Set}) zurÃ¼ck
geben. Schlussendlich werden alle Symmetrien nacheinander angewandt,
damit auch zusammengesetzte Symetrien wie beispielsweise
\texttt{Rotation\ um\ 90Â°} dann
\texttt{Spiegelung\ an\ der\ horizontalen\ Achse} errechnet werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}game\PYZhy{}utils.ipynb
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{rotation}{%
\subsection{Rotation}\label{rotation}}

Ein Spielbrett kann um 90Â°, 180Â° oder 270Â° gedreht werden, die
resultierenden Spielbretter sind rotationssymmetrisch.

Die Eingabe besteht aus einer Menge von Spielbrettern (\texttt{boards}),
die Ausgabe ist ebenfalls eine Menge, die alle Spielbretter enthÃ¤lt, die
rotationssymmetrisch zu der Eingabe sind. Berechnet wird die Ausgabe
indem alle Ringe um \(k \in {2, 4, 6}\) Zellen rotiert werden. Durch
Aneinanderreihung der letzten \(8-k\) Zellen und der ersten \(k\) Zellen
kommt die Rotation zustande.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{symmetryRotation}\PY{p}{(}\PY{n}{boards}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{n+nb}{tuple}\PY{p}{(}
            \PY{n}{board}\PY{p}{[}\PY{n}{ring}\PY{p}{]}\PY{p}{[}\PY{n}{rotation}\PY{p}{:}\PY{p}{]} \PY{o}{+} \PY{n}{board}\PY{p}{[}\PY{n}{ring}\PY{p}{]}\PY{p}{[}\PY{p}{:}\PY{n}{rotation}\PY{p}{]}
            \PY{k}{for} \PY{n}{ring} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
        \PY{p}{)}
        \PY{k}{for} \PY{n}{rotation} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{l+m+mi}{6}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{2}\PY{p}{)}
        \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{spiegelung}{%
\subsection{Spiegelung}\label{spiegelung}}

Bei den Spiegelungen wird an vier Achsen gespiegelt:

\begin{itemize}
    \item die \emph{horizontale} und \emph{vertikale} Achse, sowie
    \item die Diagonale von
    oben links nach unten rechts (\emph{negative Diagonale}) und die
    Diagonale von unten links nach oben rechts (\emph{positive Diagnonale}).
\end{itemize}

Diese Spiegelungen kÃ¶nnen einzelnd pro Ring vorgenommen werden, da der
Ã¤uÃere Ring bleibt nach der Spiegelung weiterhin der Ã¤uÃere Ring.
Gleiches gilt fÃ¼r die anderen Ringe. Alle Spiegelungen lassen sich durch
eine Invertierung der Ringe und eine Rotation von \(k \in {0, 2, 4, 6}\)
darstellen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{symmetryHorizontal}\PY{p}{(}\PY{n}{boards}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{n+nb}{tuple}\PY{p}{(}
            \PY{n+nb}{tuple}\PY{p}{(}
                \PY{n}{board}\PY{p}{[}\PY{n}{ring}\PY{p}{]}\PY{p}{[}\PY{p}{(}\PY{l+m+mi}{8}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n}{cell}\PY{o}{+}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{o}{\PYZpc{}}\PY{k}{8}]
                \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{)}
            \PY{p}{)}
            \PY{k}{for} \PY{n}{ring} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
        \PY{p}{)}
        \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{symmetryVertical}\PY{p}{(}\PY{n}{boards}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{n+nb}{tuple}\PY{p}{(}
            \PY{n+nb}{tuple}\PY{p}{(}
                \PY{n}{board}\PY{p}{[}\PY{n}{ring}\PY{p}{]}\PY{p}{[}\PY{p}{(}\PY{l+m+mi}{8}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n}{cell}\PY{o}{+}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}\PY{o}{\PYZpc{}}\PY{k}{8}]
                \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{)}
            \PY{p}{)}
            \PY{k}{for} \PY{n}{ring} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
        \PY{p}{)}
        \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{symmetryDiagonalPositive}\PY{p}{(}\PY{n}{boards}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{n+nb}{tuple}\PY{p}{(}
            \PY{n+nb}{tuple}\PY{p}{(}
                \PY{n}{board}\PY{p}{[}\PY{n}{ring}\PY{p}{]}\PY{p}{[}\PY{p}{(}\PY{l+m+mi}{8}\PY{o}{\PYZhy{}}\PY{p}{(}\PY{n}{cell}\PY{o}{+}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}\PY{o}{\PYZpc{}}\PY{k}{8}]
                \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{)}
            \PY{p}{)}
            \PY{k}{for} \PY{n}{ring} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
        \PY{p}{)}
        \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{symmetryDiagnoalNegative}\PY{p}{(}\PY{n}{boards}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{n+nb}{tuple}\PY{p}{(}
            \PY{n+nb}{tuple}\PY{p}{(}
                \PY{n}{board}\PY{p}{[}\PY{n}{ring}\PY{p}{]}\PY{p}{[}\PY{p}{(}\PY{l+m+mi}{8}\PY{o}{\PYZhy{}}\PY{n}{cell}\PY{p}{)}\PY{o}{\PYZpc{}}\PY{k}{8}]
                \PY{k}{for} \PY{n}{cell} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{8}\PY{p}{)}
            \PY{p}{)}
            \PY{k}{for} \PY{n}{ring} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
        \PY{p}{)}
        \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{ring-tausch}{%
\subsection{Ring-Tausch}\label{ring-tausch}}

Da der innere und der Ã¤uÃere Ring Ã¼ber symmetrische Kanten mit dem
mittleren Ring verbunden ist, kÃ¶nnen der Ã¤uÃere und der innere Ringe
getauscht werden. Dies funktioniert indem rÃ¼ckwÃ¤rts Ã¼ber die Ringe
iteriert wird.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{symmetryRing}\PY{p}{(}\PY{n}{boards}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{n+nb}{tuple}\PY{p}{(}
            \PY{n}{board}\PY{p}{[}\PY{n}{ring}\PY{p}{]}
            \PY{k}{for} \PY{n}{ring} \PY{o+ow}{in} \PY{n+nb}{reversed}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
        \PY{p}{)}
        \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{zusammenfuxfchrung}{%
\subsection{ZusammenfÃ¼hrung}\label{zusammenfuxfchrung}}

Damit alle mÃ¶glichen Symmetrien gefunden werden, wird jede Hilfsfunktion
einzelnd auf alle vorherigen Spielbretter (\texttt{boards}) oder
ZustÃ¤nde (\texttt{states}) angewandt. Dadurch sind auch zusammengesetzte
Symmetrien wie beispielsweise \texttt{Rotation\ um\ 90Â°} dann
\texttt{Spiegelung\ an\ der\ horizontalen\ Achse} mÃ¶glich. Mit Hilfe
einer Menge wird sichergestellt, dass keine Duplikate zurÃ¼ck gegeben
werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{findSymmetries}\PY{p}{(}\PY{n}{state}\PY{p}{)}\PY{p}{:}
    \PY{n}{stash}\PY{p}{,} \PY{n}{board} \PY{o}{=} \PY{n}{state}
    
    \PY{n}{boards} \PY{o}{=} \PY{p}{\PYZob{}} \PY{n}{board} \PY{p}{\PYZcb{}}
    \PY{n}{boards} \PY{o}{|}\PY{o}{=} \PY{n}{symmetryRotation}\PY{p}{(}\PY{n}{boards}\PY{p}{)}
    \PY{n}{boards} \PY{o}{|}\PY{o}{=} \PY{n}{symmetryHorizontal}\PY{p}{(}\PY{n}{boards}\PY{p}{)}
    \PY{n}{boards} \PY{o}{|}\PY{o}{=} \PY{n}{symmetryVertical}\PY{p}{(}\PY{n}{boards}\PY{p}{)}
    \PY{n}{boards} \PY{o}{|}\PY{o}{=} \PY{n}{symmetryDiagonalPositive}\PY{p}{(}\PY{n}{boards}\PY{p}{)}
    \PY{n}{boards} \PY{o}{|}\PY{o}{=} \PY{n}{symmetryDiagnoalNegative}\PY{p}{(}\PY{n}{boards}\PY{p}{)}
    \PY{n}{boards} \PY{o}{|}\PY{o}{=} \PY{n}{symmetryRing}\PY{p}{(}\PY{n}{boards}\PY{p}{)}
    
    \PY{k}{return} \PY{p}{\PYZob{}}
        \PY{p}{(}\PY{n}{stash}\PY{p}{,} \PY{n}{board}\PY{p}{)}
        \PY{k}{for} \PY{n}{board} \PY{o+ow}{in} \PY{n}{boards}
    \PY{p}{\PYZcb{}}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
    
    
    

    
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}game.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}artificial\PYZhy{}intelligence.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}heuristic.ipynb
\PY{k+kn}{import} \PY{n+nn}{time}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{minimax}{%
\section{Minimax}\label{minimax}}

Der \emph{Minimax} Algorithmus bietet eine einfache MÃ¶glichkeit, um den
perfekten Spielzug in einem Nullsummenspiel zu berechnen. Um diesen zu
finden, wird der komplette Spielbaum vollstÃ¤ndig per Tiefensuche
durchsucht. FÃ¼r einen Spielbaum mit der Tiefe \texttt{h} und dem
Verzweigungsgrad \texttt{b} bedeutet das fÃ¼r die Zeit \texttt{t} und den
Speicher \texttt{m}: \[ t_{Minimax} \in \mathcal{O}(b^h) \]
\[ m_{Minimax} \in \mathcal{O}(b\cdot h) \] Logischerweise ist
\emph{Minimax} somit nicht fÃ¼r die komplette Berechnung des Spiels
geeignet, weil dies die Ã¼blicherweise zur VerfÃ¼gung stehenden Ressourcen
Ã¼berschreitet. Aus diesem Grund wird die Tiefensuche auf eine maximale
Tiefe \texttt{limit} beschrÃ¤nkt. Dies hat jedoch zur Folge, dass bei der
maximalen Tiefe hÃ¤ufig noch kein eindeutiges Ergebnis \emph{Mini} dem
Wert \texttt{-1} (sichere Niederlage fÃ¼r \texttt{player}) oder
\emph{Max} mit dem Wert \texttt{1} (sicherer Sieg fÃ¼r \texttt{player})
erkannt werden konnte. Somit ist die Funktion
\texttt{heuristic(state,\ player)} notwendig die in einem solchen Fall
eine einfache heuristische Bewertung des \texttt{state} fÃ¼r den
\texttt{player} durchfÃ¼hrt und einen Wert \$ -1 \textless{} value
\textless{} 1 \$ berechnet.

    FÃ¼r die Implementierung des \emph{Minimax} Algorithmus wird nun eine
Klasse \texttt{Minimax} implementiert, die von der zuvor definierten
Klasse \texttt{ArtificialIntelligence} erbt. Hierzu wird die Funktion
\texttt{bestMoves} Ã¼berschrieben, die spÃ¤ter genauer definiert wird, und
der Konstruktor \texttt{\_\_init\_\_} implementiert. Der Konstruktor
besitzt zwei optionale Parameter, die den Algorithmus konfigurieren
kÃ¶nnen:

\begin{itemize}
\tightlist
\item
  Die \texttt{limit} Einstellung setzt die maximale Rekursionstiefe;
\item
  Durch den \texttt{weights} Parameter kÃ¶nnen die Gewichtungen der zuvor
  definierten Heuristik bestimmt werden.
\end{itemize}

ZusÃ¤tzlich initialisiert der Konstruktor das Attribut \texttt{cache} mit
einem leeren \texttt{dict}. Dieses wird spÃ¤ter als Transpositionstabelle
verwendet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Minimax}\PY{p}{(}\PY{n}{ArtificialIntelligence}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{limit}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{weights}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limit} \PY{o}{=} \PY{n}{limit}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights} \PY{o}{=} \PY{n}{weights}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights} \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{def} \PY{n+nf}{bestMoves}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{:}
        \PY{k}{pass}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r Debuggingzwecke wird eine \texttt{\_\_repr\_\_} Funktion
implementiert, die eine String-ReprÃ¤sentation aus einer \texttt{Minimax}
Instanz mit allen Einstelungen erstellt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Minimax}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Minimax(limit=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limit}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, weights=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{Minimax}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{memoize} erwartet eine Funktion \texttt{f} als
Parameter und Ã¼berprÃ¼ft, ob diese bereits mit den gleichen Parametern
aufgerufen wurde. Falls ja, wird der gespeicherte Wert zurÃ¼ckgegeben.
Falls nicht, werden die Parameter und das Ergebnis nach der Errechnung
in die Transpositionstabelle gespeichert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{memoize}\PY{p}{(}\PY{n}{f}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{f\PYZus{}memoized}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{:}
        \PY{n}{key} \PY{o}{=} \PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
        
        \PY{k}{if} \PY{n}{key} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}hit} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{n}{key}\PY{p}{]}

        \PY{n}{result} \PY{o}{=} \PY{n}{f}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{n}{key}\PY{p}{]} \PY{o}{=} \PY{n}{result}

        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}miss} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{k}{return} \PY{n}{result}

    \PY{k}{return} \PY{n}{f\PYZus{}memoized}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{value} nimmt einen Spielzustand \texttt{state} und
liefert bei Ende des Spiels den Wert \texttt{value} mit Hilfe der
\texttt{utility} Funktion fÃ¼r den Spieler \texttt{player}. Mit
\texttt{limit} wird die Rekursionstiefe begrenzt. Beim Erreichen dieser
wird die Funktion \texttt{heuristic} aufgerufen. In allen weiteren
FÃ¤llen wird rekursiv in den nÃ¤chsten mÃ¶glichen Schritten nach dem
maximal zu erreichenden Wert \texttt{value} gesucht. Zusammengefasst
bedeutet das fÃ¼r die Funktion:

\[ value(state, player, limit) = \begin{cases}
utility(state, player) & falls\ \ finished(state, player) = true \\
heuristic(state, player) & falls\ \ limit = 0 \\
max(-value(ns, \neg{player}, limit)) \\
\forall  ns \in nextStates(state, player) & sonst
\end{cases}
\]

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nd}{@memoize}
\PY{k}{def} \PY{n+nf}{value}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{finished}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{utility}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}
    \PY{k}{if} \PY{n}{limit} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{k}{return} \PY{n}{heuristic}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights}\PY{p}{)}
    \PY{k}{return} \PY{n+nb}{max}\PY{p}{(}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{value}\PY{p}{(}\PY{n}{ns}\PY{p}{,} \PY{n}{opponent}\PY{p}{(}\PY{n}{player}\PY{p}{)}\PY{p}{,} \PY{n}{limit}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{k}{for} \PY{n}{ns} \PY{o+ow}{in} \PY{n}{nextStates}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{]}\PY{p}{)}

\PY{n}{Minimax}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{n}{value}
\PY{k}{del} \PY{n}{value}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{bestMoves} berechnet den geschÃ¤tzten Wert aller
mÃ¶glichen ZÃ¼ge fÃ¼r einen Spieler \texttt{player} und wÃ¤hlt die ZÃ¼ge mit
dem besten Wert aus. Dieser Wert wird innerhalb der maximalen
Rekursionstiefe \texttt{limit} mit dem gegebenen Ausgangszustand
\texttt{state} gesucht.

ZusÃ¤tzlich werden Informationen gesammelt, die die genaueren AblÃ¤ufe im
Algorithmus abbilden:

\begin{itemize}
    \item \texttt{runtime} ist die Rechendauer der Funktion in Sekunden;
    \item \texttt{limit} beschreibt die verwendete maximale Rekursionstiefe;
    \item \texttt{cache\_hit} ist die Anzahl der Berechnungen, die durch die Transpositionstabelle (\texttt{cache}) eingespart werden konnten;
    \item \texttt{cache\_miss} hingegen ist die
    Anzahl der Berechnungen, die trotz der Transpositionstablle durchgefÃ¼hrt
    werden mussten.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{bestMoves}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n}{BestMoves}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Start clock}
    \PY{n}{start} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
    
    \PY{c+c1}{\PYZsh{} Reset debug counter}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}hit} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}miss} \PY{o}{=} \PY{l+m+mi}{0}
    
    \PY{c+c1}{\PYZsh{} Compute all expected values}
    \PY{n}{moves} \PY{o}{=} \PY{p}{[}
        \PY{p}{(}\PY{o}{\PYZhy{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{value}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{opponent}\PY{p}{(}\PY{n}{player}\PY{p}{)}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limit}\PY{p}{)}\PY{p}{,} \PY{n}{state}\PY{p}{)}
        \PY{k}{for} \PY{n}{state} \PY{o+ow}{in} \PY{n}{nextStates}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}
    \PY{p}{]}
    
    \PY{n}{maximum} \PY{o}{=} \PY{n+nb}{max}\PY{p}{(}\PY{n}{value} \PY{k}{for} \PY{p}{(}\PY{n}{value}\PY{p}{,} \PY{n}{state}\PY{p}{)} \PY{o+ow}{in} \PY{n}{moves}\PY{p}{)}
    \PY{n}{bestMoves} \PY{o}{=} \PY{p}{[}\PY{n}{state} \PY{k}{for} \PY{p}{(}\PY{n}{value}\PY{p}{,} \PY{n}{state}\PY{p}{)} \PY{o+ow}{in} \PY{n}{moves} \PY{k}{if} \PY{n}{value} \PY{o}{==} \PY{n}{maximum}\PY{p}{]}
    
    \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
    \PY{k}{return} \PY{n}{BestMoves}\PY{p}{(}
        \PY{n}{bestMoves}\PY{p}{,}
        \PY{n}{maximum}\PY{p}{,}
        \PY{c+c1}{\PYZsh{} Collect debug information}
        \PY{p}{\PYZob{}}   \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{runtime}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{,}
            \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{limit}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limit}\PY{p}{,}
            \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cache\PYZus{}hit}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}hit}\PY{p}{,}
            \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cache\PYZus{}miss}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}miss}\PY{p}{,}   \PY{p}{\PYZcb{}}
    \PY{p}{)}

\PY{n}{Minimax}\PY{o}{.}\PY{n}{bestMoves} \PY{o}{=} \PY{n}{bestMoves}
\PY{k}{del} \PY{n}{bestMoves}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
    
    
    

    
    \hypertarget{ux3b1-ux3b2-pruning}{%
\section{$\alpha$-$\beta$-Pruning}\label{ux3b1-ux3b2-pruning}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}game.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}artificial\PYZhy{}intelligence.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}heuristic.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}symmetry.ipynb
\PY{k+kn}{import} \PY{n+nn}{time}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r die Implementierung des \emph{$\alpha$-$\beta$-Pruning} Algorithmus wird eine
Klasse \texttt{AlphaBetaPruning} implementiert, die ebenfalls von der
zuvor definierten Klasse \texttt{ArtificialIntelligence} erbt. Auch hier
wird die Funktion \texttt{bestMoves} Ã¼berschrieben, die spÃ¤ter genauer
definiert wird, und den Konstruktor \texttt{\_\_init\_\_} implementiert.
Der Konstruktor besitzt drei optionale Parameter, die den Algorithmus
konfigurieren kÃ¶nnen:

\begin{itemize}
\tightlist
\item
  die \texttt{max\_states} Einstellung setzt die maximale Anzahl an
  ZusÃ¤nden, die betrachtet werden sollen;
\item
  die \texttt{symmetry} Einstellung legt fest, ob alle symmetrischen
  Spielfelder zu einem Zustand berechnet werden sollen und dann
  ebenfalls in der Transpositionstabelle abgelegt werden sollen;
\item
  durch den \texttt{weights} Parameter kÃ¶nnen die Gewichtungen der zuvor
  definierten Heuristik bestimmt werden.
\end{itemize}

ZusÃ¤tzlich initialisiert der Konstruktor das Attribute \texttt{cache}
mit einem leeren \texttt{dict}. Dieses wird spÃ¤ter als
Transpositionstabelle, bzw. als Sortierungsgrundlage in der Funktion
\texttt{orderMoves} fÃ¼r \emph{Iterative Deepening} verwendet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{AlphaBetaPruning}\PY{p}{(}\PY{n}{ArtificialIntelligence}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{max\PYZus{}states}\PY{o}{=}\PY{l+m+mi}{25\PYZus{}000}\PY{p}{,} \PY{n}{symmetry}\PY{o}{=}\PY{k+kc}{True}\PY{p}{,} \PY{n}{weights}\PY{o}{=}\PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache} \PY{o}{=} \PY{p}{\PYZob{}}\PY{p}{\PYZcb{}}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}states} \PY{o}{=} \PY{n}{max\PYZus{}states}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{symmetry} \PY{o}{=} \PY{n}{symmetry}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights} \PY{o}{=} \PY{n}{weights}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights} \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{def} \PY{n+nf}{bestMoves}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{:}
        \PY{k}{pass}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r Debuggingzwecke wird eine \texttt{\_\_repr\_\_} Funktion
implementiert, die eine String-ReprÃ¤sentation aus einer
\texttt{AlphaBetaPruning} Instanz mit allen Einstelungen erstellt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{AlphaBetaPruning(max\PYZus{}states=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}states}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, symmetry=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{symmetry}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, weights=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{AlphaBetaPruning}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{iterative-tiefensuche}{%
\subsubsection{Iterative Tiefensuche}\label{iterative-tiefensuche}}

Die Iterative Tiefensuche bietet die MÃ¶glichkeit eine konstante Anzahl
an ZustÃ¤nden betrachten zu kÃ¶nnen. Dieses bietet den Vorteil gegenÃ¼ber
fest definierten Tiefenlimits, dass bei weniger komplexen BÃ¤umen die
Suche weiter fortgesetzt werden kann und die Antwortzeit an den Nutzer
durch die gleiche Anzahl an ZustÃ¤nden nahezu konstant bleibt. Dies sorgt
gerade in Phase 2 des MÃ¼hle-Spiels dafÃ¼r, dass die SpielzÃ¼ge um einiges
weiter im Voraus berechnet werden kÃ¶nnen. Andererseits verhindert es
jedoch auch bei sehr komplexes SuchbÃ¤umen eine verlÃ¤ngerte Antwortzeit.

In der Umsetzung bedeutet das, dass die maximale Rekursionstiefe bei
einem Aufruf der \texttt{bestMoves()}-Funktion zunÃ¤chst immer bei
\texttt{limit=1} liegt. Wenn nach der Betrachung aller ZustÃ¤nde mit
Verwendung der Rekursionstiefe noch keine
\texttt{IterativeMaxCountException()} geworfen wurde, wird das Maximum
um eins erhÃ¶ht.

Die gewÃ¼nschte maximale Anzahl an ZustÃ¤nden \texttt{maxCount} kann im
\texttt{AlphaBetaPruning}-Konstruktor mit Hilfe der Option
\texttt{max\_states} festgelegt werden.

\hypertarget{exception-fuxfcr-das-erreichen-der-maximalen-zustuxe4nden-iterativemaxcountexception}{%
\paragraph{\texorpdfstring{Exception fÃ¼r das Erreichen der maximalen
ZustÃ¤nden
\texttt{IterativeMaxCountException}}{Exception fÃ¼r das Erreichen der maximalen ZustÃ¤nden IterativeMaxCountException}}\label{exception-fuxfcr-das-erreichen-der-maximalen-zustuxe4nden-iterativemaxcountexception}}

Die Exception \texttt{IterativeMaxCountException} wird aufgerufen, wenn
ein Fehler aufgrund des Erreichens der maximal zu betrachtenden ZustÃ¤nde
bei der iterativen Tiefensuche erzeugt werden soll. Der Parameter
\texttt{maxCount} im Konstruktor der Fehlermeldung nimmt dabei die
erreichte maximale Anzahl an besuchten ZustÃ¤nden an, um diese in der
Fehlermeldung wiedergeben zu kÃ¶nnen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{IterativeMaxCountException}\PY{p}{(}\PY{n+ne}{Exception}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{maxCount}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{super}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Reached max count (}\PY{l+s+si}{\PYZob{}}\PY{n}{maxCount}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{) of iterative deepeing}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}    
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktion-zum-uxfcberpruxfcfen-der-maximal-zu-besuchenden-zustuxe4nde-checkmaxstates}{%
\paragraph{\texorpdfstring{Hilfsfunktion zum ÃberprÃ¼fen der maximal zu
besuchenden ZustÃ¤nde
\texttt{checkMaxStates}}{Hilfsfunktion zum ÃberprÃ¼fen der maximal zu besuchenden ZustÃ¤nde checkMaxStates}}\label{hilfsfunktion-zum-uxfcberpruxfcfen-der-maximal-zu-besuchenden-zustuxe4nde-checkmaxstates}}

Die Hilfsfunktion \texttt{checkMaxStates} zÃ¤hlt die errechneten und
besuchten ZustÃ¤nde fÃ¼r die Implementierung der \emph{iterativen
Tiefensuche}. Ist die Anzahl der maximal erlaubten ZustÃ¤nde
Ã¼berschritten, wird ein Fehler ausgelÃ¶st, damit der Algorithmus abbricht
und ein Ergebnis zurÃ¼ck gegeben werden kann. Diese Ausnahmebetrachtung
ist in der Funktion \texttt{bestMoves} implementiert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{checkMaxStates}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{visited} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
    \PY{k}{if} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{visited} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}states}\PY{p}{)}\PY{p}{:}
        \PY{k}{raise} \PY{n}{IterativeMaxCountException}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}states}\PY{p}{)}

\PY{n}{AlphaBetaPruning}\PY{o}{.}\PY{n}{checkMaxStates} \PY{o}{=} \PY{n}{checkMaxStates}
\PY{k}{del} \PY{n}{checkMaxStates}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{sortieren-der-zustuxe4nde}{%
\paragraph{Sortieren der ZustÃ¤nde}\label{sortieren-der-zustuxe4nde}}

Die Funktion \texttt{orderMoves} sortiert eine Liste von ZustÃ¤nden
\texttt{states} fÃ¼r einen Spieler \texttt{player} entsprechend der fÃ¼r
diese ZustÃ¤nde erreichten Werte aus der vorherigen Iteration der
\emph{Iterativen Tiefensuche}. So soll erreicht werden, dass
vielversprechende ZustÃ¤nde frÃ¼her betrachtet werden und sich somit
TeilbÃ¤ume eventuell frÃ¼her abschneiden lassen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{orderMoves}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{states}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n+nb}{sorted}\PY{p}{(}
        \PY{n}{states}\PY{p}{,}
        \PY{n}{key}     \PY{o}{=} \PY{k}{lambda} \PY{n}{state}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
        \PY{n}{reverse} \PY{o}{=} \PY{k+kc}{True}
    \PY{p}{)}

\PY{n}{AlphaBetaPruning}\PY{o}{.}\PY{n}{orderMoves} \PY{o}{=} \PY{n}{orderMoves}
\PY{k}{del} \PY{n}{orderMoves}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{implementierung-ux3b1-ux3b2-pruning}{%
\subsubsection{\texorpdfstring{Implementierung
\emph{$\alpha$-$\beta$-Pruning}}{Implementierung $\alpha$-$\beta$-Pruning}}\label{implementierung-ux3b1-ux3b2-pruning}}

\hypertarget{hilfsfunktion-zum-fuxfcllen-der-transpositionstabelle-writecache}{%
\paragraph{\texorpdfstring{Hilfsfunktion zum FÃ¼llen der
Transpositionstabelle
\texttt{writeCache}}{Hilfsfunktion zum FÃ¼llen der Transpositionstabelle writeCache}}\label{hilfsfunktion-zum-fuxfcllen-der-transpositionstabelle-writecache}}

Die Hilfsfunktion \texttt{writeCache} legt den gegebenen Zustand
\texttt{state} und Spieler \texttt{player} mit samt der errechneten
Werte \texttt{value}, \texttt{alpha} und \texttt{beta} in der
Transpositionstabelle (\texttt{cache}) ab. Ist zusÃ¤tzlich die
Einstellung \texttt{symmetry} aktiviert, werden auch die errechneten
Spielfelder in der Transpositionstabelle gespeichert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{writeCache}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{value}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{symmetry}\PY{p}{:}
        \PY{k}{for} \PY{n}{symmetricState} \PY{o+ow}{in} \PY{n}{findSymmetries}\PY{p}{(}\PY{n}{state}\PY{p}{)}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{p}{(}\PY{n}{symmetricState}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{n}{value}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{n}{value}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{)}

\PY{n}{AlphaBetaPruning}\PY{o}{.}\PY{n}{writeCache} \PY{o}{=} \PY{n}{writeCache}
\PY{k}{del} \PY{n}{writeCache}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktion-zum-abgleich-mit-der-transpositionstabelle-value}{%
\paragraph{\texorpdfstring{Hilfsfunktion zum Abgleich mit der
Transpositionstabelle
\texttt{value}}{Hilfsfunktion zum Abgleich mit der Transpositionstabelle value}}\label{hilfsfunktion-zum-abgleich-mit-der-transpositionstabelle-value}}

Die \texttt{value} Funktion ist ein Wrapper fÃ¼r die eigentliche
Implementierung des \emph{$\alpha$-$\beta$-Pruning} in der Funktion
\texttt{alphaBeta}. Dieser Wrapper Ã¼berprÃ¼ft die Transpositionstabelle
\emph{cache} auf das Vorhandensein eines bereits berechneten Wertes fÃ¼r
eine Kombination aus \texttt{state}, \texttt{player}, und
\texttt{limit}. Ist ein Wert vorhanden, wird dieser auf seine ValiditÃ¤t
Ã¼berprÃ¼ft. Wenn diese ÃberprÃ¼fung fehlschlÃ¤gt, oder kein Wert vorhanden
ist, wird dieser mithilfe der \texttt{alphaBeta}-Funktion berechnet und
in der Transpositionstabelle \emph{cache} abgespeichert.

Ein Ergebnis aus dem Cache ist valide, solange das Intervall
\texttt{alpha} und \texttt{beta} aus den Parametern innerhalb des im
Cache verwendeten Intervalls \texttt{a} und \texttt{b} liegt. Also das
Intervall des Caches muss genereller sein, als das Intervall aus den
Parametern.

FÃ¼r Auswertungszwecke wird auÃerdem bei jedem der drei mÃ¶glichen FÃ¤lle
ein ZÃ¤hler erhÃ¶ht.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{value}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{:}
        \PY{p}{(}\PY{n}{val}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{)} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache}\PY{p}{[}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{]}
        \PY{k}{if} \PY{n}{a} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{alpha} \PY{o+ow}{and} \PY{n}{beta} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{b}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}hit} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{k}{return} \PY{n}{val}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{alpha} \PY{o}{=} \PY{n+nb}{min}\PY{p}{(}\PY{n}{alpha}\PY{p}{,} \PY{n}{a}\PY{p}{)}
            \PY{n}{beta}  \PY{o}{=} \PY{n+nb}{max}\PY{p}{(}\PY{n}{beta} \PY{p}{,} \PY{n}{b}\PY{p}{)}
            \PY{n}{val}   \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{alphaBeta}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{writeCache}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{val}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}invalid} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{k}{return} \PY{n}{val}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{val} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{alphaBeta}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{writeCache}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{val}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{,} \PY{n}{limit}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}miss} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{k}{return} \PY{n}{val}

\PY{n}{AlphaBetaPruning}\PY{o}{.}\PY{n}{value} \PY{o}{=} \PY{n}{value}
\PY{k}{del} \PY{n}{value}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{funktion-zur-berechnung-des-wertes-eines-spielzustands-alphabeta}{%
\paragraph{\texorpdfstring{Funktion zur Berechnung des Wertes eines
Spielzustands
\texttt{alphaBeta}}{Funktion zur Berechnung des Wertes eines Spielzustands alphaBeta}}\label{funktion-zur-berechnung-des-wertes-eines-spielzustands-alphabeta}}

Die Funktion \texttt{alphaBeta} beinhaltet nun die eigentliche
Implementierung des \emph{$\alpha$-$\beta$-Pruning}.

\begin{itemize}
\tightlist
\item
  Wie zuvor beim \emph{Minimax-Algorithmus}, wird der \texttt{utility}
  Wert zurÃ¼ckgegeben, falls das Spiel in dem State \texttt{s} beendet
  (\texttt{finished}) ist.
\item
  Ebenfalls Ã¤quivalent wird der \texttt{heuristic} Wert verwendet,
  sobald das Rekursionslimit (\texttt{limit}) erreicht wird.
\item
  ZusÃ¤tzlich wird mithilfe der Funktion \texttt{checkMaxStates}
  Ã¼berprÃ¼ft, ob die maximal zu betrachtende Anzahl an ZustÃ¤nden erreicht
  wurde.
\item
  Der eigentliche $\alpha$-$\beta$-Pruning Alogrithmus errechnet rekursiv mit Hilfe
  des Caches (\texttt{value}) den Wert eines Zuges. Hierbei wird der
  erste Wert der nÃ¤chsten States verwendet, der grÃ¶Ãer oder gleich der
  oberen Grenze \texttt{beta} ist.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{alphaBeta}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{alpha}\PY{p}{,} \PY{n}{beta}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{:}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{checkMaxStates}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{if} \PY{n}{limit} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{k}{return} \PY{n}{heuristic}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{weights}\PY{p}{)}

    \PY{n}{states} \PY{o}{=} \PY{n}{nextStates}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}
    \PY{k}{if} \PY{n}{finished}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{ns}\PY{o}{=}\PY{n}{states}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{utility}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{ns}\PY{o}{=}\PY{n}{states}\PY{p}{)}

    \PY{n}{val} \PY{o}{=} \PY{n}{alpha}
    \PY{k}{for} \PY{n}{ns} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{orderMoves}\PY{p}{(}\PY{n}{states}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{:}
        \PY{n}{val} \PY{o}{=} \PY{n+nb}{max}\PY{p}{(}\PY{n}{val}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{value}\PY{p}{(}\PY{n}{ns}\PY{p}{,} \PY{n}{opponent}\PY{p}{(}\PY{n}{player}\PY{p}{)}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{beta}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{n}{alpha}\PY{p}{,} \PY{n}{limit}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
        \PY{k}{if} \PY{n}{val} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n}{beta}\PY{p}{:}
            \PY{k}{return} \PY{n}{val}
        \PY{n}{alpha} \PY{o}{=} \PY{n+nb}{max}\PY{p}{(}\PY{n}{val}\PY{p}{,} \PY{n}{alpha}\PY{p}{)}
    \PY{k}{return} \PY{n}{val}

\PY{n}{AlphaBetaPruning}\PY{o}{.}\PY{n}{alphaBeta} \PY{o}{=} \PY{n}{alphaBeta}
\PY{k}{del} \PY{n}{alphaBeta}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{funktion-zur-auswahl-des-bestmuxf6glichen-zuges-bestmoves}{%
\paragraph{\texorpdfstring{Funktion zur Auswahl des bestmÃ¶glichen Zuges
\texttt{bestMoves}}{Funktion zur Auswahl des bestmÃ¶glichen Zuges bestMoves}}\label{funktion-zur-auswahl-des-bestmuxf6glichen-zuges-bestmoves}}

Die Funktion \texttt{bestMoves} berechnet rekursiv den geschÃ¤tzten Wert
aller mÃ¶glichen ZÃ¼ge fÃ¼r einen Spieler \texttt{player} und wÃ¤hlt die
ZÃ¼ge mit dem besten Wert aus. Diese rekursive Suche wird solange
ausgefÃ¼hrt, bis die maximale Anzahl der zu betrachtenden ZustÃ¤nde
erreicht ist. Erreicht wird dies durch das Abfangen einer Exception,
welche beim Erreichen dieser Grenze ausgelÃ¶st wird und somit die
Endlosschleife beendet. Wenn fÃ¼r eine Rekursionstiefe alle ZustÃ¤nde
betrachtet wurden, wird diese automatisch erhÃ¶ht. AbschlieÃend werden
aus den erhaltenen ZustÃ¤nden die ZustÃ¤nde mit dem besten Wert ausgewÃ¤hlt
und zurÃ¼ckgegeben.

ZusÃ¤tzlich werden Informationen gesammelt, die die genaueren AblÃ¤ufe im
Algorithmus abbilden:

\begin{itemize}
    \item \texttt{runtime} ist die Rechendauer der Funktion in Sekunden;
    \item \texttt{limit} ist die erreichte maximale Rekursionstiefe;
    \item \texttt{visited} ist die Anzahl der besuchten ZustÃ¤nde;
    \item \texttt{max\_states} ist die Anzahl der maximal zu besuchenden ZustÃ¤nde;
    \item \texttt{cache\_hit} ist die Anzahl der Berechenungen, die durch die Tanspositionstabelle (\texttt{cache}) eingespart werden konnten;
    \item \texttt{cache\_invalid} ist die Anzahl der Berechnungen, die durchgefÃ¼hrt werden mussten, da der in der Transpositionstabelle vorhandene Wert nicht zu verwenden war;
    \item \texttt{cache\_miss} ist die Anzahl der Berechnungen, die trotz der Transpositionstabelle durchgefÃ¼hrt werden mussten, da kein Eintrag gefunden wurde.    
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{bestMoves}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Start clock}
    \PY{n}{start} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
    
    \PY{c+c1}{\PYZsh{} Reset counter}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{visited} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}hit} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}invalid} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}miss} \PY{o}{=} \PY{l+m+mi}{0}
    
    \PY{n}{states} \PY{o}{=} \PY{n}{nextStates}\PY{p}{(}\PY{n}{state}\PY{p}{,} \PY{n}{player}\PY{p}{)}
    \PY{n}{moves} \PY{o}{=} \PY{p}{[}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{s}\PY{p}{)} \PY{k}{for} \PY{n}{s} \PY{o+ow}{in} \PY{n}{states}\PY{p}{]}

    \PY{n}{limit} \PY{o}{=} \PY{l+m+mi}{1}
    \PY{k}{while} \PY{k+kc}{True}\PY{p}{:}
        \PY{k}{try}\PY{p}{:}
            \PY{n}{moves} \PY{o}{=} \PY{p}{[}
                \PY{p}{(}\PY{o}{\PYZhy{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{value}\PY{p}{(}\PY{n}{s}\PY{p}{,} \PY{n}{opponent}\PY{p}{(}\PY{n}{player}\PY{p}{)}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{limit}\PY{p}{)}\PY{p}{,} \PY{n}{s}\PY{p}{)}
                \PY{k}{for} \PY{n}{s} \PY{o+ow}{in} \PY{n}{states}
            \PY{p}{]}
            \PY{n}{limit} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{k}{except} \PY{n}{IterativeMaxCountException}\PY{p}{:}
            \PY{k}{break}
    
    \PY{n}{maximum} \PY{o}{=} \PY{n+nb}{max}\PY{p}{(}\PY{n}{v} \PY{k}{for} \PY{p}{(}\PY{n}{v}\PY{p}{,} \PY{n}{s}\PY{p}{)} \PY{o+ow}{in} \PY{n}{moves}\PY{p}{)}
    \PY{n}{bestMoves} \PY{o}{=} \PY{p}{[}\PY{n}{s} \PY{k}{for} \PY{p}{(}\PY{n}{v}\PY{p}{,} \PY{n}{s}\PY{p}{)} \PY{o+ow}{in} \PY{n}{moves} \PY{k}{if} \PY{n}{v} \PY{o}{==} \PY{n}{maximum}\PY{p}{]}
    
    \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
    \PY{k}{return} \PY{n}{BestMoves}\PY{p}{(}
        \PY{n}{bestMoves}\PY{p}{,}
        \PY{n}{maximum}\PY{p}{,}
        \PY{c+c1}{\PYZsh{} Collect debug information}
        \PY{p}{\PYZob{}}   \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{runtime}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{,}
            \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{limit}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n}{limit}\PY{p}{,}
            \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{visited}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{visited}\PY{p}{,}
            \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{max\PYZus{}states}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}states}\PY{p}{,}
            \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cache\PYZus{}hit}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}hit}\PY{p}{,}
            \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cache\PYZus{}invalid}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}invalid}\PY{p}{,}
            \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cache\PYZus{}miss}\PY{l+s+s2}{\PYZdq{}}\PY{p}{:} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cache\PYZus{}miss}\PY{p}{,}   \PY{p}{\PYZcb{}}
    \PY{p}{)}

\PY{n}{AlphaBetaPruning}\PY{o}{.}\PY{n}{bestMoves} \PY{o}{=} \PY{n}{bestMoves}
\PY{k}{del} \PY{n}{bestMoves}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
    
    
    

    
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktionen-fuxfcr-die-grafische-oberfluxe4che}{%
\section{Hilfsfunktionen fÃ¼r die grafische
OberflÃ¤che}\label{hilfsfunktionen-fuxfcr-die-grafische-oberfluxe4che}}

In diesem Notebook werden Hilfsfunktionen und Konstanten definiert, die
fÃ¼r das Zeichnen und Spielen auf der grafischen OberflÃ¤che benÃ¶tigt
werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{math}
\end{Verbatim}
\end{tcolorbox}

    Da das Spiel in der GUI in einem seperatem Thread lÃ¤uft, werden Fehler
oder Warnungen nicht in der Jupyter-Notebook geloggt. Deswegen wird zu
Debugzwecken ein Datei-Logger implementiert. Dieser wird im Rahmen der
Arbeit aber nicht weiter erlÃ¤utert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{logging}

\PY{n}{logger} \PY{o}{=} \PY{n}{logging}\PY{o}{.}\PY{n}{getLogger}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{GUI}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{logger}\PY{o}{.}\PY{n}{setLevel}\PY{p}{(}\PY{n}{logging}\PY{o}{.}\PY{n}{DEBUG}\PY{p}{)}
\PY{n}{fh} \PY{o}{=} \PY{n}{logging}\PY{o}{.}\PY{n}{FileHandler}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{log.txt}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{fh}\PY{o}{.}\PY{n}{setLevel}\PY{p}{(}\PY{n}{logging}\PY{o}{.}\PY{n}{DEBUG}\PY{p}{)}
\PY{n}{formatter} \PY{o}{=} \PY{n}{logging}\PY{o}{.}\PY{n}{Formatter}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZpc{}(asctime)s}\PY{l+s+s1}{ \PYZhy{} }\PY{l+s+si}{\PYZpc{}(levelname)s}\PY{l+s+s1}{ \PYZhy{} }\PY{l+s+si}{\PYZpc{}(message)s}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\PY{n}{fh}\PY{o}{.}\PY{n}{setFormatter}\PY{p}{(}\PY{n}{formatter}\PY{p}{)}
\PY{n}{logger}\PY{o}{.}\PY{n}{addHandler}\PY{p}{(}\PY{n}{fh}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{konstanten}{%
\subsection{Konstanten}\label{konstanten}}

Um eine einheitliche GUI zur VerfÃ¼gung zu stellen, die leicht zu warten
ist, werden im Folgenden einige Konstanten definiert.

    \hypertarget{spieler}{%
\subsubsection{Spieler}\label{spieler}}

Die Konstanten dienen dazu, die Strings der Spieler bzw. des leeren
Feldes zu definieren.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{NO\PYZus{}PLAYER} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}
\PY{n}{PLAYER\PYZus{}1} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{PLAYER\PYZus{}2} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{brett}{%
\subsubsection{Brett}\label{brett}}

In der Abbildung sind alle Konstanten fÃ¼r die ZeichenflÃ¤che angegeben,
um die Bedeutung der einzelnen Konstanten besser zeigen zu kÃ¶nnen.
ZusÃ¤tzlich sind in der Abbildung alle Farbkonstanten rotmarkiert.

\includegraphics{../images/nmm-constants.png}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{BOARD\PYZus{}SIZE} \PY{o}{=} \PY{l+m+mi}{500}
\PY{n}{CANVAS\PYZus{}PADDING} \PY{o}{=} \PY{l+m+mi}{30}
\PY{n}{ROW\PYZus{}WIDTH} \PY{o}{=} \PY{l+m+mi}{60}
\PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{=} \PY{l+m+mi}{12}
\PY{n}{DEFAULT\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{=} \PY{l+m+mi}{5}

\PY{n}{DEFAULT\PYZus{}STONE\PYZus{}LINE\PYZus{}WIDTH} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{SELECTED\PYZus{}STONE\PYZus{}LINE\PYZus{}WIDTH} \PY{o}{=} \PY{l+m+mi}{3}
\PY{n}{POUNDED\PYZus{}STONE\PYZus{}LINE\PYZus{}WIDTH} \PY{o}{=} \PY{l+m+mi}{5}

\PY{n}{STASH\PYZus{}STONES\PYZus{}SPACING} \PY{o}{=} \PY{l+m+mi}{5}

\PY{n}{STASH\PYZus{}HEIGHT} \PY{o}{=} \PY{p}{(}\PY{p}{(}\PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{*} \PY{l+m+mi}{2} \PY{p}{)} \PY{o}{*} \PY{l+m+mi}{2}\PY{p}{)} \PY{o}{+} \PY{p}{(}\PY{n}{STASH\PYZus{}STONES\PYZus{}SPACING}\PY{p}{)} \PY{o}{+} \PY{p}{(}\PY{n}{CANVAS\PYZus{}PADDING} \PY{o}{*} \PY{l+m+mi}{2}\PY{p}{)}
\PY{n}{STASH\PYZus{}WIDTH} \PY{o}{=} \PY{p}{(}\PY{p}{(}\PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{*} \PY{l+m+mi}{2} \PY{p}{)} \PY{o}{*} \PY{l+m+mi}{9}\PY{p}{)} \PY{o}{+} \PY{p}{(}\PY{n}{STASH\PYZus{}STONES\PYZus{}SPACING} \PY{o}{*} \PY{l+m+mi}{8}\PY{p}{)} \PY{o}{+} \PY{p}{(}\PY{n}{CANVAS\PYZus{}PADDING} \PY{o}{*} \PY{l+m+mi}{2}\PY{p}{)}

\PY{n}{CANVAS\PYZus{}HEIGHT} \PY{o}{=} \PY{n}{BOARD\PYZus{}SIZE}
\PY{n}{CANVAS\PYZus{}WIDTH} \PY{o}{=} \PY{l+m+mi}{1500}

\PY{n}{STASH\PYZus{}STARTING\PYZus{}POINT\PYZus{}X} \PY{o}{=} \PY{n}{BOARD\PYZus{}SIZE}
\PY{n}{STASH\PYZus{}STARTING\PYZus{}POINT\PYZus{}Y} \PY{o}{=} \PY{n}{CANVAS\PYZus{}HEIGHT} \PY{o}{\PYZhy{}} \PY{n}{STASH\PYZus{}HEIGHT}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{farben}{%
\subsubsection{Farben}\label{farben}}

Die Farben fÃ¼r das Spiel werden im Folgenden definiert. In der obigen
Abbildung sind diese genauer erklÃ¤rt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{CANVAS\PYZus{}BACKGROUND\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}ffffff}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{BOARD\PYZus{}FOREGROUND\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}191919}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{BOARD\PYZus{}BACKGROUND\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}ffffcb}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{STASH\PYZus{}BACKGROUND\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}dedede}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{PLAYER\PYZus{}1\PYZus{}FILL\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}E8E8E8}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{PLAYER\PYZus{}1\PYZus{}STROKE\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}191919}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{PLAYER\PYZus{}2\PYZus{}FILL\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}5c5c5c}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{PLAYER\PYZus{}2\PYZus{}STROKE\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}191919}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{LAST\PYZus{}MOVED\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}61aced}\PY{l+s+s1}{\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{text}{%
\subsubsection{Text}\label{text}}

In der GUI gibt es drei verschiedene Textarten:
\begin{itemize}
    \item Spielnachricht (wer spielt gerade oder ob das Spiel beendet ist),
    \item Hinweise (falls zum Beispiel eine ungÃ¼ltige Aktion ausgefÃ¼hrt worden ist) und - Informationen Ã¼ber den letzten Zug der kÃ¼nstlichen Intelligenz.
\end{itemize}

Diese Textarten haben eine eigene Schriftart, -grÃ¶Ãe und -farbe.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{TEXT\PYZus{}X} \PY{o}{=} \PY{n}{BOARD\PYZus{}SIZE} \PY{o}{+} \PY{n}{CANVAS\PYZus{}PADDING}
\PY{n}{TEXT\PYZus{}Y} \PY{o}{=} \PY{n}{CANVAS\PYZus{}PADDING}
\PY{n}{TEXT\PYZus{}MAX\PYZus{}WIDTH} \PY{o}{=} \PY{n}{CANVAS\PYZus{}WIDTH} \PY{o}{\PYZhy{}} \PY{n}{BOARD\PYZus{}SIZE} \PY{o}{\PYZhy{}} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{CANVAS\PYZus{}PADDING}
\PY{n}{TEXT\PYZus{}VERTICAL\PYZus{}PADDING} \PY{o}{=} \PY{l+m+mi}{30}
\PY{n}{TEXT\PYZus{}MSG\PYZus{}FONT} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{18px sans\PYZhy{}serif}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{TEXT\PYZus{}MSG\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}333333}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{TEXT\PYZus{}HINT\PYZus{}FONT} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{14px sans\PYZhy{}serif}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{TEXT\PYZus{}HINT\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}c75528}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{TEXT\PYZus{}INFO\PYZus{}FONT} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{14px mono}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{TEXT\PYZus{}INFO\PYZus{}COLOR} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}333333}\PY{l+s+s1}{\PYZsq{}}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{schatten}{%
\subsubsection{Schatten}\label{schatten}}

Um das Spiel dynamischer zu gestalten, haben Spielsteine einen Schatten.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{SHADOW\PYZus{}COLOR\PYZus{}ENABLED} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{\PYZsh{}000000}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{SHADOW\PYZus{}OFFSET\PYZus{}X\PYZus{}ENABLED} \PY{o}{=} \PY{l+m+mi}{2}
\PY{n}{SHADOW\PYZus{}OFFSET\PYZus{}Y\PYZus{}ENABLED} \PY{o}{=} \PY{l+m+mi}{2}
\PY{n}{SHADOW\PYZus{}BLUR\PYZus{}ENABLED} \PY{o}{=} \PY{l+m+mi}{2}

\PY{n}{SHADOW\PYZus{}COLOR\PYZus{}DISABLED} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{rgba(0, 0, 0, 0)}\PY{l+s+s1}{\PYZsq{}}
\PY{n}{SHADOW\PYZus{}OFFSET\PYZus{}X\PYZus{}DISABLED} \PY{o}{=} \PY{l+m+mi}{0}
\PY{n}{SHADOW\PYZus{}OFFSET\PYZus{}Y\PYZus{}DISABLED} \PY{o}{=} \PY{l+m+mi}{0}
\PY{n}{SHADOW\PYZus{}BLUR\PYZus{}DISABLED} \PY{o}{=} \PY{l+m+mi}{0}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{berechnete-werte}{%
\subsubsection{Berechnete Werte}\label{berechnete-werte}}

Die Koordinaten fÃ¼r die Knoten lassen sich aus den obrigen Konstanten
berechnen. Da das MÃ¼hlespielbrett horizontal und vertikal identisch ist,
werden fÃ¼r die Koordinaten auf der x- und y-Achse die gleichen Werte
benÃ¶tigt, die mit \(av\) (fÃ¼r \emph{available values}) bezeichnet
werden. Es werden insgesamt sieben Werte \(av_0\) bis \(av_6\) benÃ¶tigt,
die in der folgenden Abbildung dargestellt werden.

\includegraphics{../images/nmm-av.png}

Die Werte lassen sich wie folgt berechnen.

\[ av_0 =  CANVAS\_PADDING \] \[ av_1 =  CANVAS\_PADDING + ROW\_WIDTH \]
\[ av_2 =  CANVAS\_PADDING + 2 \cdot ROW\_WIDTH \]
\[ av_3 =  \frac{BOARD\_SIZE}{2}\]
\[ av_4 =  BOARD\_SIZE - (CANVAS\_PADDING + 2 \cdot ROW\_WIDTH) \]
\[ av_5 =  BOARD\_SIZE - (CANVAS\_PADDING + ROW\_WIDTH)\]
\[ av_6 =  BOARD\_SIZE - CANVAS\_PADDING \]

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{av} \PY{o}{=} \PY{p}{(}
    \PY{n}{math}\PY{o}{.}\PY{n}{floor}\PY{p}{(}\PY{n}{CANVAS\PYZus{}PADDING}\PY{p}{)}\PY{p}{,}
    \PY{n}{math}\PY{o}{.}\PY{n}{floor}\PY{p}{(}\PY{n}{CANVAS\PYZus{}PADDING} \PY{o}{+} \PY{n}{ROW\PYZus{}WIDTH}\PY{p}{)}\PY{p}{,}
    \PY{n}{math}\PY{o}{.}\PY{n}{floor}\PY{p}{(}\PY{n}{CANVAS\PYZus{}PADDING} \PY{o}{+} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{ROW\PYZus{}WIDTH}\PY{p}{)}\PY{p}{,}
    \PY{n}{math}\PY{o}{.}\PY{n}{floor}\PY{p}{(}\PY{n}{BOARD\PYZus{}SIZE} \PY{o}{/} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,}
    \PY{n}{math}\PY{o}{.}\PY{n}{floor}\PY{p}{(}\PY{n}{BOARD\PYZus{}SIZE} \PY{o}{\PYZhy{}} \PY{p}{(}\PY{n}{CANVAS\PYZus{}PADDING} \PY{o}{+} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{ROW\PYZus{}WIDTH}\PY{p}{)}\PY{p}{)}\PY{p}{,}
    \PY{n}{math}\PY{o}{.}\PY{n}{floor}\PY{p}{(}\PY{n}{BOARD\PYZus{}SIZE} \PY{o}{\PYZhy{}} \PY{p}{(}\PY{n}{CANVAS\PYZus{}PADDING} \PY{o}{+} \PY{n}{ROW\PYZus{}WIDTH}\PY{p}{)}\PY{p}{)}\PY{p}{,}
    \PY{n}{math}\PY{o}{.}\PY{n}{floor}\PY{p}{(}\PY{n}{BOARD\PYZus{}SIZE} \PY{o}{\PYZhy{}} \PY{n}{CANVAS\PYZus{}PADDING}\PY{p}{)}
\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{koordinaten}{%
\subsubsection{Koordinaten}\label{koordinaten}}

Die Koordinaten der Knoten sind in dem zweidimensionalen Tupel
\texttt{coords} definiert. Zuerst wird der Ring definiert, von auÃen
nach innen. Danach die Position im Ring, beginnend von oben links und
dann im Uhrzeigersinn. In der Abbildung sind die Knoten mit den
Koordinaten dargestellt. Die Werte von den Koordinaten sind die x- und
y-Werte auf der ZeichenflÃ¤che, definiert in \texttt{av}.

\includegraphics{../images/nmm-coords.png}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{coords} \PY{o}{=} \PY{p}{(}
    \PY{p}{(}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
    \PY{p}{)}\PY{p}{,}
    \PY{p}{(}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
    \PY{p}{)}\PY{p}{,}
    \PY{p}{(}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{)}\PY{p}{,}
        \PY{p}{(}\PY{n}{av}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n}{av}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
    \PY{p}{)}
\PY{p}{)} 
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{funktionen-zum-zeichnen}{%
\subsection{Funktionen zum Zeichnen}\label{funktionen-zum-zeichnen}}

Die grafische OberflÃ¤che (englisch \emph{graphical user interface}, GUI)
wird mit dem Python-Modul ipycanvas aufgebaut. Dieses Modul ermÃ¶glicht
die Verwendung einer interaktiven ZeichenflÃ¤che zum Zeichnen von
2D-Objekten in IPython. Es bringt eine Reihe von Funktionen mit, um
einfache Formen zeichnen zu kÃ¶nnen. Gezeichnet wird auf einem
2D-Canvas-Objekt mit den Startkoordinaten \texttt{(0,0)} oben links.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{ipycanvas}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{toggleShadow} schaltet den Schatten auf einem
gegebenen Canvas ein und aus. Sie hat folgende Eingabeparameter:

\begin{itemize}
\tightlist
\item
  \texttt{c} ist eine Referenz auf ein Canvas-Objekt.
\item
  \texttt{enable} ist ein boolischer Wert, der angibt, ob Schatten auf
  dem Canvas \texttt{c} ein oder ausgeschaltet werden soll.
\end{itemize}

Wird der Schatten eingeschaltet, werden die Schatteneigenschaften des
Canvas mit den oben definierten Konstanten gesetzt. Andernfalls werden
die Standardwerte von \emph{ipycanvas} gesetzt, was bedeutet, der
Schatten wird deaktiviert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{toggleShadow}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{enable}\PY{p}{)}\PY{p}{:}
    \PY{n}{c}\PY{o}{.}\PY{n}{shadow\PYZus{}color}    \PY{o}{=} \PY{n}{SHADOW\PYZus{}COLOR\PYZus{}ENABLED}    \PY{k}{if} \PY{n}{enable} \PY{k}{else} \PY{n}{SHADOW\PYZus{}COLOR\PYZus{}DISABLED}
    \PY{n}{c}\PY{o}{.}\PY{n}{shadow\PYZus{}offset\PYZus{}x} \PY{o}{=} \PY{n}{SHADOW\PYZus{}OFFSET\PYZus{}X\PYZus{}ENABLED} \PY{k}{if} \PY{n}{enable} \PY{k}{else} \PY{n}{SHADOW\PYZus{}OFFSET\PYZus{}X\PYZus{}DISABLED}
    \PY{n}{c}\PY{o}{.}\PY{n}{shadow\PYZus{}offset\PYZus{}y} \PY{o}{=} \PY{n}{SHADOW\PYZus{}OFFSET\PYZus{}Y\PYZus{}ENABLED} \PY{k}{if} \PY{n}{enable} \PY{k}{else} \PY{n}{SHADOW\PYZus{}OFFSET\PYZus{}Y\PYZus{}DISABLED}
    \PY{n}{c}\PY{o}{.}\PY{n}{shadow\PYZus{}blur}     \PY{o}{=} \PY{n}{SHADOW\PYZus{}BLUR\PYZus{}ENABLED}     \PY{k}{if} \PY{n}{enable} \PY{k}{else} \PY{n}{SHADOW\PYZus{}BLUR\PYZus{}DISABLED}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{drawCircle} dient zum Zeichnen eines Kreises auf
einem Zeichenfeld. Die Funktion hat vier Argumente und drei optionale
Parameter:

\begin{itemize}
\tightlist
\item
  \texttt{c} ist eine Referenz auf ein Canvas-Objekt, auf dem der Kreis
  gezeichnet werden soll.
\item
  \texttt{coords} ist die Koordinate des Mittelpunktes des Kreies.
\item
  \texttt{radius} ist der Radius des Kreises.
\item
  \texttt{color} gibt die Farbe des Kreises an.
\item
  \texttt{strokeColor} ist ein optionaler Parameter, der die Farbe der
  Umrandung angibt. Der Standardwert ist \texttt{None}. In dem Fall wird
  der Kreis nicht umrandet.
\item
  \texttt{lineWidth} ist ein optionaler Parameter, der die Liniendicke
  angibt. Der Standardwert ist in der Kontante
  \texttt{DEFAULT\_STONE\_LINE\_WIDTH} definiert.
\item
  \texttt{useShadow} ist ein optionaler, boolischer Wert. Wenn er
  gesetzt ist, wird ein Schatten von dem Kreis gemalt. StandardmÃ¤Ãig ist
  der Wert \texttt{False}.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{drawCircle}\PY{p}{(}
        \PY{n}{c}\PY{p}{,}
        \PY{n}{coords}\PY{p}{,}
        \PY{n}{radius}\PY{p}{,}
        \PY{n}{color}\PY{p}{,}
        \PY{n}{strokeColor} \PY{o}{=} \PY{k+kc}{None}\PY{p}{,}
        \PY{n}{lineWidth} \PY{o}{=} \PY{n}{DEFAULT\PYZus{}STONE\PYZus{}LINE\PYZus{}WIDTH}\PY{p}{,}
        \PY{n}{useShadow} \PY{o}{=} \PY{k+kc}{False}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{useShadow}\PY{p}{:}
        \PY{n}{toggleShadow}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{k+kc}{True}\PY{p}{)}
    \PY{n}{c}\PY{o}{.}\PY{n}{fill\PYZus{}style} \PY{o}{=} \PY{n}{color}
    \PY{n}{c}\PY{o}{.}\PY{n}{fill\PYZus{}arc}\PY{p}{(}\PY{n}{coords}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{coords}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{radius}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{math}\PY{o}{.}\PY{n}{pi}\PY{p}{)}
    \PY{k}{if} \PY{n}{useShadow}\PY{p}{:}
        \PY{n}{toggleShadow}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{k+kc}{False}\PY{p}{)}
    \PY{k}{if} \PY{n}{strokeColor} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{c}\PY{o}{.}\PY{n}{line\PYZus{}width} \PY{o}{=} \PY{n}{lineWidth}
        \PY{n}{c}\PY{o}{.}\PY{n}{stroke\PYZus{}style} \PY{o}{=} \PY{n}{strokeColor}
        \PY{n}{c}\PY{o}{.}\PY{n}{stroke\PYZus{}arc}\PY{p}{(}\PY{n}{coords}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{coords}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{radius}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{math}\PY{o}{.}\PY{n}{pi}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{drawStone} dient zum Zeichnen eines Steines auf
einem Zeichenfeld mit Hilfe der Funktion \texttt{drawCircle}. Ein
Spielstein besteht aus zwei Kreisen und ein leerer Knoten (also wo sich
kein Spieler befinden) aus einem Kreis.

Die Funktion hat drei Argumente und zwei optionale Parameter:

\begin{itemize}
\tightlist
\item
  \texttt{c} ist eine Referenz auf ein Canvas-Objekt, auf dem der Stein
  gezeichnet werden soll;
\item
  \texttt{coords} ist die Koordinate des Mittelpunktes des Steines;
\item
  \texttt{player} gibt den Spieler an;
\item
  \texttt{selected} ist ein optionaler, boolischer Wert, der angibt, ob
  ein Spielerstein ausgewÃ¤hlt ist oder nicht. Der Standardwert ist
  \texttt{False};
\item
  \texttt{lastMoved} ist ein optionaler, boolischer Wert, der angibt ob
  der zu zeichnende Spielerstein zuletzt bewegt worden ist. Der
  Standardwert ist \texttt{False}.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{drawStone}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{coords}\PY{p}{,} \PY{n}{player}\PY{p}{,} \PY{n}{selected} \PY{o}{=} \PY{k+kc}{False}\PY{p}{,} \PY{n}{lastMoved} \PY{o}{=} \PY{k+kc}{False}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{n}{NO\PYZus{}PLAYER}\PY{p}{:}
        \PY{n}{drawCircle}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{coords}\PY{p}{,} \PY{n}{DEFAULT\PYZus{}PIECE\PYZus{}RADIUS}\PY{p}{,} \PY{n}{BOARD\PYZus{}FOREGROUND\PYZus{}COLOR}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{color}       \PY{o}{=} \PY{n}{PLAYER\PYZus{}1\PYZus{}FILL\PYZus{}COLOR}   \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}1} \PY{k}{else} \PY{n}{PLAYER\PYZus{}2\PYZus{}FILL\PYZus{}COLOR}
        \PY{n}{strokeColor} \PY{o}{=} \PY{n}{PLAYER\PYZus{}1\PYZus{}STROKE\PYZus{}COLOR} \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}1} \PY{k}{else} \PY{n}{PLAYER\PYZus{}2\PYZus{}STROKE\PYZus{}COLOR}
        
        \PY{n}{lineWidth} \PY{o}{=} \PY{n}{SELECTED\PYZus{}STONE\PYZus{}LINE\PYZus{}WIDTH} \PY{k}{if} \PY{n}{selected} \PY{k}{else} \PY{n}{DEFAULT\PYZus{}STONE\PYZus{}LINE\PYZus{}WIDTH}
        \PY{n}{drawCircle}\PY{p}{(}
            \PY{n}{c}\PY{p}{,}
            \PY{n}{coords}\PY{p}{,}
            \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS}\PY{p}{,}
            \PY{n}{LAST\PYZus{}MOVED\PYZus{}COLOR} \PY{k}{if} \PY{n}{lastMoved} \PY{k}{else} \PY{n}{color}\PY{p}{,}
            \PY{n}{strokeColor}\PY{p}{,}
            \PY{n}{lineWidth}\PY{p}{,}
            \PY{n}{useShadow} \PY{o}{=} \PY{k+kc}{True}\PY{p}{)}
        \PY{n}{drawCircle}\PY{p}{(}
            \PY{n}{c}\PY{p}{,}
            \PY{n}{coords}\PY{p}{,}
            \PY{n}{math}\PY{o}{.}\PY{n}{floor}\PY{p}{(}\PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{/} \PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,}
            \PY{n}{color}\PY{p}{,}
            \PY{n}{strokeColor}\PY{p}{,}
            \PY{n}{lineWidth}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{drawPoundedStone} dient zum Zeichnen eines
geschlagenden Steines auf einem Zeichenfeld. Ein geschlagender Stein
wird durch ein Kreuz in der GUI dargestellt.

Die Funktion hat drei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{c} ist eine Referenz auf ein Canvas-Objekt, auf dem der
  geschlagende Stein gezeichnet werden soll;
\item
  \texttt{coords} ist die Koordinate des Mittelpunktes des geschlagenden
  Steines;
\item
  \texttt{player} gibt den Spieler des Steines an.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{drawPoundedStone}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{coords}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{:}
    \PY{n}{x}\PY{p}{,} \PY{n}{y} \PY{o}{=} \PY{n}{coords}
    \PY{n}{offset} \PY{o}{=} \PY{n+nb}{int}\PY{p}{(}\PY{n}{math}\PY{o}{.}\PY{n}{sin}\PY{p}{(}\PY{l+m+mf}{0.25}\PY{o}{*}\PY{n}{math}\PY{o}{.}\PY{n}{pi}\PY{p}{)} \PY{o}{*} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS}\PY{p}{)}
    \PY{n}{c}\PY{o}{.}\PY{n}{line\PYZus{}width} \PY{o}{=} \PY{n}{POUNDED\PYZus{}STONE\PYZus{}LINE\PYZus{}WIDTH}
    \PY{n}{c}\PY{o}{.}\PY{n}{stroke\PYZus{}style} \PY{o}{=} \PY{n}{PLAYER\PYZus{}1\PYZus{}FILL\PYZus{}COLOR}   \PY{k}{if} \PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}1} \PY{k}{else} \PY{n}{PLAYER\PYZus{}2\PYZus{}FILL\PYZus{}COLOR}
    \PY{k}{with} \PY{n}{ipycanvas}\PY{o}{.}\PY{n}{hold\PYZus{}canvas}\PY{p}{(}\PY{n}{c}\PY{p}{)}\PY{p}{:}
        \PY{n}{c}\PY{o}{.}\PY{n}{stroke\PYZus{}line}\PY{p}{(}\PY{n}{x} \PY{o}{\PYZhy{}} \PY{n}{offset}\PY{p}{,} \PY{n}{y} \PY{o}{\PYZhy{}} \PY{n}{offset}\PY{p}{,} \PY{n}{x} \PY{o}{+} \PY{n}{offset}\PY{p}{,} \PY{n}{y} \PY{o}{+} \PY{n}{offset}\PY{p}{)}
        \PY{n}{c}\PY{o}{.}\PY{n}{stroke\PYZus{}line}\PY{p}{(}\PY{n}{x} \PY{o}{\PYZhy{}} \PY{n}{offset}\PY{p}{,} \PY{n}{y} \PY{o}{+} \PY{n}{offset}\PY{p}{,} \PY{n}{x} \PY{o}{+} \PY{n}{offset}\PY{p}{,} \PY{n}{y} \PY{o}{\PYZhy{}} \PY{n}{offset}\PY{p}{)}
    
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{drawText} zeichnet einen Text auf einer
ZeichenflÃ¤che. Die Funktion hat zwei Argumente und zwei optionale
Parameter:

\begin{itemize}
\tightlist
\item
  \texttt{c} ist eine Referenz auf ein Canvas-Objekt, auf dem der Text
  gezeichnet werden soll.
\item
  \texttt{msg} ist die Nachricht, die auf dem Canvas geschrieben werden
  soll.
\item
  \texttt{hint} ist ein optionaler String, der ein Hinweis oder eine
  Warnung ist. StandardmÃ¤Ãig ist die Variable auf \texttt{None} gesetzt.
\item
  \texttt{information} ist ein optionales Dictionary. Alle EintrÃ¤ge des
  Dictionaries werden als Information auf dem Zeichenfeld ausgegeben.
\end{itemize}

Bei jedem Funktionsaufruf wird am Anfang der Inhalt der ZeichenflÃ¤che
gelÃ¶scht, sodass sich immer nur eine Version der Texte auf der
ZeichenflÃ¤che befindet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{drawText}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{msg}\PY{p}{,} \PY{n}{hint} \PY{o}{=} \PY{k+kc}{None}\PY{p}{,} \PY{n}{information} \PY{o}{=} \PY{k+kc}{None}\PY{p}{)}\PY{p}{:}
    \PY{k}{with} \PY{n}{ipycanvas}\PY{o}{.}\PY{n}{hold\PYZus{}canvas}\PY{p}{(}\PY{n}{c}\PY{p}{)}\PY{p}{:}
        \PY{n}{c}\PY{o}{.}\PY{n}{clear}\PY{p}{(}\PY{p}{)}
        \PY{n}{y} \PY{o}{=} \PY{n}{TEXT\PYZus{}Y}
        \PY{n}{c}\PY{o}{.}\PY{n}{font} \PY{o}{=} \PY{n}{TEXT\PYZus{}MSG\PYZus{}FONT}
        \PY{n}{c}\PY{o}{.}\PY{n}{fill\PYZus{}style} \PY{o}{=} \PY{n}{TEXT\PYZus{}MSG\PYZus{}COLOR}
        \PY{n}{c}\PY{o}{.}\PY{n}{fill\PYZus{}text}\PY{p}{(}\PY{n}{msg}\PY{p}{,} \PY{n}{TEXT\PYZus{}X}\PY{p}{,} \PY{n}{y}\PY{p}{,} \PY{n}{max\PYZus{}width} \PY{o}{=} \PY{n}{TEXT\PYZus{}MAX\PYZus{}WIDTH}\PY{p}{)}
        \PY{n}{y} \PY{o}{+}\PY{o}{=} \PY{n}{TEXT\PYZus{}VERTICAL\PYZus{}PADDING}
        \PY{k}{if} \PY{n}{hint} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{n}{c}\PY{o}{.}\PY{n}{font} \PY{o}{=} \PY{n}{TEXT\PYZus{}HINT\PYZus{}FONT}
            \PY{n}{c}\PY{o}{.}\PY{n}{fill\PYZus{}style} \PY{o}{=} \PY{n}{TEXT\PYZus{}HINT\PYZus{}COLOR}
            \PY{n}{c}\PY{o}{.}\PY{n}{fill\PYZus{}text}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Hint: }\PY{l+s+s1}{\PYZsq{}} \PY{o}{+} \PY{n}{hint}\PY{p}{,} \PY{n}{TEXT\PYZus{}X}\PY{p}{,} \PY{n}{y}\PY{p}{,} \PY{n}{max\PYZus{}width} \PY{o}{=} \PY{n}{TEXT\PYZus{}MAX\PYZus{}WIDTH}\PY{p}{)}
            \PY{n}{y} \PY{o}{+}\PY{o}{=} \PY{n}{TEXT\PYZus{}VERTICAL\PYZus{}PADDING}
        \PY{k}{if} \PY{n}{information} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{n}{c}\PY{o}{.}\PY{n}{font} \PY{o}{=} \PY{n}{TEXT\PYZus{}INFO\PYZus{}FONT}
            \PY{n}{c}\PY{o}{.}\PY{n}{fill\PYZus{}style} \PY{o}{=} \PY{n}{TEXT\PYZus{}INFO\PYZus{}COLOR}
            \PY{n}{c}\PY{o}{.}\PY{n}{fill\PYZus{}text}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Information from last move:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{TEXT\PYZus{}X}\PY{p}{,} \PY{n}{y}\PY{p}{,} \PY{n}{max\PYZus{}width} \PY{o}{=} \PY{n}{TEXT\PYZus{}MAX\PYZus{}WIDTH}\PY{p}{)}
            \PY{n}{y} \PY{o}{+}\PY{o}{=} \PY{n}{TEXT\PYZus{}VERTICAL\PYZus{}PADDING}
            \PY{k}{for} \PY{p}{(}\PY{n}{key}\PY{p}{,} \PY{n}{value}\PY{p}{)} \PY{o+ow}{in} \PY{n}{information}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
                \PY{n}{c}\PY{o}{.}\PY{n}{fill\PYZus{}text}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{   }\PY{l+s+si}{\PYZob{}}\PY{n}{key}\PY{o}{.}\PY{n}{ljust}\PY{p}{(}\PY{l+m+mi}{16}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ }\PY{l+s+si}{\PYZob{}}\PY{n}{value}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{TEXT\PYZus{}X}\PY{p}{,} \PY{n}{y}\PY{p}{,} \PY{n}{max\PYZus{}width} \PY{o}{=} \PY{n}{TEXT\PYZus{}MAX\PYZus{}WIDTH}\PY{p}{)}
                \PY{n}{y} \PY{o}{+}\PY{o}{=} \PY{n}{TEXT\PYZus{}VERTICAL\PYZus{}PADDING}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{constructLine} dient zum Konstruieren einer Linie
auf einem Zeichenfeld. Die Funktion hat drei Eingabeparameter:

\begin{itemize}
\tightlist
\item
  \texttt{c} ist eine Referenz auf ein Canvas-Objekt, auf dem die Linie
  gezeichnet werden soll.
\item
  \texttt{start} ist die Koordinate des Startpunktes der Linie.
\item
  \texttt{end} ist die Koordinate des Endpunktes der Linie.
\end{itemize}

Die Funktion aktualisiert einen Pfad auf dem Zeichenfeld, aber sie
zeichnet noch nicht den aktualisierten Pfad.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{constructLine}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{start}\PY{p}{,} \PY{n}{end}\PY{p}{)}\PY{p}{:}
    \PY{n}{c}\PY{o}{.}\PY{n}{move\PYZus{}to}\PY{p}{(}\PY{n}{start}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{start}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
    \PY{n}{c}\PY{o}{.}\PY{n}{line\PYZus{}to}\PY{p}{(}\PY{n}{end}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{end}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{constructSquare} konstruiert ein Quadrat auf einer
ZeichenflÃ¤che und lÃ¤sst es mit Hilfe der Funktion \texttt{constructLine}
zeichnen. Die Funktion hat zwei Eingabeargumente:

\begin{itemize}
\tightlist
\item
  \texttt{c} ist eine Referenz auf ein Canvas-Objekt, auf dem das
  Quadrat gezeichnet werden soll.
\item
  \texttt{ring} ist ein Acht-Tupel, das die Koordinaten eines Ringes
  enthÃ¤lt.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{constructSquare}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{ring}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{:}
        \PY{n}{start} \PY{o}{=} \PY{n}{i} \PY{o}{*} \PY{l+m+mi}{2}
        \PY{n}{end} \PY{o}{=} \PY{p}{(}\PY{n}{i} \PY{o}{*} \PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{2}\PY{p}{)} \PY{k}{if} \PY{p}{(}\PY{n}{i} \PY{o}{*} \PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{2} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{6}\PY{p}{)} \PY{k}{else} \PY{l+m+mi}{0} 
        \PY{n}{constructLine}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{ring}\PY{p}{[}\PY{n}{start}\PY{p}{]}\PY{p}{,} \PY{n}{ring}\PY{p}{[}\PY{n}{end}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{constructCrossLines} konstruiert die Querlinien des
MÃ¼hlespiels auf einer ZeichenflÃ¤che und lÃ¤sst es mit Hilfe der Funktion
\texttt{constructLine} zeichnen. Die Funktion hat zwei Eingabeargumente:

\begin{itemize}
\tightlist
\item
  \texttt{c} ist eine Referenz auf ein Canvas-Objekt, auf dem die
  Querlinien gezeichnet werden sollen.
\item
  \texttt{coords} ist ein zweidimensionales Tupel, welches alle
  Koordinaten des Spielbrettes enthÃ¤lt (vgl. das Kapitel
  \emph{Koordinaten} in der GUI).
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{constructCrossLines}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{coords}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{:}
        \PY{n}{k} \PY{o}{=} \PY{n}{i} \PY{o}{*} \PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{1}
        \PY{n}{constructLine}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{coords}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{n}{k}\PY{p}{]}\PY{p}{,} \PY{n}{coords}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{[}\PY{n}{k}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{setupCanvas} erstellt das Canvas-Objekt und
zeichnet den Hintergrund des Spielfeldes. Die Funktion hat keine
Eingabeparameter und gibt eine Referenz auf das erstellte Canvas-Objekt
zurÃ¼ck.

Die ZeichenflÃ¤che besteht aus einem MultiCanvas-Objekt mit drei Ebenen:

\begin{itemize}
\tightlist
\item
  Der Hintergrund, der das Spielbrett mit den Linien darstellt;
\item
  Auf der zweiten Ebene wird der Text fÃ¼r das Spiel geschrieben;
\item
  Die Spielsteine werden auf der obersten Ebene gezeichnet.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{setupCanvas}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{n}{canvas} \PY{o}{=} \PY{n}{ipycanvas}\PY{o}{.}\PY{n}{MultiCanvas}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{width} \PY{o}{=} \PY{n}{CANVAS\PYZus{}WIDTH}\PY{p}{,} \PY{n}{height} \PY{o}{=} \PY{n}{CANVAS\PYZus{}HEIGHT}\PY{p}{)}
    \PY{k}{with} \PY{n}{ipycanvas}\PY{o}{.}\PY{n}{hold\PYZus{}canvas}\PY{p}{(}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{p}{:}
        
        \PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{fill\PYZus{}style} \PY{o}{=} \PY{n}{CANVAS\PYZus{}BACKGROUND\PYZus{}COLOR}
        \PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{fill\PYZus{}rect}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{n}{CANVAS\PYZus{}WIDTH}\PY{p}{,} \PY{n}{CANVAS\PYZus{}HEIGHT}\PY{p}{)}
        
        \PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{fill\PYZus{}style} \PY{o}{=} \PY{n}{BOARD\PYZus{}BACKGROUND\PYZus{}COLOR}
        \PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{fill\PYZus{}rect}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{0}\PY{p}{,} \PY{n}{BOARD\PYZus{}SIZE}\PY{p}{,} \PY{n}{BOARD\PYZus{}SIZE}\PY{p}{)}

        \PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{fill\PYZus{}style} \PY{o}{=} \PY{n}{STASH\PYZus{}BACKGROUND\PYZus{}COLOR}
        \PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{fill\PYZus{}rect}\PY{p}{(}\PY{n}{STASH\PYZus{}STARTING\PYZus{}POINT\PYZus{}X}\PY{p}{,} \PY{n}{STASH\PYZus{}STARTING\PYZus{}POINT\PYZus{}Y}\PY{p}{,} \PY{n}{STASH\PYZus{}WIDTH}\PY{p}{,} \PY{n}{STASH\PYZus{}HEIGHT}\PY{p}{)}


        \PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{stroke\PYZus{}style} \PY{o}{=} \PY{n}{BOARD\PYZus{}FOREGROUND\PYZus{}COLOR}
        \PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{begin\PYZus{}path}\PY{p}{(}\PY{p}{)}

        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{:}
            \PY{n}{constructSquare}\PY{p}{(}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{coords}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}

        \PY{n}{constructCrossLines}\PY{p}{(}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{coords}\PY{p}{)}
        \PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{.}\PY{n}{stroke}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{return} \PY{n}{canvas}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{updateGui} dient zum Aktualisieren der
ZeichenflÃ¤che fÃ¼r einen gegebenen Spielzustand. Die Funktion hat zwei
Argumente und drei optionale Parameter:

\begin{itemize}
\tightlist
\item
  \texttt{c} ist eine Referenz auf ein Canvas-Objekt;
\item
  \texttt{state} ist der Spielzustand, der in der GUI angezeigt werden
  soll;
\item
  \texttt{selectedStone} ist eine Koordinate von einem selektierten
  Stein. Der Standardwert ist \texttt{None}. Ist in der Phase 2 oder 3
  ein Stein auswÃ¤hlt, kann er mit diesem optionalen Parameter auf der
  ZeichenflÃ¤che hervorgehoben werden;
\item
  \texttt{movedStone} ist die Koordinate des zuletzt bewegten Steins, um
  diesen in der GUI entsprechend zu markieren. Der Standardwert ist
  \texttt{None}, was bedeutet, das kein Stein bewegt worden ist;
\item
  \texttt{poundedStones} ist eine Menge von den geschlagenden Steinen
  des Gegenspielers. Diese werden in der GUI als ein Kreuz dargestellt.
  StandardmÃ¤Ãig ist \texttt{poundedStones} eine leere Menge, was
  bedeutet, das kein Stein geschlagen worden ist.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{updateGui}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{state}\PY{p}{,} \PY{n}{selectedStone} \PY{o}{=} \PY{k+kc}{None}\PY{p}{,} \PY{n}{movedStone} \PY{o}{=} \PY{k+kc}{None}\PY{p}{,} \PY{n}{poundedStones} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{:}
    \PY{k}{with} \PY{n}{ipycanvas}\PY{o}{.}\PY{n}{hold\PYZus{}canvas}\PY{p}{(}\PY{n}{c}\PY{p}{)}\PY{p}{:}
        \PY{n}{c}\PY{o}{.}\PY{n}{clear}\PY{p}{(}\PY{p}{)}
        \PY{p}{(}\PY{p}{(}\PY{n}{stashP1}\PY{p}{,} \PY{n}{stashP2}\PY{p}{)}\PY{p}{,} \PY{n}{squares}\PY{p}{)} \PY{o}{=} \PY{n}{state}

        \PY{c+c1}{\PYZsh{} update pieces on the board}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{squares}\PY{p}{)}\PY{p}{)}\PY{p}{:}
            \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{squares}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{:}
                \PY{n}{drawStone}\PY{p}{(}
                    \PY{n}{c}\PY{p}{,}
                    \PY{n}{coords}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{p}{,}
                    \PY{n}{squares}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{p}{,}
                    \PY{n}{selected} \PY{o}{=} \PY{n}{selectedStone} \PY{o}{==} \PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{j}\PY{p}{)}\PY{p}{,}
                    \PY{n}{lastMoved} \PY{o}{=} \PY{n}{movedStone} \PY{o}{==} \PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{j}\PY{p}{)}\PY{p}{)}

        \PY{k}{for} \PY{p}{(}\PY{n}{player}\PY{p}{,} \PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{j}\PY{p}{)}\PY{p}{)} \PY{o+ow}{in} \PY{n}{poundedStones}\PY{p}{:}
            \PY{n}{drawPoundedStone}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{n}{coords}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{p}{,} \PY{n}{player}\PY{p}{)}
            
        \PY{c+c1}{\PYZsh{} update pieces on the stash}

        \PY{c+c1}{\PYZsh{} player 1}

        \PY{n}{x} \PY{o}{=} \PY{n}{STASH\PYZus{}STARTING\PYZus{}POINT\PYZus{}X} \PY{o}{+} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS}
        \PY{n}{y} \PY{o}{=} \PY{n}{STASH\PYZus{}STARTING\PYZus{}POINT\PYZus{}Y} \PY{o}{+} \PY{n}{CANVAS\PYZus{}PADDING} \PY{o}{+} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS}

        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{stashP1}\PY{p}{)}\PY{p}{:}
            \PY{n}{x} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{+} \PY{n}{STASH\PYZus{}STONES\PYZus{}SPACING}
            \PY{n}{drawStone}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{n}{PLAYER\PYZus{}1}\PY{p}{)}

        \PY{c+c1}{\PYZsh{} player 2}

        \PY{n}{x} \PY{o}{=} \PY{n}{STASH\PYZus{}STARTING\PYZus{}POINT\PYZus{}X} \PY{o}{+} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS}
        \PY{n}{y} \PY{o}{=} \PY{n}{STASH\PYZus{}STARTING\PYZus{}POINT\PYZus{}Y} \PY{o}{+} \PY{n}{CANVAS\PYZus{}PADDING} \PY{o}{+} \PY{l+m+mi}{3} \PY{o}{*} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{+} \PY{n}{STASH\PYZus{}STONES\PYZus{}SPACING}

        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{stashP2}\PY{p}{)}\PY{p}{:}
            \PY{n}{x} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{2} \PY{o}{*} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{+} \PY{n}{STASH\PYZus{}STONES\PYZus{}SPACING}
            \PY{n}{drawStone}\PY{p}{(}\PY{n}{c}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{n}{PLAYER\PYZus{}2}\PY{p}{)}
    
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{hilfsfunktionen-fuxfcr-das-spielen-in-der-gui}{%
\subsection{Hilfsfunktionen fÃ¼r das Spielen in der
GUI}\label{hilfsfunktionen-fuxfcr-das-spielen-in-der-gui}}

In diesem Kapitel werden Funktionen deklariert, die Hilfsfunktionen fÃ¼r
die GUI darstellen, aber unabhÃ¤ngig von dem eigentlichen Spielzustand
sind.

ZusÃ¤tzlich werden die Jupyter-Notebooks von dem Minimax- und
Alpha-Beta-Pruning-Algorithmus benÃ¶tigt und hier ausfÃ¼hrt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}minimax.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}alpha\PYZhy{}beta\PYZhy{}pruning.ipynb
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{getClickedStone} dient zum Ermitteln, ob auf der
ZeichenflÃ¤che eine Ecke angeklickt worden ist, auf dem ein Stein stehen
kann. Die Funktion hat zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{x} fÃ¼r den Wert auf der horizontalen Achse;
\item
  \texttt{y} fÃ¼r den Wert auf der vertikalen Achse.
\end{itemize}

Es mÃ¼ssen nicht die genauen Werte fÃ¼r x und y angeklickt werden, sondern
es gibt einen Puffer in HÃ¶he des Radius von einem Spielerstein. Falls
eine Position fÃ¼r einen Stein angeklickt worden ist, fÃ¼r die jeweilige
Koordinate aus dem \texttt{coords}-Tupel zurÃ¼ckgegeben. Falls keine
Position gefunden worden ist, wird \texttt{None} zurÃ¼ckgegeben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{getClickedStone}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{value} \PY{o+ow}{in} \PY{n}{av}\PY{p}{:}
        \PY{k}{if} \PY{n}{value} \PY{o}{\PYZhy{}} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{x} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{value} \PY{o}{+} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS}\PY{p}{:}
            \PY{n}{x} \PY{o}{=} \PY{n}{value}
        \PY{k}{if} \PY{n}{value} \PY{o}{\PYZhy{}} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{y} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{n}{value} \PY{o}{+} \PY{n}{PLAYER\PYZus{}PIECE\PYZus{}RADIUS}\PY{p}{:}
            \PY{n}{y} \PY{o}{=} \PY{n}{value}

    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{coords}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{coords}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{:}
            \PY{k}{if} \PY{n}{coords}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{j}\PY{p}{]} \PY{o}{==} \PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}\PY{p}{:}
                \PY{k}{return} \PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{j}\PY{p}{)}
    \PY{k}{return} \PY{k+kc}{None}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{getChangedStones} ermittelt den zuletzt bewegten
Stein eines Spielers und alle geschlagenden Steine des Gegenspielers
zwischen zwei ZustÃ¤nden. Die Funktion hat drei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{oldState} ist der Ausgangszustand;
\item
  \texttt{newState} ist der neue Zustand;
\item
  \texttt{player} ist der Spieler, den den Zug gespielt hat.
\end{itemize}

Die Funktion gibt ein Zwei-Tupel der Form
\texttt{\textless{}movedStone,\ poundedStones\textgreater{}} mit
\begin{enumerate}
    \item \texttt{movedStone} ist die Koordinate des bewegten Steins des Spielers;
    \item \texttt{poundedStones} ist eine Menge von Zwei-Tupeln der Form \texttt{\textless{}op,\ coord\textgreater{}} mit
    \item \texttt{op} ist der Gegenspieler;
    \item \texttt{coord} ist die Koordinate des geschlagenden Steines;
\end{enumerate}

zurÃ¼ck.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{getChangedStones}\PY{p}{(}\PY{n}{oldState}\PY{p}{,} \PY{n}{newState}\PY{p}{,} \PY{n}{player}\PY{p}{)}\PY{p}{:}
    \PY{p}{(}\PY{n}{\PYZus{}}\PY{p}{,} \PY{n}{oldBoard}\PY{p}{)} \PY{o}{=} \PY{n}{oldState}
    \PY{p}{(}\PY{n}{\PYZus{}}\PY{p}{,} \PY{n}{newBoard}\PY{p}{)} \PY{o}{=} \PY{n}{newState}
    \PY{n}{op} \PY{o}{=} \PY{n}{opponent}\PY{p}{(}\PY{n}{player}\PY{p}{)}
    \PY{n}{movedStone} \PY{o}{=} \PY{k+kc}{None}\PY{p}{;}
    \PY{n}{poundedStones} \PY{o}{=} \PY{n+nb}{set}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{oldBoard}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{oldBoard}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}\PY{p}{)}\PY{p}{:}
            \PY{k}{if} \PY{n}{oldBoard}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{j}\PY{p}{]} \PY{o}{!=} \PY{n}{newBoard}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{j}\PY{p}{]}\PY{p}{:}
                \PY{k}{if} \PY{n}{newBoard}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{j}\PY{p}{]} \PY{o}{==} \PY{n}{player}\PY{p}{:}
                    \PY{n}{movedStone} \PY{o}{=} \PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{j}\PY{p}{)}
                \PY{k}{if} \PY{n}{oldBoard}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{[}\PY{n}{j}\PY{p}{]} \PY{o}{==} \PY{n}{op}\PY{p}{:}
                    \PY{n}{poundedStones} \PY{o}{|}\PY{o}{=} \PY{p}{\PYZob{}} \PY{p}{(}\PY{n}{op}\PY{p}{,} \PY{p}{(}\PY{n}{i}\PY{p}{,} \PY{n}{j}\PY{p}{)}\PY{p}{)} \PY{p}{\PYZcb{}}
    \PY{k}{return} \PY{p}{(}\PY{n}{movedStone}\PY{p}{,} \PY{n}{poundedStones}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
    
    
    

    
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{grafische-oberfluxe4che}{%
\section{Grafische OberflÃ¤che}\label{grafische-oberfluxe4che}}

In diesem Notebook ist das Spielen in der GUI implementiert. Die
Hilfsfunktionen sind in dem Notebook nmm-game-utils definiert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}gui\PYZhy{}utils.ipynb
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{klasse-gamestate}{%
\subsection{Klasse GameState}\label{klasse-gamestate}}

Die Klasse \texttt{GameState} dient zum Spielen und Verwalten von einem
MÃ¼hle-Spiel in der GUI.

Der Konstruktur der Klasse hat elf Eingabeparameter, die alle optional
sind:
\begin{itemize}
    \item \texttt{state} ist der Startzustand fÃ¼r das Spiel. StandardmÃ¤Ãig wird das Spiel mit \texttt{s0} gestartet, welches ein leeres Spielfeld darstellt;
    \item \texttt{player} definiert den Spieler, der den ersten Zug spielt. StandardmÃ¤Ãig wird das Spiel mit dem weiÃen Spieler (\texttt{w}) gestartet;
    \item \texttt{algorithm1} definiert, ob und welcher Algorithmus fÃ¼r den weiÃen Spieler spielt. StandardmÃ¤Ãig wird der Spieler von einem Menschen gespielt (\texttt{None}). FÃ¼r \emph{$\alpha$-$\beta$-Pruning} ist eine Instanz der Klasse \texttt{AlphaBetaPruning} zu Ã¼bergeben und fÃ¼r \emph{Minimax} eine Instanz der Klasse \texttt{Minimax}.
    \item \texttt{algorithm2} definiert, ob und welcher Algorithmus fÃ¼r den schwarzen Spieler spielt. StandardmÃ¤Ãig wird der Spieler von einem Menschen gespielt (\texttt{None}). FÃ¼r \emph{$\alpha$-$\beta$-Pruning} ist eine Instanz der Klasse \texttt{AlphaBetaPruning} zu Ã¼bergeben und fÃ¼r \emph{Minimax} eine Instanz der Klasse \texttt{Minimax}.
    \item \texttt{timeout} definiert einen Timeout in Sekunden, der nach einem Computer-Zug gesetzt wird. Dies dient dazu, die Ãbersichtlichkeit zu erhÃ¶hen, wenn Computer gegen Computer spielt. StandardmÃ¤Ãig gibt es keinen Timeout (\texttt{None});
    \item \texttt{stepwise} ist ein boolischer Wert und gibt an, ob das Spiel bei Computer gegen Computer im Einzelschrittmodus gespielt wird. Das bedeutet, nach jedem Computerzug muss der nÃ¤chste Computerzug manuell begonnen werden. StandardmÃ¤Ãig ist der Einzelschrittmodus deaktiviert (\texttt{False});
    \item \texttt{limitMovesWithoutMill} ist eine Ganzzahl, die angibt, wie viele ZÃ¼ge ohne geschlagende MÃ¼hle gespielt werden kÃ¶nnen. Ist das Limit Ã¼berschritten, endet das Spiel in einem Unentschieden. Der Standardwert ist \texttt{30}. Um dieses Limit auszuschalten, muss der Wert auf \texttt{None} gesetzt werden;
    \item \texttt{limitStatesCounter} ist eine Ganzzahl, die angibt, wie oft ein gleicher Zustand gespielt werden kann. Ist das Limit Ã¼berschritten, endet das Spiel in einem Unentschieden. Der Standardwert ist \texttt{5}. Um dieses Limit auszuschalten, muss der Wert auf \texttt{None} gesetzt werden;

\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{collections} \PY{k+kn}{import} \PY{n}{defaultdict}

\PY{k}{class} \PY{n+nc}{GameState}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,}
                 \PY{n}{state} \PY{o}{=} \PY{n}{s0}\PY{p}{,}
                 \PY{n}{player} \PY{o}{=} \PY{n}{PLAYER\PYZus{}1}\PY{p}{,}
                 \PY{n}{algorithm1} \PY{o}{=} \PY{k+kc}{None}\PY{p}{,}
                 \PY{n}{algorithm2} \PY{o}{=} \PY{k+kc}{None}\PY{p}{,}
                 \PY{n}{timeout} \PY{o}{=} \PY{k+kc}{None}\PY{p}{,}
                 \PY{n}{stepwise} \PY{o}{=} \PY{k+kc}{False}\PY{p}{,}
                 \PY{n}{limitMovesWithoutMill} \PY{o}{=} \PY{l+m+mi}{30}\PY{p}{,}
                 \PY{n}{limitStatesCounter} \PY{o}{=} \PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm1} \PY{o}{=} \PY{n}{algorithm1}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm2} \PY{o}{=} \PY{n}{algorithm2}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state} \PY{o}{=} \PY{n}{state}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{=} \PY{n}{player}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{canvas} \PY{o}{=} \PY{n}{setupCanvas}\PY{p}{(}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o}{=} \PY{k+kc}{None}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{information} \PY{o}{=} \PY{k+kc}{None}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{resetStateVariables}\PY{p}{(}\PY{p}{)}

        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{timeout} \PY{o}{=} \PY{n}{timeout}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stepwise} \PY{o}{=} \PY{n}{stepwise}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitMovesWithoutMill} \PY{o}{=} \PY{n}{limitMovesWithoutMill}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{movesWithoutMill} \PY{o}{=} \PY{l+m+mi}{0}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitStatesCounter} \PY{o}{=} \PY{n}{limitStatesCounter}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{statesCounter} \PY{o}{=} \PY{n}{defaultdict}\PY{p}{(}\PY{n+nb}{int}\PY{p}{)}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{pause} \PY{o}{=} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}1} \PY{o+ow}{and} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm1}\PY{p}{)} \PY{o+ow}{or} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}2} \PY{o+ow}{and} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm2}\PY{p}{)}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{pause}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Please click to start the game.}\PY{l+s+s1}{\PYZsq{}}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{.}\PY{n}{on\PYZus{}mouse\PYZus{}up}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{handleGame}\PY{p}{)}
        
        \PY{n}{updateGui}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{)}
        \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{game state initalized}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{updateText}\PY{p}{(}\PY{p}{)}       
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{resetStateVariables} dient zum ZurÃ¼cksetzen der
temporÃ¤ren Hilfsvariablen der Klasse \texttt{GameState}. Diese Funktion
hat weder Ein- noch Ausgabe.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{resetStateVariables}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp} \PY{o}{=} \PY{k+kc}{None}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone} \PY{o}{=} \PY{k+kc}{None}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{k+kc}{None}
    
\PY{n}{GameState}\PY{o}{.}\PY{n}{resetStateVariables} \PY{o}{=} \PY{n}{resetStateVariables}
\PY{k}{del} \PY{n}{resetStateVariables}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{handleGame} steuert den Ablauf des Spiels. Die
Funktion wird bei jedem Mausklick auf das Canvas-Objekt von dem Event
\texttt{on\_mouse\_up} aufgerufen. Die Funktion hat zwei Argumente:

\begin{itemize}
\tightlist
\item
  \texttt{x} ist relative Wert der Maus zu dem Canvas-Objekt auf der
  horizontalen Achse;
\item
  \texttt{y} ist relative Wert der Maus zu dem Canvas-Objekt auf der
  vertikalen Achse.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{handleGame}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Game has ended!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{return}
    
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{pause}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{pause} \PY{o}{=} \PY{k+kc}{False}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{k+kc}{None}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{updateText}\PY{p}{(}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{checkForComputerStep}\PY{p}{(}\PY{p}{)}
    
        \PY{k}{return}

    \PY{n}{phase} \PY{o}{=} \PY{n}{playerPhase}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
    \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{player phase: }\PY{l+s+si}{\PYZob{}}\PY{n}{phase}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    
    \PY{n}{stone} \PY{o}{=} \PY{n}{getClickedStone}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}

    \PY{k}{if} \PY{n}{stone} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{No stone was clicked!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None} \PY{o+ow}{and} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{cancelStep}\PY{p}{(}\PY{p}{)}
    \PY{k}{elif} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{poundMillInGui}\PY{p}{(}\PY{n}{stone}\PY{p}{)}
    \PY{k}{elif} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{moveStone}\PY{p}{(}\PY{n}{stone}\PY{p}{)}
    \PY{k}{elif} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{1}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{placeStone}\PY{p}{(}\PY{n}{stone}\PY{p}{)}
    \PY{k}{elif} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{2} \PY{o+ow}{or} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{3}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectStone}\PY{p}{(}\PY{n}{stone}\PY{p}{)}

    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{information} \PY{o}{=} \PY{k+kc}{None}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{updateText}\PY{p}{(}\PY{p}{)}

    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{checkForComputerStep}\PY{p}{(}\PY{p}{)}

\PY{n}{GameState}\PY{o}{.}\PY{n}{handleGame} \PY{o}{=} \PY{n}{handleGame}
\PY{k}{del} \PY{n}{handleGame}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{togglePlayer} tauscht den Spieler, der den nÃ¤chsten
Zug spielt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{togglePlayer}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{=} \PY{n}{opponent}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
        
\PY{n}{GameState}\PY{o}{.}\PY{n}{togglePlayer} \PY{o}{=} \PY{n}{togglePlayer}
\PY{k}{del} \PY{n}{togglePlayer}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{playNewState} spielt einen vollstÃ¤ndigen Zug in der
GUI. DafÃ¼r hat sie ein Argument:

\begin{itemize}
\tightlist
\item
  \texttt{newState} ist der neue Zustand, der gespielt werden soll.
\end{itemize}

Die Funktion aktualisiert alle benÃ¶tigten Hilfsvariablen in der Klasse
\texttt{GameState} und ruft diverse Funktionen auf, um das Spiel fÃ¼r den
neuen Zug vorzubereiten.

Sind die Regeln fÃ¼r ein Untenschieden \texttt{limitStatesCounter} und
\texttt{limitMovesWithoutMill} aktiviert (also nicht \texttt{None}),
werden die entsprechenden ZÃ¤hler, um die Regeln zu kontrollieren,
aktualisiert. Die Regeln werden jedoch nur aktualisiert, wenn sich die
Spieler nicht mehr in der Setzphase befinden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{playNewState}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{newState}\PY{p}{)}\PY{p}{:} 
    \PY{n}{movedStone}\PY{p}{,} \PY{n}{poundedStones} \PY{o}{=} \PY{n}{getChangedStones}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n}{newState}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
    \PY{n}{phase} \PY{o}{=} \PY{n}{playerPhase}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
    \PY{k}{if} \PY{n}{phase} \PY{o}{!=} \PY{l+m+mi}{1}\PY{p}{:}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitStatesCounter} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{statesCounter}\PY{p}{[}\PY{n}{newState}\PY{p}{]} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{the state }\PY{l+s+si}{\PYZob{}}\PY{n}{newState}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ was played }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{statesCounter}\PY{p}{[}\PY{n}{newState}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ times.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitMovesWithoutMill} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{k}{if} \PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{poundedStones}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{movesWithoutMill} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
            \PY{k}{else}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{movesWithoutMill} \PY{o}{=} \PY{l+m+mi}{0}
            \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{moves without mill: }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{movesWithoutMill}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}

    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state} \PY{o}{=} \PY{n}{newState}
    \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{New State was played:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+si}{\PYZob{}}\PY{n}{newState}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{resetStateVariables}\PY{p}{(}\PY{p}{)}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{togglePlayer}\PY{p}{(}\PY{p}{)}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{checkIfFinished}\PY{p}{(}\PY{p}{)}
    
    \PY{k}{if} \PY{n}{phase} \PY{o}{!=} \PY{l+m+mi}{1}\PY{p}{:}
        \PY{k}{if}  \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitStatesCounter} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{)} \PY{o+ow}{and} \PYZbs{}
            \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{statesCounter}\PY{p}{[}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{]} \PY{o}{+} \PY{l+m+mi}{1} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitStatesCounter}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The state has already been played }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{statesCounter}\PY{p}{[}\PY{n}{newState}\PY{p}{]}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ times. }\PY{l+s+s1}{\PYZsq{}} \PYZbs{}
                            \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{If it is played once more, the game will end in a remis!}\PY{l+s+s1}{\PYZsq{}}

        \PY{k}{if}  \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitMovesWithoutMill} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{)} \PY{o+ow}{and} \PYZbs{}
            \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{movesWithoutMill} \PY{o}{+} \PY{l+m+mi}{5} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitMovesWithoutMill}\PY{p}{)}\PY{p}{:}
                \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{No mill was pound in the last }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{movesWithoutMill}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ moves. }\PY{l+s+s1}{\PYZsq{}} \PYZbs{}
                            \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{In }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitMovesWithoutMill} \PY{o}{\PYZhy{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{movesWithoutMill}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ moves the game will end in a remis!}\PY{l+s+s1}{\PYZsq{}}
            
    \PY{n}{updateGui}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n}{movedStone} \PY{o}{=} \PY{n}{movedStone}\PY{p}{,} \PY{n}{poundedStones} \PY{o}{=} \PY{n}{poundedStones}\PY{p}{)}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{updateText}\PY{p}{(}\PY{p}{)}

\PY{n}{GameState}\PY{o}{.}\PY{n}{playNewState} \PY{o}{=} \PY{n}{playNewState}
\PY{k}{del} \PY{n}{playNewState}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{checkForComputerStep} Ã¼berprÃ¼ft, ob der nÃ¤chste Zug
von einem Algorithmus gespielt werden soll. Falls dies der Fall ist,
wird der jeweilige Algorithmus ausgefÃ¼hrt und der Spielzustand
aktualisiert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{time} \PY{k+kn}{import} \PY{n}{sleep}

\PY{k}{def} \PY{n+nf}{checkForComputerStep}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Game has ended!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{return}
    
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{pause}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Pause!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The game has paused. Please click to continue!}\PY{l+s+s1}{\PYZsq{}}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{updateText}\PY{p}{(}\PY{p}{)}
        \PY{k}{return}
    
    \PY{k}{if} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}1} \PY{o+ow}{and} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm1}\PY{p}{)} \PY{o+ow}{or} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}2} \PY{o+ow}{and} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm2}\PY{p}{)}\PY{p}{:}
        \PY{n}{algorithmName} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm1}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}class\PYZus{}\PYZus{}}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}} \PYZbs{}
                        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}1} \PYZbs{}
                        \PY{k}{else} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm2}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}class\PYZus{}\PYZus{}}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}
        \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Computer calculating for player }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ with algorithm }\PY{l+s+si}{\PYZob{}}\PY{n}{algorithmName}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}1}\PY{p}{:}
            \PY{n}{moves} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm1}\PY{o}{.}\PY{n}{bestMoves}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{moves} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm2}\PY{o}{.}\PY{n}{bestMoves}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
        
        \PY{n}{nextState} \PY{o}{=} \PY{n}{moves}\PY{o}{.}\PY{n}{choice}\PY{p}{(}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{information} \PY{o}{=} \PY{p}{\PYZob{}} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{score}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} \PY{n}{moves}\PY{o}{.}\PY{n}{value} \PY{p}{\PYZcb{}}
        \PY{k}{if} \PY{n}{moves}\PY{o}{.}\PY{n}{debugInformation}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{information}\PY{o}{.}\PY{n}{update}\PY{p}{(}\PY{n}{moves}\PY{o}{.}\PY{n}{debugInformation}\PY{p}{)}
            
        \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Algorithm }\PY{l+s+si}{\PYZob{}}\PY{n}{algorithmName}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ calulated best state with score }\PY{l+s+si}{\PYZob{}}\PY{n}{moves}\PY{o}{.}\PY{n}{value}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Debug Information:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+si}{\PYZob{}}\PY{n}{moves}\PY{o}{.}\PY{n}{debugInformation}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{playNewState}\PY{p}{(}\PY{n}{nextState}\PY{p}{)}
        
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{timeout}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Timeout (}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{timeout}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ seconds). Please wait!}\PY{l+s+s1}{\PYZsq{}}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{updateText}\PY{p}{(}\PY{p}{)}
            \PY{n}{sleep}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{timeout}\PY{p}{)}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{pause} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stepwise}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{checkForComputerStep}\PY{p}{(}\PY{p}{)}
    
\PY{n}{GameState}\PY{o}{.}\PY{n}{checkForComputerStep} \PY{o}{=} \PY{n}{checkForComputerStep}
\PY{k}{del} \PY{n}{checkForComputerStep}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{placeStone} dient zum Platzieren eines
Spielersteins in der Spielphase 1. Die Funktion hat ein Argument:

\begin{itemize}
\tightlist
\item
  \texttt{coord} ist die Koordinate aus dem Tupel \texttt{coords} an dem
  der Stein des Spielers gesetzt werden soll.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{placeStone}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{coord}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{getPlayerAt}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{coord}\PY{p}{)} \PY{o}{!=} \PY{n}{NO\PYZus{}PLAYER}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{coord}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ is not free}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The slot at }\PY{l+s+si}{\PYZob{}}\PY{n}{coord}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ is not free!}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{return}

    \PY{n}{newState} \PY{o}{=} \PY{p}{(}\PY{n}{removeFromStash}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}\PY{p}{,} \PY{n}{place}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{coord}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}\PY{p}{)}

    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{validateNewState}\PY{p}{(}\PY{n}{newState}\PY{p}{)}\PY{p}{:}
        \PY{n}{logging}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{stone placed}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{NewState not in allAvailableStates, checking for new Mills ...}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{checkForNewMills}\PY{p}{(}\PY{n}{newState}\PY{p}{)}

        
\PY{n}{GameState}\PY{o}{.}\PY{n}{placeStone} \PY{o}{=} \PY{n}{placeStone}
\PY{k}{del} \PY{n}{placeStone}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{selectStone} dient zum Selektieren des Steines, der
in der Phase 2 verschoben bzw. in Phase 3 springen soll. Die Funktion
hat ein Argument:

\begin{itemize}
\tightlist
\item
  \texttt{stone} ist die Koordinate des Steines, der bewegt werden soll.
\end{itemize}

Die Funktion erzeugt bei erfolgreicher Validierung einen Hilfszustand in
der GUI mit dem markierten Stein.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{selectStone}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{stone}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{getPlayerAt}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{stone}\PY{p}{)} \PY{o}{!=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{stone}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ is not the own stone}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Please select your own stone!}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{return}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone} \PY{o}{=} \PY{n}{stone}
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{k+kc}{None}
    \PY{n}{updateGui}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n}{selectedStone} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone}\PY{p}{)}

    
\PY{n}{GameState}\PY{o}{.}\PY{n}{selectStone} \PY{o}{=} \PY{n}{selectStone}
\PY{k}{del} \PY{n}{selectStone}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{moveStone} dient zum Bewegen des selektierten
Steins in der Zug- und Endphase. Die Funktion hat ein Argument:

\begin{itemize}
\tightlist
\item
  \texttt{coord} ist die Koordinate, wohin der Stein bewegt werden soll.
\end{itemize}

Der zu bewegende Stein wurde in dem vorherigen Hilfszug in der Funktion
\texttt{selectStone} ausgewÃ¤hlt und in der Hilfsvariablen
\texttt{selectedStone} gespeichert.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{moveStone}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{coord}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n}{getPlayerAt}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{coord}\PY{p}{)} \PY{o}{!=} \PY{n}{NO\PYZus{}PLAYER}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{coord}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ is not free}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The slot at }\PY{l+s+si}{\PYZob{}}\PY{n}{coord}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ is not free!}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{return}
    
    \PY{n}{canJump} \PY{o}{=} \PY{n}{isAllowedToJump}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}

    \PY{k}{if} \PY{n}{canJump} \PY{o+ow}{or} \PY{n}{coord} \PY{o+ow}{in} \PY{n}{findNeighboringEmptyCells}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone}\PY{p}{)}\PY{p}{:}
        \PY{n}{newState} \PY{o}{=} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{place}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone}\PY{p}{,} \PY{n}{NO\PYZus{}PLAYER}\PY{p}{)}\PY{p}{)}
        \PY{n}{newState} \PY{o}{=} \PY{p}{(}\PY{n}{newState}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{place}\PY{p}{(}\PY{n}{newState}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{coord}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}\PY{p}{)}

        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{validateNewState}\PY{p}{(}\PY{n}{newState}\PY{p}{)}\PY{p}{:}
            \PY{n}{movement} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{jumped}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{canJump} \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{moved}\PY{l+s+s1}{\PYZsq{}}
            \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Stone successfully }\PY{l+s+si}{\PYZob{}}\PY{n}{movement}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Round not finished, checking for new mills...}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{checkForNewMills}\PY{p}{(}\PY{n}{newState}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{coord}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ is not a (free) neighbor of }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The slot at }\PY{l+s+si}{\PYZob{}}\PY{n}{coord}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ is not a (free) neighbor of }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{!}\PY{l+s+s1}{\PYZsq{}}

\PY{n}{GameState}\PY{o}{.}\PY{n}{moveStone} \PY{o}{=} \PY{n}{moveStone}
\PY{k}{del} \PY{n}{moveStone}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{checkForNewMills} Ã¼berprÃ¼ft, ob ein gegebener
Zustand neue MÃ¼hlen enthÃ¤lt. Die Funktion hat ein Argument:

\begin{itemize}
\tightlist
\item
  \texttt{newState} ist der neue Zustand, der Ã¼berprÃ¼ft werden soll.
\end{itemize}

Falls neue MÃ¼hlen gefunden worden sind, wird ein temporÃ¤rer Zustand
erstellt, der den menschlichen Spieler auffordert, einen gegnerischen
Stein von dem Spiellbrett zu entfernen. Im Englischen wird dies als
\emph{pounding} bezeichnet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{checkForNewMills}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{newState}\PY{p}{)}\PY{p}{:}
    \PY{n}{oldMills} \PY{o}{=} \PY{n}{findMills}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
    \PY{n}{newMills} \PY{o}{=} \PY{n}{countNewMills}\PY{p}{(}\PY{n}{newState}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{oldMills}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}

    \PY{k}{if} \PY{n}{newMills} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp} \PY{o}{=} \PY{n}{newState}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound} \PY{o}{=} \PY{n}{newMills}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{k+kc}{None}
        \PY{n}{movedStone}\PY{p}{,} \PY{n}{poundedStones} \PY{o}{=} \PY{n}{getChangedStones}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
        \PY{n}{updateGui}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp}\PY{p}{,} \PY{n}{movedStone} \PY{o}{=} \PY{n}{movedStone}\PY{p}{,} \PY{n}{poundedStones} \PY{o}{=} \PY{n}{poundedStones}\PY{p}{)}

\PY{n}{GameState}\PY{o}{.}\PY{n}{checkForNewMills} \PY{o}{=} \PY{n}{checkForNewMills}
\PY{k}{del} \PY{n}{checkForNewMills}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{poundMillInGui} entfernt einen gegnerischen
Spielerstein und beendet somit einen MÃ¼hlenzug. Die Funktion hat dabei
ein Argument:

\begin{itemize}
\tightlist
\item
  \texttt{stone} ist die Koordinate des gegnerischen Spielersteins, der
  entfernt werden soll.
\end{itemize}

Ob ein Spielerstein entfernt werden kann, wird mit der Funktion
\texttt{validateNewState} validiert.

In der Setzphase kann es vorkommen, dass ein Spieler zwei MÃ¼hlen
schlagen kann. In diesem Fall kann das nicht von der Funktion
\texttt{validateNewState} ausfÃ¼hrt werden, weil der Zug noch nicht
abgeschlossen ist und somit nicht in der Menge \texttt{nextStates}
auftritt. In diesem Fall muss die Validierung von der Funktion selber
durchgefÃ¼hrt werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{poundMillInGui}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{stone}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound}  \PY{o}{\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{0}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Player has no Mills to pound!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{return}
    \PY{k}{if} \PY{n}{getPlayerAt}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{stone}\PY{p}{)} \PY{o}{!=} \PY{n}{opponent}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{stone}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ is not the opponent!}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Please select an opponent stone!}\PY{l+s+s1}{\PYZsq{}}
        
        \PY{k}{return}
    \PY{c+c1}{\PYZsh{} if the player has only one mill left to pound, it uses the place function and afterwards}
    \PY{c+c1}{\PYZsh{} validates the newState}
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound} \PY{o}{==} \PY{l+m+mi}{1}\PY{p}{:}
        \PY{n}{newState} \PY{o}{=} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{place}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{stone}\PY{p}{,} \PY{n}{NO\PYZus{}PLAYER}\PY{p}{)}\PY{p}{)}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{validateNewState}\PY{p}{(}\PY{n}{newState}\PY{p}{)}\PY{p}{:}
            \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{success}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Mills could not be pounded! The new state could not be validated by the game logic.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Please do not select an opponent stone that is in a mill!}\PY{l+s+s1}{\PYZsq{}}

        \PY{k}{return}
    
    \PY{c+c1}{\PYZsh{} otherwise the gui has to validate the mill manually,}
    \PY{c+c1}{\PYZsh{} as the intermediate step cannot be checked by the game logic}
    \PY{k}{if} \PY{n}{stone} \PY{o+ow}{in} \PY{n}{getCellsPoundable}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp} \PY{o}{=} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,} \PY{n}{place}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{stone}\PY{p}{,} \PY{n}{NO\PYZus{}PLAYER}\PY{p}{)}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound} \PY{o}{\PYZhy{}}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{k+kc}{None}
        \PY{n}{movedStone}\PY{p}{,} \PY{n}{poundedStones} \PY{o}{=} \PY{n}{getChangedStones}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
        \PY{n}{updateGui}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{stateTemp}\PY{p}{,} \PY{n}{movedStone} \PY{o}{=} \PY{n}{movedStone}\PY{p}{,} \PY{n}{poundedStones} \PY{o}{=} \PY{n}{poundedStones}\PY{p}{)}
    \PY{k}{else}\PY{p}{:}
        \PY{n}{logger}\PY{o}{.}\PY{n}{warning}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Mills could not be pounded! The new state could not be validated by the gui.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Please do not select an opponent stone that is in a mill!}\PY{l+s+s1}{\PYZsq{}}

\PY{n}{GameState}\PY{o}{.}\PY{n}{poundMillInGui} \PY{o}{=} \PY{n}{poundMillInGui}
\PY{k}{del} \PY{n}{poundMillInGui}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{validateNewState} Ã¼berprÃ¼ft, ob ein gegebener
Zustand in der Menge der \texttt{nextStates} vorhanden ist. Die Funktion
hat ein Argument:

\begin{itemize}
\tightlist
\item
  \texttt{newState} ist der neue Zustand, der validert werden soll.
\end{itemize}

Falls sich der neue Zustand \texttt{newState} in der Menge
\texttt{nextStates} von dem aktuellen Zustand \texttt{state} befindet,
ist ein Zug von dem Spieler abgeschlossen. Die Hilfsvariablen werden
zurÃ¼ckgesetzt und es wird der Spieler getauscht.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{validateNewState}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{newState}\PY{p}{)}\PY{p}{:}
    \PY{n}{allAvailableStates} \PY{o}{=} \PY{n}{nextStates}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
    \PY{k}{if} \PY{n}{newState} \PY{o+ow}{in} \PY{n}{allAvailableStates}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{playNewState}\PY{p}{(}\PY{n}{newState}\PY{p}{)}
        \PY{k}{return} \PY{k+kc}{True}
    \PY{k}{return} \PY{k+kc}{False}

\PY{n}{GameState}\PY{o}{.}\PY{n}{validateNewState} \PY{o}{=} \PY{n}{validateNewState}
\PY{k}{del} \PY{n}{validateNewState}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{cancelStep} dient zum Deselektieren eines Steines
in der Zug- oder Endphase.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{cancelStep}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{n}{logger}\PY{o}{.}\PY{n}{warn}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{step is canceled.}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
    
    \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{resetStateVariables}\PY{p}{(}\PY{p}{)}
    \PY{n}{updateGui}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{)}
    
\PY{n}{GameState}\PY{o}{.}\PY{n}{cancelStep} \PY{o}{=} \PY{n}{cancelStep}
\PY{k}{del} \PY{n}{cancelStep}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{updateText} dient zum Aktualisieren des Textes und
des Hinweises auf dem Spielbrett. Die Funktion ermittelt dabei
selbstÃ¤ndig den aktuellen Zustand des Spieles anhand der Variablen
innerhalb der Klasse.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{updateText}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{n}{phase} \PY{o}{=} \PY{n}{playerPhase}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o+ow}{is} \PY{k+kc}{None}\PY{p}{:}
        \PY{n}{message} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Player }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{: }\PY{l+s+s1}{\PYZsq{}}
        
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}1} \PY{o+ow}{and} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm1}\PY{p}{:}
            \PY{n}{message} \PY{o}{+}\PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Computer}\PY{l+s+se}{\PYZbs{}\PYZsq{}}\PY{l+s+s1}{s turn with }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm1}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}class\PYZus{}\PYZus{}}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{. Please wait.}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{elif} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{==} \PY{n}{PLAYER\PYZus{}2} \PY{o+ow}{and} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm2}\PY{p}{:}
            \PY{n}{message} \PY{o}{+}\PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Computer}\PY{l+s+se}{\PYZbs{}\PYZsq{}}\PY{l+s+s1}{s turn with }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{algorithm2}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}class\PYZus{}\PYZus{}}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{. Please wait.}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{elif} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound} \PY{o}{==} \PY{l+m+mi}{1}\PY{p}{:}
            \PY{n}{message} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Pound your mill.}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{elif} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound} \PY{o}{\PYZgt{}} \PY{l+m+mi}{1}\PY{p}{:}
            \PY{n}{message} \PY{o}{+}\PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{You have }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{millsToPound}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ mills left to pound. Please pound your next mill.}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{elif} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{selectedStone} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{n}{movement} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Move}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{2} \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Jump}\PY{l+s+s1}{\PYZsq{}}
            \PY{n}{message} \PY{o}{+}\PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{movement}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ your selected stone.}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{elif} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{1}\PY{p}{:}
            \PY{n}{message} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Place your stone.}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{elif} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{2} \PY{o+ow}{or} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{3}\PY{p}{:}
            \PY{n}{movement} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{move}\PY{l+s+s1}{\PYZsq{}} \PY{k}{if} \PY{n}{phase} \PY{o}{==} \PY{l+m+mi}{2} \PY{k}{else} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{jump}\PY{l+s+s1}{\PYZsq{}}
            \PY{n}{message} \PY{o}{+}\PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{select your stone you want to }\PY{l+s+si}{\PYZob{}}\PY{n}{movement}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{.}\PY{l+s+s1}{\PYZsq{}}      
    \PY{k}{else}\PY{p}{:}
        \PY{n}{message} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The game has ended: }\PY{l+s+s1}{\PYZsq{}}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint} \PY{o}{=} \PY{k+kc}{None}
        \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o}{==} \PY{n}{NO\PYZus{}PLAYER}\PY{p}{:}
            \PY{n}{message} \PY{o}{+}\PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Tie.}\PY{l+s+s1}{\PYZsq{}}
        \PY{k}{else}\PY{p}{:}
            \PY{n}{message} \PY{o}{+}\PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s1}{ has won!}\PY{l+s+s1}{\PYZsq{}}
    \PY{n}{logger}\PY{o}{.}\PY{n}{info}\PY{p}{(}\PY{n}{message}\PY{p}{)}
    \PY{n}{drawText}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{canvas}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{message}\PY{p}{,} \PY{n}{hint} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{hint}\PY{p}{,} \PY{n}{information} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{information}\PY{p}{)}

\PY{n}{GameState}\PY{o}{.}\PY{n}{updateText} \PY{o}{=} \PY{n}{updateText}
\PY{k}{del} \PY{n}{updateText}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{checkIfFinished} Ã¼berprÃ¼ft, ob ein Spiel beendet
worden ist. Dabei benutzt es die Funktionen \texttt{finished} und
\texttt{utility} aus dem Jupyter-Notebookt \texttt{nmm-game}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{checkIfFinished}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
    \PY{k}{if} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitMovesWithoutMill} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{)} \PY{o+ow}{and} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{movesWithoutMill} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitMovesWithoutMill}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o}{=} \PY{n}{NO\PYZus{}PLAYER}
    \PY{k}{elif} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitStatesCounter} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{)} \PY{o+ow}{and} \PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{statesCounter}\PY{p}{[}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{]} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{limitStatesCounter}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o}{=} \PY{n}{NO\PYZus{}PLAYER}
    \PY{k}{elif} \PY{n}{finished}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}\PY{p}{:}
        \PY{n}{status} \PY{o}{=} \PY{n}{utility}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
        \PY{k}{if} \PY{n}{status} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o}{=} \PY{n}{NO\PYZus{}PLAYER}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{k}{if} \PY{n}{status} \PY{o}{==} \PY{l+m+mi}{1} \PY{k}{else} \PY{n}{opponent}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}

\PY{n}{GameState}\PY{o}{.}\PY{n}{checkIfFinished} \PY{o}{=} \PY{n}{checkIfFinished}
\PY{k}{del} \PY{n}{checkIfFinished}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{spielen}{%
\subsection{Spielen}\label{spielen}}

Um das Spiel in der GUI zu spielen, muss zuerst ein Objekt der Klasse
\texttt{GameState} initialisiert werden. Die Argumente fÃ¼r die Klasse
bestimmen die Spieloptionen. Im Folgenden seien vier Beispiele fÃ¼r die
AusfÃ¼hrungsoptionen gegeben.

    \hypertarget{beispiel-1}{%
\subsubsection{Beispiel 1}\label{beispiel-1}}

Der weiÃe Spieler wird von einem Menschen gespielt und der schwarze
Spieler von $\alpha$-$\beta$-Pruning mit der Standardkonfiguration.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} gameState = GameState(algorithm2 = AlphaBetaPruning())}

\PY{c+c1}{\PYZsh{} gameState.canvas}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{beispiel-2}{%
\subsubsection{Beispiel 2}\label{beispiel-2}}

Der weiÃe Spieler wird von einem Menschen gespielt und der schwarze
Spieler von $\alpha$-$\beta$-Pruning mit maximal 1000 ZustÃ¤nden pro Zug.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} gameState = GameState(algorithm2 = AlphaBetaPruning(max\PYZus{}states=1000))}

\PY{c+c1}{\PYZsh{} gameState.canvas}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{beispiel-3}{%
\subsubsection{Beispiel 3}\label{beispiel-3}}

In diesem Spiel spielt $\alpha$-$\beta$-Pruning fÃ¼r weiÃ gegen Minimax fÃ¼r schwarz.
Beide KI's spielen mit der Standardkonfiguration. Nach jedem Zug gibt es
eine automatische Pause von 5 Sekunden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} gameState = GameState(algorithm1 = AlphaBetaPruning(), algorithm2 = Minimax(), timeout=5)}

\PY{c+c1}{\PYZsh{} gameState.canvas}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{beispiel-4}{%
\subsubsection{Beispiel 4}\label{beispiel-4}}

In diesem Spiel spielt $\alpha$-$\beta$-Pruning fÃ¼r weiÃ gegen Minimax fÃ¼r schwarz.
$\alpha$-$\beta$-Pruning spielt mit einer geÃ¤nderten Konfiguration, die auch eine
andere Gewichtung der Heuristik verwendet. Das Spiel wird im
Einzelschrittmodus gespielt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} customWeights = HeuristicWeights(stones = 2, stash = 2, mills = 2, possible\PYZus{}mills = 2)}

\PY{c+c1}{\PYZsh{} gameState = GameState(}
\PY{c+c1}{\PYZsh{}                 algorithm1 = AlphaBetaPruning(max\PYZus{}states = 5\PYZus{}000, weights = customWeights),}
\PY{c+c1}{\PYZsh{}                 algorithm2 = AlphaBetaPruning(),}
\PY{c+c1}{\PYZsh{}                 stepwise = True)}

\PY{c+c1}{\PYZsh{} gameState.canvas}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
    
    
    

    
    \hypertarget{tunier}{%
\section{Tunier}\label{tunier}}

Damit unterschiedliche Algorithmen und deren Einstellungen vergleichen
werden kÃ¶nnen, wird eine virtuelles Tunier implementiert. Bei diesem
Tunier nehmen die Algorithmen in verschiedenen AusfÃ¼hrungen teil und
spielen mehrmals gegeneinander, damit sicher gestellt wird, dass es sich
nicht um Zufall handelt.

Innerhalb eines Tuniers (eng. \texttt{Tournament}) spielen alle
Teilnehmer gegen jeden anderen Teilnehmer, sodass jeder Teilnehmer
einmal als Spieler weiÃ beginnt. Diese Teilnehmerbegegnungen nennen sich
Runden (eng. \texttt{Round}) in denen mehrere Spiele (eng.
\texttt{Match}) gespielt werden.

Am Ende des Tuniers kann dann anhand der Anzahl der Gewinne ausgewertet
werden, welcher Algorithmus mit welcher Einstellung am besten
abschneidet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    ZunÃ¤chst werden beide implementierten Algorithmen geladen:
\texttt{AlphaBetaPruning} und \texttt{Minimax}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}alpha\PYZhy{}beta\PYZhy{}pruning.ipynb
\PY{o}{\PYZpc{}}\PY{k}{run} ./nmm\PYZhy{}minimax.ipynb
\end{Verbatim}
\end{tcolorbox}

    Um eine Ã¼bersichtlichere Entwicklung zu ermÃ¶glichen, werden
Typdefinitionen geladen, welche spÃ¤ter im Code verwendet werden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{typing} \PY{k+kn}{import} \PY{n}{Optional}\PY{p}{,} \PY{n}{Union}\PY{p}{,} \PY{n}{List}\PY{p}{,} \PY{n}{Callable}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{spiel}{%
\subsection{Spiel}\label{spiel}}

Ein Spiel wird durch die Klasse \texttt{Match} implementiert, welche ein
einziges Spiel zwischen zwei Teilnehmern darstellt. Der Konstruktor der
Klasse erwartet zwei verpflichtende Argumente und sechs optionale
Argumente:

Verpflichtend:
\begin{itemize}
    \item \texttt{white} ist eine Instanz einer \texttt{ArtificialIntelligence}, die den weiÃen Spieler spielen wird;
    \item \texttt{black} ist eine Instanz einer \texttt{ArtificialIntelligence}, die den schwarzen Spieler spielen wird;
\end{itemize}

Optional:
\begin{itemize}
    \item \texttt{start\_state} ist der Startzustand, der verwendet werden soll, standardmÃ¤Ãig \texttt{s0};
    \item \texttt{start\_player} ist der Spieler, der das Spiel beginnen soll, standardmÃ¤ig \texttt{w};
    \item \texttt{max\_turns} ist die maximale Anzahl an ZÃ¼gen, die das Spiel dauern darf, bevor es in einem Remis endet, standardmÃ¤Ãig \texttt{250};
    \item \texttt{max\_state\_replayed} ist die maximale Anzahl die ein Zug nochmal gespielt werden darf, bevor das Spiel in einem Remis endet, standardmÃ¤Ãig \texttt{5};
    \item \texttt{max\_states\_without\_mill} ist die maximale Anzahl von aufeinanderfolgenden ZÃ¼gen in denen kein Stein geschlagen wurde, bevor das Spiel in einem Remis endet, standardmÃ¤Ãig \texttt{30};
    \item \texttt{name} ein optionaler Name fÃ¼r das Spiel.
\end{itemize}

Des Weiteren werden zwei Attribute initialisiert, die fÃ¼r den
Spielverlauf nÃ¶tig sind:
\begin{itemize}
    \item \texttt{log} der Verlauf aller ZustÃ¤nde;
    \item \texttt{no\_mill\_played} die Anzahl der letzten ZÃ¼ge ohne eine neue MÃ¼hle.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Match}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}
        \PY{n+nb+bp}{self}\PY{p}{,}
        \PY{n}{white}\PY{p}{:} \PY{n}{ArtificialIntelligence}\PY{p}{,} \PY{n}{black}\PY{p}{:} \PY{n}{ArtificialIntelligence}\PY{p}{,}
        \PY{n}{start\PYZus{}state} \PY{o}{=} \PY{n}{s0}\PY{p}{,} \PY{n}{start\PYZus{}player} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
        \PY{n}{max\PYZus{}turns}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{250}\PY{p}{,} \PY{n}{max\PYZus{}state\PYZus{}replayed}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{5}\PY{p}{,} \PY{n}{max\PYZus{}states\PYZus{}without\PYZus{}mill}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{30}\PY{p}{,}
        \PY{n}{name}\PY{p}{:} \PY{n+nb}{str} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
    \PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{white} \PY{o}{=} \PY{n}{white}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{black} \PY{o}{=} \PY{n}{black}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state} \PY{o}{=} \PY{n}{start\PYZus{}state}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{=} \PY{n}{start\PYZus{}player}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}turns} \PY{o}{=} \PY{n}{max\PYZus{}turns}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}state\PYZus{}replayed} \PY{o}{=} \PY{n}{max\PYZus{}state\PYZus{}replayed}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}states\PYZus{}without\PYZus{}mill} \PY{o}{=} \PY{n}{max\PYZus{}states\PYZus{}without\PYZus{}mill}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{name} \PY{o}{=} \PY{n}{name}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log} \PY{o}{=} \PY{p}{[}\PY{n}{start\PYZus{}state}\PY{p}{]}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{no\PYZus{}mill\PYZus{}played} \PY{o}{=} \PY{l+m+mi}{0}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r Entwicklungszwecke wird eine Stringdarstellung fÃ¼r die Klasse
\texttt{Match} implementiert. Hierzu wird durch die Funktion
\texttt{\_\_repr\_\_} ein String zurÃ¼ckgegeben, der alle Parameter der
Klasse beinhaltet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Match}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Match(name=}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{, white=}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{type}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{white}\PY{p}{)}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
           \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{black=}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{type}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{black}\PY{p}{)}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, max\PYZus{}turns=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}turns}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, }\PY{l+s+s2}{\PYZdq{}} \PY{o}{+} \PYZbs{}
           \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{max\PYZus{}state\PYZus{}replayed=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}state\PYZus{}replayed}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, max\PYZus{}states\PYZus{}without\PYZus{}mill=}\PY{l+s+si}{\PYZob{}}\PY{n}{max\PYZus{}states\PYZus{}without\PYZus{}mill}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{Match}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    Das Ergebnis eines Spiels wird in der \texttt{MatchResult} Klasse
gespeichert. Durch die Aufteilung in die Klassen \texttt{Match} und
\texttt{MatchResult} kann der Garbage Collector die \texttt{Match}
Instanz lÃ¶schen, sobald das Spiel beendet ist und die Variable nicht
mehr verwendet wird. So kÃ¶nnen mÃ¶glicherweise groÃe
Transpositionstabellen gelÃ¶scht werden und der RAM wieder frei gegeben
werden.

Ein \texttt{MatchResult} besteht aus drei Attributen, die im Konstruktor
gesetzt werden mÃ¼ssen:
\begin{itemize}
    \item \texttt{winner} \(\in Player \cup \{'\ '\}\), der Gewinner (oder Remis) des Spieles;
    \item \texttt{log} ist die chronologische Liste aller gespielen ZustÃ¤nde;
    \item \texttt{reason} eine Zeichenkette die genauer beschreibt warum das Spiel endete.
\end{itemize}

FÃ¼r Entwicklungszwecke wird hier ebenfalls eine Stringdarstellung fÃ¼r
die Klasse \texttt{MatchResult} implementiert. Hierzu wird durch die
Funktion \texttt{\_\_repr\_\_} ein String zurÃ¼ckgegeben, der alle
Parameter der Klasse beinhaltet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{MatchResult}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{,} \PY{n}{winner}\PY{p}{:} \PY{n+nb}{str}\PY{p}{,} \PY{n}{log}\PY{p}{:} \PY{n}{List}\PY{p}{,} \PY{n}{reason}\PY{p}{:} \PY{n+nb}{str}\PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner} \PY{o}{=} \PY{n}{winner}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}    \PY{o}{=} \PY{n}{log}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{reason} \PY{o}{=} \PY{n}{reason}
    
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{MatchResult(winner=}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{winner}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{, log=}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}\PY{p}{)}\PY{l+s+si}{:}\PY{l+s+s2}{ \PYZgt{}3}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, reason=}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{reason}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}
\end{Verbatim}
\end{tcolorbox}

    Die Hilfsfunktion \texttt{current\_ai} gibt fÃ¼r das aktuelle Spiel die
KI-Instanz zurÃ¼ck, die gerade am Zug ist.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{current\PYZus{}ai}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Match}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n}{ArtificialIntelligence}\PY{p}{:}
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
        \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{white}
    \PY{k}{return} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{black}

\PY{n}{Match}\PY{o}{.}\PY{n}{current\PYZus{}ai} \PY{o}{=} \PY{n}{current\PYZus{}ai}
\PY{k}{del} \PY{n}{current\PYZus{}ai}
\end{Verbatim}
\end{tcolorbox}

    Die Hilfsfunktion \texttt{check\_remis} Ã¼berprÃ¼ft, ob der aktuelle
Zustand und Spieler zu einem Remis fÃ¼hren. Ist dies der Fall, wird ein
entsprechendes \texttt{MatchResult} mit BegrÃ¼ndung, ansonsten
\texttt{None}, zurÃ¼ckgegeben. GrÃ¼nde fÃ¼r ein Remis sind:

\begin{itemize}
    \item die maximale Anzahl an ZÃ¼gen wurde gespielt - \texttt{max\_turns};
    \item ein Zug wurde Ã¶fter als maximal erlaubt gespielt - \texttt{max\_state\_replayed};
    \item die maximale Anzahl an ZÃ¼gen ohne eine neue MÃ¼hle wurde gespielt - \texttt{max\_states\_without\_mill}.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{check\PYZus{}remis}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Match}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n}{Optional}\PY{p}{[}\PY{n}{MatchResult}\PY{p}{]}\PY{p}{:}
    \PY{k}{if} \PY{n+nb}{len}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}\PY{p}{)} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}turns}\PY{p}{:}
        \PY{k}{return} \PY{n}{MatchResult}\PY{p}{(}
            \PY{n}{winner} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{n}{log}    \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}\PY{p}{,}
            \PY{n}{reason} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Reached max\PYZus{}turns after }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}turns}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ turns}\PY{l+s+s2}{\PYZdq{}}
        \PY{p}{)}
    
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}\PY{o}{.}\PY{n}{count}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{)} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}state\PYZus{}replayed}\PY{p}{:}
        \PY{k}{return} \PY{n}{MatchResult}\PY{p}{(}
            \PY{n}{winner} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{n}{log}    \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}\PY{p}{,}
            \PY{n}{reason} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{State has been replayed for }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}\PY{o}{.}\PY{n}{count}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ turns}\PY{l+s+s2}{\PYZdq{}}
        \PY{p}{)}
    
    \PY{k}{if} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{no\PYZus{}mill\PYZus{}played} \PY{o}{\PYZgt{}}\PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{max\PYZus{}states\PYZus{}without\PYZus{}mill}\PY{p}{:}
        \PY{k}{return} \PY{n}{MatchResult}\PY{p}{(}
            \PY{n}{winner} \PY{o}{=} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,}
            \PY{n}{log}    \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}\PY{p}{,}
            \PY{n}{reason} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{No mill has been played for }\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{no\PYZus{}mill\PYZus{}played}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ turns}\PY{l+s+s2}{\PYZdq{}}
        \PY{p}{)}
    \PY{k}{return} \PY{k+kc}{None}

\PY{n}{Match}\PY{o}{.}\PY{n}{check\PYZus{}remis} \PY{o}{=} \PY{n}{check\PYZus{}remis}
\PY{k}{del} \PY{n}{check\PYZus{}remis}
\end{Verbatim}
\end{tcolorbox}

    Um ein Spiel zu spielen wird die Funktion \texttt{player} implementiert,
diese bedient sich der im \texttt{Match} gespeicherten Einstellungen und
Daten.

Prinzipiell unendlich lang sind die Spieler abwechselnd am Zug und
spielen ihren am besten berechneten Zug. Ein Spiel endet sobald per
\texttt{finished} Funktion ein Gewinner ermittelt wurde oder per
\texttt{check\_remis} Hilfsfunktion ein Remis beschlossen wurde. Ist
dies nicht der Fall, wird der aktuelle Teilnehmer nach dem nÃ¤chsten
(besten) Zug befragt, dieser wird gespeichert und der Gegner ist am Zug.

Da nach einer undefinierten Anzahl an ZÃ¼gen entweder \texttt{finished}
oder \texttt{check\_remis} ein Ergebnis liefern, wird immer eine
\texttt{MatchResult} Instanz zurÃ¼ckgegeben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{play}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Match}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n}{MatchResult}\PY{p}{:}
    \PY{k}{while} \PY{k+kc}{True}\PY{p}{:}
        \PY{n}{remis} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{check\PYZus{}remis}\PY{p}{(}\PY{p}{)}
        \PY{k}{if} \PY{n}{remis} \PY{o+ow}{is} \PY{o+ow}{not} \PY{k+kc}{None}\PY{p}{:}
            \PY{k}{return} \PY{n}{remis}
        
        \PY{k}{if} \PY{n}{finished}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} Remis was already checked}
            \PY{n}{winner} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{k}{if} \PY{n}{utility}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)} \PY{o}{==} \PY{l+m+mi}{1} \PY{k}{else} \PY{n}{opponent}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
            \PY{k}{return} \PY{n}{MatchResult}\PY{p}{(}
                \PY{n}{winner} \PY{o}{=} \PY{n}{winner}\PY{p}{,}
                \PY{n}{log}    \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}\PY{p}{,}
                \PY{n}{reason} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{A player won the match}\PY{l+s+s2}{\PYZdq{}}
            \PY{p}{)}
        
        \PY{n}{mills\PYZus{}before} \PY{o}{=} \PY{n}{findMills}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
        
        \PY{n}{bestMoves} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{current\PYZus{}ai}\PY{p}{(}\PY{p}{)}\PY{o}{.}\PY{n}{bestMoves}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}  \PY{o}{=} \PY{n}{bestMoves}\PY{o}{.}\PY{n}{choice}\PY{p}{(}\PY{p}{)}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player} \PY{o}{=} \PY{n}{opponent}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)}
        
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{log}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{)}
        \PY{k}{if} \PY{n}{playerPhase}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)} \PY{o}{!=} \PY{l+m+mi}{1} \PY{o+ow}{and} \PYZbs{}
           \PY{n}{countNewMills}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{state}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{mills\PYZus{}before}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{player}\PY{p}{)} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{0}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{no\PYZus{}mill\PYZus{}played} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{no\PYZus{}mill\PYZus{}played} \PY{o}{=} \PY{l+m+mi}{0}

\PY{n}{Match}\PY{o}{.}\PY{n}{play} \PY{o}{=} \PY{n}{play}
\PY{k}{del} \PY{n}{play}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{runde}{%
\subsection{Runde}\label{runde}}

Damit zufÃ¤llige Gewinne mÃ¶glichst ausgeschlossen werden, kÃ¶nnen mehrere
Spiele zwischen den gleichen Teilnehmern gleichzeitig in einer Runde
gespielt werden. Hierzu wird die Python Bibliothek
\texttt{multiprocessing} verwendet, die fÃ¼r jedes Spiel einen eigenen
Prozess startet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{multiprocessing} \PY{k+kn}{import} \PY{n}{Pool}
\end{Verbatim}
\end{tcolorbox}

    Die Klasse \texttt{Round} spiegelt solch eine Runde wieder und besitzt
drei Parameter im Konstruktor:
\begin{itemize}
    \item \texttt{white} ist eine Instanz oder eine Funktion die eine \texttt{ArtificialIntelligence} produziert, die den weiÃen Spieler spielt;
    \item \texttt{black} ist eine Instanz oder eine Funktion die eine \texttt{ArtificialIntelligence} produziert, die den schwarzen Spieler spielt;
    \item \texttt{instances} ist die Anzahl der Spiele die gleichzeitig gestartet werden sollen;
    \item \texttt{seed\_offset} ist die Zahl, die auf den Seed addiert werden soll.
\end{itemize}

Die Parameter \texttt{white} und \texttt{black} kÃ¶nnen auch Funktionen
akzeptieren, damit sichergestellt werden kann, dass die Teilnehmer
innerhalb der gestarteten Spiele sich keine Transpositionstabllen teilen
und somit einen Vorteil erhalten kÃ¶nnten.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Round}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}
        \PY{n+nb+bp}{self}\PY{p}{,}
        \PY{n}{white}\PY{p}{:} \PY{n}{Union}\PY{p}{[}\PY{n}{ArtificialIntelligence}\PY{p}{,} \PY{n}{Callable}\PY{p}{]}\PY{p}{,}
        \PY{n}{black}\PY{p}{:} \PY{n}{Union}\PY{p}{[}\PY{n}{ArtificialIntelligence}\PY{p}{,} \PY{n}{Callable}\PY{p}{]}\PY{p}{,}
        \PY{n}{instances}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,}
        \PY{n}{seed\PYZus{}offset}\PY{p}{:} \PY{n+nb}{int}
    \PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{white} \PY{o}{=} \PY{n}{white}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{black} \PY{o}{=} \PY{n}{black}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{instances} \PY{o}{=} \PY{n}{instances}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset} \PY{o}{=} \PY{n}{seed\PYZus{}offset}
\end{Verbatim}
\end{tcolorbox}

    FÃ¼r Entwicklungszwecke wird eine Stringdarstellung fÃ¼r die Klasse
\texttt{Round} implementiert. Hierzu wird durch die Funktion
\texttt{\_\_repr\_\_} ein String zurÃ¼ckgegeben, der alle Parameter der
Klasse beinhaltet.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Round}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Round(white=}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{type}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{white}\PY{p}{)}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, black=}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{type}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{black}\PY{p}{)}\PY{o}{.}\PY{n+nv+vm}{\PYZus{}\PYZus{}name\PYZus{}\PYZus{}}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{, instances=}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{instances}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{)}\PY{l+s+s2}{\PYZdq{}}

\PY{n}{Round}\PY{o}{.}\PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}} \PY{o}{=} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\PY{k}{del} \PY{n+nf+fm}{\PYZus{}\PYZus{}repr\PYZus{}\PYZus{}}
\end{Verbatim}
\end{tcolorbox}

    Die Hilfsfunktion \texttt{execute} wird durch die Python Bibliothek
\texttt{multiprocessing} innerhalb des neu erzeugten Prozesses
ausgefÃ¼hrt. Sie setzt den Seed der Random-Funktion auf den Index der
Runde damit verschiedene Spiele stattfinden und startet das Spiel.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{execute}\PY{p}{(}\PY{n}{match}\PY{p}{)}\PY{p}{:}
    \PY{n}{seed}\PY{p}{,} \PY{n}{rnd} \PY{o}{=} \PY{n}{match}
    \PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{n}{seed}\PY{p}{)}
    \PY{k}{return} \PY{n}{rnd}\PY{o}{.}\PY{n}{play}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{play} erzeugt eine Liste von \texttt{instances}
Spielen und erstellt gegebenenfalls die Instanzen der KIs aus den
gespeicherten Erstellungsfunktionen. Daraufhin werden die Spiele per
\texttt{multiprocessing} und \texttt{execute} Hilfsfunktion in neuen
Prozessen gestartet.

Sobald jedes Spiel beendet wurde, werden die Ergebnisse wieder als Liste
zurÃ¼ck gegeben.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{play}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Round}\PY{p}{)} \PY{o}{\PYZhy{}}\PY{o}{\PYZgt{}} \PY{n}{List}\PY{p}{[}\PY{n}{MatchResult}\PY{p}{]}\PY{p}{:}
    \PY{n}{matches} \PY{o}{=} \PY{p}{[}
        \PY{n}{Match}\PY{p}{(}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{white}\PY{p}{(}\PY{p}{)} \PY{k}{if} \PY{n}{callable}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{white}\PY{p}{)} \PY{k}{else} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{white}\PY{p}{,}
            \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{black}\PY{p}{(}\PY{p}{)} \PY{k}{if} \PY{n}{callable}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{black}\PY{p}{)} \PY{k}{else} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{black}\PY{p}{,}
            \PY{n}{name} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r=}\PY{l+s+si}{\PYZob{}}\PY{n}{i}\PY{l+s+si}{:}\PY{l+s+s2}{ \PYZlt{}2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}
        \PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{instances}\PY{p}{)}
    \PY{p}{]}
    \PY{k}{with} \PY{n}{Pool}\PY{p}{(}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{instances}\PY{p}{)} \PY{k}{as} \PY{n}{pool}\PY{p}{:}
        \PY{k}{return} \PY{n}{pool}\PY{o}{.}\PY{n}{map}\PY{p}{(}\PY{n}{execute}\PY{p}{,} \PY{p}{(}\PY{p}{(}\PY{n}{seed}\PY{o}{+}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset}\PY{p}{,} \PY{n}{match}\PY{p}{)} \PY{k}{for} \PY{n}{seed}\PY{p}{,} \PY{n}{match} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{matches}\PY{p}{)}\PY{p}{)}\PY{p}{)}

\PY{n}{Round}\PY{o}{.}\PY{n}{play} \PY{o}{=} \PY{n}{play}
\PY{k}{del} \PY{n}{play}
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{tunier}{%
\subsection{Tunier}\label{tunier}}

Damit nun verschiedene Teilnehmer in unterschiedlichen Konstellationen
verglichen werden kÃ¶nnen, wurde ein Tunier implementiert. Die Klasse
\texttt{Tournament} erwartet einen verflichtenden und zwei optionale
Parameter:

Verpflichtend:
\begin{itemize}
\item \texttt{participants} ist eine Liste an Teilnehmer
\texttt{ArtificialIntelligence} Instanzen oder Funktionen, die diese
erzeugen;
\end{itemize}

Optional:
\begin{itemize}
    \item \texttt{instances\_per\_round} ist die Anzahl der Spiele die
pro Runde und pro Teilnehmer Konstellation gespielt werden soll;
    \item \texttt{name} ist ein Name, der den Log-Dateien angehÃ¤ngt wird;
    \item \texttt{skip} ist die Anzahl der Runden, die Ã¼bersprungen werden sollen.
Dies ist Hilfreich falls die Berechnungen abbrechen und fortgesetzt
werden sollen;
    \item \texttt{seed\_offset} ist die Zahl, die auf den Seed
einer Runde addiert werden soll. So kÃ¶nnen Runden in Teilen ausgerechnet
werden.
\end{itemize}

Pro Spiel kÃ¶nnen durch die Transpositionstabelle bis zu 6 Gigabyte an
RAM benÃ¶tigt werden. Dementsprechend wird empfohlen die
\texttt{instances\_per\_round} Einstellung zu bearbeiten.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{class} \PY{n+nc}{Tournament}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf+fm}{\PYZus{}\PYZus{}init\PYZus{}\PYZus{}}\PY{p}{(}
        \PY{n+nb+bp}{self}\PY{p}{,}
        \PY{n}{participants}\PY{p}{:} \PY{n}{List}\PY{p}{[}\PY{n}{Union}\PY{p}{[}\PY{n}{ArtificialIntelligence}\PY{p}{,} \PY{n}{Callable}\PY{p}{]}\PY{p}{]}\PY{p}{,}
        \PY{n}{instances\PYZus{}per\PYZus{}round}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{4}\PY{p}{,}
        \PY{n}{name}\PY{p}{:} \PY{n+nb}{str} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{unnamed}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
        \PY{n}{skip}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{0}\PY{p}{,}
        \PY{n}{seed\PYZus{}offset}\PY{p}{:} \PY{n+nb}{int} \PY{o}{=} \PY{l+m+mi}{0}
    \PY{p}{)}\PY{p}{:}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{participants} \PY{o}{=} \PY{n}{participants}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{instances\PYZus{}per\PYZus{}round} \PY{o}{=} \PY{n}{instances\PYZus{}per\PYZus{}round}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{name} \PY{o}{=} \PY{n}{name}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{skip} \PY{o}{=} \PY{n}{skip}
        \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset} \PY{o}{=} \PY{n}{seed\PYZus{}offset}
\end{Verbatim}
\end{tcolorbox}

    Die Hilfsfunktion \texttt{save} speichert die Ergebnisse einer Runde in
einer menschenlesbaren Datei, die nach dem Schema
\texttt{round-NAME-ID.txt} benannt ist. Die Funktion erwartet drei
Parameter:

\begin{itemize}
    \item \texttt{idx} ist die Nummer der aktuellen Runde (wird um
eins erhÃ¶ht, um eine natÃ¼rliche ZÃ¤hlung zu verwenden); 
    \item \texttt{rnd}
ist die aktuelle Runde;
    \item \texttt{results} ist die Liste der Ergebnisse,
die gespeichert werden soll.
\end{itemize}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{save}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Tournament}\PY{p}{,} \PY{n}{idx}\PY{p}{:} \PY{n+nb}{int}\PY{p}{,} \PY{n}{rnd}\PY{p}{:} \PY{n}{Round}\PY{p}{,} \PY{n}{results}\PY{p}{:} \PY{n}{List}\PY{p}{[}\PY{n}{MatchResult}\PY{p}{]}\PY{p}{)}\PY{p}{:}
    \PY{n}{path} \PY{o}{=} \PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{round\PYZhy{}}\PY{l+s+si}{\PYZob{}}\PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{name}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZhy{}}\PY{l+s+si}{\PYZob{}}\PY{n}{idx}\PY{o}{+}\PY{l+m+mi}{1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{.txt}\PY{l+s+s2}{\PYZdq{}}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{n}{path}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{w}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Round: }\PY{l+s+si}{\PYZob{}}\PY{n}{idx}\PY{o}{+}\PY{l+m+mi}{1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        
        \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{Player:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{white} \PY{o}{=} \PY{n}{rnd}\PY{o}{.}\PY{n}{white}\PY{p}{(}\PY{p}{)} \PY{k}{if} \PY{n}{callable}\PY{p}{(}\PY{n}{rnd}\PY{o}{.}\PY{n}{white}\PY{p}{)} \PY{k}{else} \PY{n}{rnd}\PY{o}{.}\PY{n}{white}
        \PY{n}{black} \PY{o}{=} \PY{n}{rnd}\PY{o}{.}\PY{n}{black}\PY{p}{(}\PY{p}{)} \PY{k}{if} \PY{n}{callable}\PY{p}{(}\PY{n}{rnd}\PY{o}{.}\PY{n}{black}\PY{p}{)} \PY{k}{else} \PY{n}{rnd}\PY{o}{.}\PY{n}{black}
        \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{  white: }\PY{l+s+si}{\PYZob{}}\PY{n}{white}\PY{l+s+si}{\PYZcb{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{  black: }\PY{l+s+si}{\PYZob{}}\PY{n}{black}\PY{l+s+si}{\PYZcb{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        
        \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{Result:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{  remis: }\PY{l+s+si}{\PYZob{}}\PY{n+nb}{sum}\PY{p}{(}\PY{n}{result}\PY{o}{.}\PY{n}{winner}\PY{o}{==}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{ }\PY{l+s+s1}{\PYZsq{}} \PY{k}{for} \PY{n}{result} \PY{o+ow}{in} \PY{n}{results}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{  white: }\PY{l+s+si}{\PYZob{}}\PY{n+nb}{sum}\PY{p}{(}\PY{n}{result}\PY{o}{.}\PY{n}{winner}\PY{o}{==}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{w}\PY{l+s+s1}{\PYZsq{}} \PY{k}{for} \PY{n}{result} \PY{o+ow}{in} \PY{n}{results}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{  black: }\PY{l+s+si}{\PYZob{}}\PY{n+nb}{sum}\PY{p}{(}\PY{n}{result}\PY{o}{.}\PY{n}{winner}\PY{o}{==}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{b}\PY{l+s+s1}{\PYZsq{}} \PY{k}{for} \PY{n}{result} \PY{o+ow}{in} \PY{n}{results}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        
        \PY{k}{for} \PY{n}{midx}\PY{p}{,} \PY{n}{result} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{results}\PY{p}{)}\PY{p}{:}
            \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{Match }\PY{l+s+si}{\PYZob{}}\PY{n}{midx}\PY{o}{+}\PY{l+m+mi}{1}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{  Winner: }\PY{l+s+s2}{\PYZsq{}}\PY{l+s+si}{\PYZob{}}\PY{n}{result}\PY{o}{.}\PY{n}{winner}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZsq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{  Reason: }\PY{l+s+si}{\PYZob{}}\PY{n}{result}\PY{o}{.}\PY{n}{reason}\PY{l+s+si}{\PYZcb{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{  Log:}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{k}{for} \PY{n}{sidx}\PY{p}{,} \PY{n}{state} \PY{o+ow}{in} \PY{n+nb}{enumerate}\PY{p}{(}\PY{n}{result}\PY{o}{.}\PY{n}{log}\PY{p}{)}\PY{p}{:}
                \PY{n}{file}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{    }\PY{l+s+si}{\PYZob{}}\PY{n}{sidx}\PY{o}{+}\PY{l+m+mi}{1}\PY{l+s+si}{:}\PY{l+s+s2}{ \PYZgt{}3}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{. }\PY{l+s+si}{\PYZob{}}\PY{n}{state}\PY{l+s+si}{\PYZcb{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{return} \PY{n}{path}

\PY{n}{Tournament}\PY{o}{.}\PY{n}{save} \PY{o}{=} \PY{n}{save}
\PY{k}{del} \PY{n}{save}
\end{Verbatim}
\end{tcolorbox}

    Die Funktion \texttt{play} startet das Tunier und speichert per
Hilfsfunktion \texttt{save} die Ergebnisse in einer Textdatei ab. Die
Laufzeit kann gegebenenfalls mehrere Stunden lang sein. Mit Hilfe der
Bibliotheken \texttt{time} und \texttt{tqdm} wird der Fortschitt
angezeigt.

Hierzu werden alle mÃ¶glichen Konstellationen der Teilnehmer erzeugt,
sodass jeder Teilnehmer gegen jeden anderen Teilnehmer, sowohl als
\emph{weiÃ} als auch als \emph{schwarz}, spielt. Spiele gegen sich
selbst werden nicht durchgefÃ¼hrt.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{time}\PY{o}{,} \PY{n+nn}{tqdm}
\PY{k}{def} \PY{n+nf}{play}\PY{p}{(}\PY{n+nb+bp}{self}\PY{p}{:} \PY{n}{Tournament}\PY{p}{)}\PY{p}{:}
    \PY{n}{rounds} \PY{o}{=} \PY{n+nb}{list}\PY{p}{(}\PY{n+nb}{enumerate}\PY{p}{(}
        \PY{n}{Round}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{instances\PYZus{}per\PYZus{}round}\PY{p}{,} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{seed\PYZus{}offset}\PY{p}{)}
        \PY{k}{for} \PY{n}{a} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{participants}
        \PY{k}{for} \PY{n}{b} \PY{o+ow}{in} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{participants}
        \PY{k}{if} \PY{n}{a} \PY{o}{!=} \PY{n}{b}
    \PY{p}{)}\PY{p}{)}
    
    \PY{k}{for} \PY{n}{idx}\PY{p}{,} \PY{n}{rnd} \PY{o+ow}{in} \PY{n}{tqdm}\PY{o}{.}\PY{n}{tqdm}\PY{p}{(}\PY{n}{rounds}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{idx} \PY{o}{\PYZlt{}} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{skip}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Round }\PY{l+s+si}{\PYZob{}}\PY{n}{idx}\PY{o}{+}\PY{l+m+mi}{1}\PY{l+s+si}{:}\PY{l+s+s2}{ \PYZgt{}2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{/}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{len}\PY{p}{(}\PY{n}{rounds}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ was skipped}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{k}{continue}
        
        \PY{n}{start} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
        \PY{n}{results} \PY{o}{=} \PY{n}{rnd}\PY{o}{.}\PY{n}{play}\PY{p}{(}\PY{p}{)}
        \PY{n}{end} \PY{o}{=} \PY{n}{time}\PY{o}{.}\PY{n}{time}\PY{p}{(}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Round }\PY{l+s+si}{\PYZob{}}\PY{n}{idx}\PY{o}{+}\PY{l+m+mi}{1}\PY{l+s+si}{:}\PY{l+s+s2}{ \PYZgt{}2}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{/}\PY{l+s+si}{\PYZob{}}\PY{n+nb}{len}\PY{p}{(}\PY{n}{rounds}\PY{p}{)}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{ took }\PY{l+s+si}{\PYZob{}}\PY{n}{end}\PY{o}{\PYZhy{}}\PY{n}{start}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{path} \PY{o}{=} \PY{n+nb+bp}{self}\PY{o}{.}\PY{n}{save}\PY{p}{(}\PY{n}{idx}\PY{p}{,} \PY{n}{rnd}\PY{p}{,} \PY{n}{results}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ \PYZgt{} Saved to }\PY{l+s+si}{\PYZob{}}\PY{n}{path}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n}{Tournament}\PY{o}{.}\PY{n}{play} \PY{o}{=} \PY{n}{play}
\PY{k}{del} \PY{n}{play}
\end{Verbatim}
\end{tcolorbox}


    % Add a bibliography block to the postdoc
    
    
    
    
    
    

    
    \hypertarget{fazit}{%
\section{Fazit}\label{fazit}}

Das Ziel der Studienarbeit, eine kÃ¼nstliche Intelligenz fÃ¼r das
Brettspiel MÃ¼hle zu entwickeln, wurde erreicht. Es wurden zwei
Algorithmen mit verschiedenen Verbesserungen implementiert, die ein
interessantes Spiel gegen Menschen ermÃ¶glichen.

\hypertarget{bewertung}{%
\subsection{Bewertung}\label{bewertung}}

Um eine mÃ¶glichst objektive Bewertung der Algorithmen durchzufÃ¼hren,
sollen in diesem Kapitel die Algorithmen \emph{Minimax} und
\emph{$\alpha$-$\beta$-Pruning}, sowie mehrere Heuristiken ausprobiert und
miteinander verglichen werden. Die dazu benÃ¶tigten Implementierungen
wurden bereits im Kapitel \emph{Turnier} vorgenommen.

Jede gespielte Runde ist als Textdatei mit genauem Spielverlauf
aufgezeichnet und in dem Ordner \href{./rounds}{rounds} zu finden.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{os}\PY{n+nn}{.}\PY{n+nn}{path}\PY{o}{,} \PY{n+nn}{struct}
\PY{n}{css} \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{\PYZdq{}}
\PY{k}{if} \PY{n}{os}\PY{o}{.}\PY{n}{path}\PY{o}{.}\PY{n}{isfile}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{:}
    \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{core}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k+kn}{import} \PY{n}{HTML}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{style.html}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{k}{as} \PY{n}{file}\PY{p}{:}
        \PY{n}{css} \PY{o}{=} \PY{n}{file}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
\PY{n}{HTML}\PY{p}{(}\PY{n}{css}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Das zuvor beschriebene Modul \emph{Turnier} muss geladen werden. Durch
das Laden des Moduls werden bereits alle anderen nÃ¶tigen Module wie
\emph{Minimax}, \emph{$\alpha$-$\beta$-Pruning} oder die \emph{Game}-Definition
geladen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{o}{\PYZpc{}}\PY{k}{run} nmm\PYZhy{}tournament.ipynb
\end{Verbatim}
\end{tcolorbox}

    \hypertarget{minimax-vs.ux3b1-ux3b2-pruning}{%
\subsubsection{Minimax
vs.~$\alpha$-$\beta$-Pruning}\label{minimax-vs.ux3b1-ux3b2-pruning}}

In dem ersten Experiment sollen die Algorithmen \emph{Minimax} und
\emph{$\alpha$-$\beta$-Pruning} gegeneinander antreten. Beide verwenden die selbe
Heuristik, welche zufÃ¤llig ausgewÃ¤hlt wurde. Insgesamt werden zwei
Runden Ã  vier Spiele gespielt. Jeder Algorithmus beginnt einmal als der
\emph{weiÃe} Spieler.

\begin{itemize}
\tightlist
\item
  \emph{$\alpha$-$\beta$-Pruning} betrachtet 25.000 Zustande pro Zug. Dies dauert in
  jeder Phase des Spiels ca. 10 Sekunden.
\item
  \emph{Minimax} hingegen durchsucht einen Baum mit der Tiefe drei und
  schaut somit drei SpielzÃ¼ge in die Zukunft. Dies dauert zu Beginn des
  Spiels ca. 35 Sekunden, in der zweiten Phase hingegen ca. 1-2
  Sekunden.
\end{itemize}

Zu erwarten ist, dass \emph{$\alpha$-$\beta$-Pruning} besser als \emph{Minimax}
abschneidet, da es die MÃ¶glichkeit besitzt, TeilbÃ¤ume abzuschneiden,
welche nicht mehr in Frage kommen wÃ¼rden. AuÃerdem kann
\emph{$\alpha$-$\beta$-Pruning} in der zweiten Phase des Spiels aufgrund der
\emph{iterativen Tiefensuche} eine grÃ¶Ãere Rekursionstiefe erreichen.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Tournament}\PY{p}{(}
    \PY{p}{[}
        \PY{k}{lambda}\PY{p}{:} \PY{n}{Minimax}\PY{p}{(}
            \PY{n}{weights}    \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{stash}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{mills}\PY{o}{=}\PY{l+m+mi}{4}\PY{p}{,} \PY{n}{possible\PYZus{}mills}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,}
            \PY{n}{limit}      \PY{o}{=} \PY{l+m+mi}{3}
        \PY{p}{)}\PY{p}{,}
        \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}
            \PY{n}{weights}    \PY{o}{=} \PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{stash}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{mills}\PY{o}{=}\PY{l+m+mi}{4}\PY{p}{,} \PY{n}{possible\PYZus{}mills}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{,}
            \PY{n}{max\PYZus{}states} \PY{o}{=} \PY{l+m+mi}{25\PYZus{}000}
        \PY{p}{)}
    \PY{p}{]}\PY{p}{,}
    \PY{n}{instances\PYZus{}per\PYZus{}round} \PY{o}{=} \PY{l+m+mi}{4}\PY{p}{,}
    \PY{n}{name}                \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{mm\PYZhy{}vs\PYZhy{}ab}\PY{l+s+s2}{\PYZdq{}}
\PY{p}{)}\PY{o}{.}\PY{n}{play}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \includegraphics{../images/nmm-mm-vs-ab.png}

Die vorherige Vermutung lÃ¤sst sich mit diesem Ergebnis bestÃ¤tigen:
\emph{$\alpha$-$\beta$-Pruning} schneidet besser ab als \emph{Minimax}. Dennoch ist
es Ã¼berraschend, dass zwei der Spiele im Remis enden und weitere zwei
Spiele sogar von Minimax gewonnen werden.

Zu dem Gesamtsieg von \emph{$\alpha$-$\beta$-Pruning} hat einerseits der Algorithmus
selbst beigetragen, da dadurch weite Teile des Suchbaumes Ã¼bersprungen
werden konnten. Die Verwendung der \emph{iterativen Tiefensuche} hat mit
einer festen SuchgrÃ¶Ãe dazu beigetragen, dass bei gleichbleibender
Rechenzeit dynamisch die richtige Rekursionstiefe gewÃ¤hlt werden konnte.
Die Erkennung von symmetrischen ZustÃ¤nden hilft besonders in den ersten
ZÃ¼gen eine groÃe Rekursionstiefe zu erreichen, da hier viele Symmetrien
auftauchen. Auch in der letzten fliegenden Phase kÃ¶nnen ein paar
Rechnungen damit eingespaart werden.

    \hypertarget{heuristik-vs.heuristik-ux3b1-ux3b2-pruning}{%
\subsubsection{Heuristik vs.~Heuristik
($\alpha$-$\beta$-Pruning)}\label{heuristik-vs.heuristik-ux3b1-ux3b2-pruning}}

In dem zweiten Experiment soll unter Verwendung des $\alpha$-$\beta$-Pruning
Algorithmus herausgefunden werden, welche Heuristik am besten geeignet
ist. Die Anzahl der mÃ¶glichen Heuristiken ist unendlich groÃ, da jeder
der vier Parameter eine reelle Zahl ist. Aus diesem Grund soll nur ein
kleines Experiment durchgefÃ¼hrt werden. Es treten sechs Konfigurationen
in 3 Spielen pro Runde an. Dadurch ergibt sich eine Rundenanzahl von 30.

Bei diesem Experiment soll die Wichtigkeit der Parameter festgestellt
werden, indem alle mÃ¶glichen Heuristiken mit den Permutationen der
Zahlen \(1, 2, 3\) gegeneinander antreten. Die Parameter \texttt{stones}
und \texttt{stash} erhalten jedoch immer den gleichen Wert, da sich
wÃ¤hrend der Entwicklung gezeigt hat, dass die Algorithmen besonders in
der ersten Phase falsche Entscheidungen treffen, sollten sich diese
Parameter unterscheiden. Als positiver Nebeneffekt verringert sich die
GrÃ¶Ãe des Experimentes.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{Tournament}\PY{p}{(}
    \PY{p}{[}
        \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}\PY{n}{weights}\PY{o}{=}\PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{stash}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{mills}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{possible\PYZus{}mills}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}\PY{p}{,}
        \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}\PY{n}{weights}\PY{o}{=}\PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{stash}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{mills}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{possible\PYZus{}mills}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}\PY{p}{,}
        \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}\PY{n}{weights}\PY{o}{=}\PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{stash}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{mills}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{possible\PYZus{}mills}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{,}
        \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}\PY{n}{weights}\PY{o}{=}\PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{stash}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{mills}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{possible\PYZus{}mills}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{,}
        \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}\PY{n}{weights}\PY{o}{=}\PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{stash}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{mills}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{possible\PYZus{}mills}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{,}
        \PY{k}{lambda}\PY{p}{:} \PY{n}{AlphaBetaPruning}\PY{p}{(}\PY{n}{weights}\PY{o}{=}\PY{n}{HeuristicWeights}\PY{p}{(}\PY{n}{stones}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{stash}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{mills}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{possible\PYZus{}mills}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}\PY{p}{,}
    \PY{p}{]}\PY{p}{,}
    \PY{n}{instances\PYZus{}per\PYZus{}round} \PY{o}{=} \PY{l+m+mi}{3}\PY{p}{,}
    \PY{n}{name}                \PY{o}{=} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{hr\PYZhy{}vs\PYZhy{}hr}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}
\PY{p}{)}\PY{o}{.}\PY{n}{play}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Die Rechenzeit fÃ¼r dieses Experiment betrug ca. 12 Stunden. Dabei
reichte zwischenzeitlich der Arbeitsspeicher von 32GB nicht aus und das
Experiment brach kurzzeitig ab.

Die aggregierten Ergebnisse sind in der folgenden Tabelle dargestellt.
Die detaillierten Ergebnisse sind in den Dateien
\texttt{round-hr-vs-hr-\{1-30\}.txt} zu finden. Die Spalten stellen die
\emph{weiÃen} Spieler dar und die Zeilen die \emph{schwarzen} Spieler.
Jede Heuristik hat einmal als \emph{weiÃ} und einmal als \emph{schwarz}
gegen jede andere Heuristik gespielt. Gegen sich selbst wurde nicht
gespielt (siehe Diagonale ohne Daten).

Der Bezeichner fÃ¼r jede Heurisik ist als Tupel aufgeschrieben, die
folgender Definition entspricht:
\[\langle stones, stash, mills, possible\_mills \rangle\] Eine Zelle in
der Tabelle stellt eine Runde dar und zÃ¤hlt die Anzahl der Spiele in
drei Kategorien: \[WeiÃ\ gewinnt\ |\ Remis\ |\ Schwarz\ gewinnt\]

\includegraphics{../images/nmm-hr-vs-hr-rounds.png}

Aggregiert ergibt sich aus den Rundenergebnissen folgende Tabelle. Alle
Spiele der Heuristiken wurden aufgeschlÃ¼sselt in
\[Gewonnen\ |\ Remis\ |\ Verloren \] FÃ¼r die Punkteberechnung wurde
jedes Gewinnen mit \(+1\) und jedes Verlieren mit \(-1\) bewertet. Ein
Remis hat eine Wertung von \(0\).

\includegraphics{../images/nmm-hr-vs-hr-total.png}

Als klare Verlierer sind die Heuristiken zu bewerten, welche den
Parameter \(possible\_mills\) grÃ¶Ãer als die anderen Parameter gewÃ¤hlt
haben. Beide haben mehr als die HÃ¤lfte der 30 gespielten Spiele verloren
und haben somit auch eine sehr negative Punktwertung.

Mit einem Punkt Vorsprung gewinnt die Heuristik
\(\langle 3,3,2,1 \rangle\) in der Gesamtwertung. Diese gewichtet
\(stones\) und \(stash\) hÃ¶her als \(mills\), welche wiederum hÃ¶her als
\(possible\_mills\) gewichtet werden. Der zweite Platz
\(\langle 2,2,3,1 \rangle\) verliert nur mit einem Punkt. Auch im
direkten Vergleich gewann der erste Platz nur einmal Ã¶fter gegen den
zweiten Platz.

Da diese Werte sehr nah aneinander liegen, kÃ¶nnen diese kleinen
Abweichungen auch durch Zufall entstanden sein. Bei gleich bewerteten
ZÃ¼gen wÃ¤hlt der Algorithmus einen Spielzug zufÃ¤llig aus.

    \hypertarget{verbesserungsmuxf6glichkeiten}{%
\subsection{VerbesserungsmÃ¶glichkeiten}\label{verbesserungsmuxf6glichkeiten}}

Die Implementierung benÃ¶tigt sehr viel Arbeitsspeicher, was jedoch beim
normalen Spielen kein Problem darstellen sollte. Erst wenn zu
Testzwecken mehrere Spiele gleichzeitig gespielt werden, macht sich der
groÃe Arbeitsspeicherverbrauch bemerkbar. Durch die Verwendung einer
Bitmaske kÃ¶nnte der Arbeitsspeicher um ein Vielfaches verringert werden.
Die Ãnderung hÃ¤tte aber eine komplette Neuimplementierung erfordert,
welche den Rahmen der Studienarbeit gesprengt hÃ¤tte.

Die Rechenzeit der Algorithmen ist sehr hoch. Dies hÃ¤ngt stark mit dem
Arbeitsspeicherverbrauch zusammen, da hierdurch mehr Daten kopiert
werden mÃ¼ssen und Berechnungen auf Grund der grÃ¶Ãeren Datenmengen lÃ¤nger
brauchen. Eine Verringerung der Rechenzeit kÃ¶nnte die Algorithmen aus
Sicht des Anwenders besser werden lassen, da in der gleichen Zeit mehr
ZustÃ¤nde in einer grÃ¶Ãeren Rekursionstiefe, und damit weitere ZÃ¼ge in
der Zukunft, betrachtet werden.

Das LÃ¶sen dieser Probleme wÃ¼rde eine komplette Neuimplementierung der
Algorithmen nÃ¶tig machen. Im gleichen Zuge kÃ¶nnte dann jedoch eine
schnellere, kompilierte Sprache fÃ¼r die Implementierung gewÃ¤hlt werden,
beispielsweise \emph{C}, \emph{C++} oder \emph{Rust}.


    % Add a bibliography block to the postdoc
    
    
    
\end{document} 